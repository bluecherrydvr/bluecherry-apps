/* soapC.c
   Generated by gSOAP 2.8.4 from onvif\media\media.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/
#include "stdafx.h"
#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.4 2011-12-22 13:16:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns2__IANA_IfTypes:
		return soap_in_ns2__IANA_IfTypes(soap, NULL, NULL, "ns2:IANA-IfTypes");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns2__ClassType:
		return soap_in_ns2__ClassType(soap, NULL, NULL, "ns2:ClassType");
	case SOAP_TYPE_ns2__Direction:
		return soap_in_ns2__Direction(soap, NULL, NULL, "ns2:Direction");
	case SOAP_TYPE_ns2__PropertyOperation:
		return soap_in_ns2__PropertyOperation(soap, NULL, NULL, "ns2:PropertyOperation");
	case SOAP_TYPE_ns2__IrCutFilterMode:
		return soap_in_ns2__IrCutFilterMode(soap, NULL, NULL, "ns2:IrCutFilterMode");
	case SOAP_TYPE_ns2__WhiteBalanceMode:
		return soap_in_ns2__WhiteBalanceMode(soap, NULL, NULL, "ns2:WhiteBalanceMode");
	case SOAP_TYPE_ns2__Enabled:
		return soap_in_ns2__Enabled(soap, NULL, NULL, "ns2:Enabled");
	case SOAP_TYPE_ns2__ExposureMode:
		return soap_in_ns2__ExposureMode(soap, NULL, NULL, "ns2:ExposureMode");
	case SOAP_TYPE_ns2__ExposurePriority:
		return soap_in_ns2__ExposurePriority(soap, NULL, NULL, "ns2:ExposurePriority");
	case SOAP_TYPE_ns2__BacklightCompensationMode:
		return soap_in_ns2__BacklightCompensationMode(soap, NULL, NULL, "ns2:BacklightCompensationMode");
	case SOAP_TYPE_ns2__WideDynamicMode:
		return soap_in_ns2__WideDynamicMode(soap, NULL, NULL, "ns2:WideDynamicMode");
	case SOAP_TYPE_ns2__AutoFocusMode:
		return soap_in_ns2__AutoFocusMode(soap, NULL, NULL, "ns2:AutoFocusMode");
	case SOAP_TYPE_ns2__MoveStatus:
		return soap_in_ns2__MoveStatus(soap, NULL, NULL, "ns2:MoveStatus");
	case SOAP_TYPE_ns2__RelayMode:
		return soap_in_ns2__RelayMode(soap, NULL, NULL, "ns2:RelayMode");
	case SOAP_TYPE_ns2__RelayIdleState:
		return soap_in_ns2__RelayIdleState(soap, NULL, NULL, "ns2:RelayIdleState");
	case SOAP_TYPE_ns2__RelayLogicalState:
		return soap_in_ns2__RelayLogicalState(soap, NULL, NULL, "ns2:RelayLogicalState");
	case SOAP_TYPE_ns2__SetDateTimeType:
		return soap_in_ns2__SetDateTimeType(soap, NULL, NULL, "ns2:SetDateTimeType");
	case SOAP_TYPE_ns2__FactoryDefaultType:
		return soap_in_ns2__FactoryDefaultType(soap, NULL, NULL, "ns2:FactoryDefaultType");
	case SOAP_TYPE_ns2__SystemLogType:
		return soap_in_ns2__SystemLogType(soap, NULL, NULL, "ns2:SystemLogType");
	case SOAP_TYPE_ns2__CapabilityCategory:
		return soap_in_ns2__CapabilityCategory(soap, NULL, NULL, "ns2:CapabilityCategory");
	case SOAP_TYPE_ns2__DynamicDNSType:
		return soap_in_ns2__DynamicDNSType(soap, NULL, NULL, "ns2:DynamicDNSType");
	case SOAP_TYPE_ns2__IPAddressFilterType:
		return soap_in_ns2__IPAddressFilterType(soap, NULL, NULL, "ns2:IPAddressFilterType");
	case SOAP_TYPE_ns2__IPType:
		return soap_in_ns2__IPType(soap, NULL, NULL, "ns2:IPType");
	case SOAP_TYPE_ns2__NetworkHostType:
		return soap_in_ns2__NetworkHostType(soap, NULL, NULL, "ns2:NetworkHostType");
	case SOAP_TYPE_ns2__NetworkProtocolType:
		return soap_in_ns2__NetworkProtocolType(soap, NULL, NULL, "ns2:NetworkProtocolType");
	case SOAP_TYPE_ns2__IPv6DHCPConfiguration:
		return soap_in_ns2__IPv6DHCPConfiguration(soap, NULL, NULL, "ns2:IPv6DHCPConfiguration");
	case SOAP_TYPE_ns2__Duplex:
		return soap_in_ns2__Duplex(soap, NULL, NULL, "ns2:Duplex");
	case SOAP_TYPE_ns2__DiscoveryMode:
		return soap_in_ns2__DiscoveryMode(soap, NULL, NULL, "ns2:DiscoveryMode");
	case SOAP_TYPE_ns2__ScopeDefinition:
		return soap_in_ns2__ScopeDefinition(soap, NULL, NULL, "ns2:ScopeDefinition");
	case SOAP_TYPE_ns2__TransportProtocol:
		return soap_in_ns2__TransportProtocol(soap, NULL, NULL, "ns2:TransportProtocol");
	case SOAP_TYPE_ns2__StreamType:
		return soap_in_ns2__StreamType(soap, NULL, NULL, "ns2:StreamType");
	case SOAP_TYPE_ns2__AudioEncoding:
		return soap_in_ns2__AudioEncoding(soap, NULL, NULL, "ns2:AudioEncoding");
	case SOAP_TYPE_ns2__H264Profile:
		return soap_in_ns2__H264Profile(soap, NULL, NULL, "ns2:H264Profile");
	case SOAP_TYPE_ns2__Mpeg4Profile:
		return soap_in_ns2__Mpeg4Profile(soap, NULL, NULL, "ns2:Mpeg4Profile");
	case SOAP_TYPE_ns2__VideoEncoding:
		return soap_in_ns2__VideoEncoding(soap, NULL, NULL, "ns2:VideoEncoding");
	case SOAP_TYPE_ns2__UserLevel:
		return soap_in_ns2__UserLevel(soap, NULL, NULL, "ns2:UserLevel");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_ns2__PTZNode:
		return soap_in_ns2__PTZNode(soap, NULL, NULL, "ns2:PTZNode");
	case SOAP_TYPE_ns2__RelayOutput:
		return soap_in_ns2__RelayOutput(soap, NULL, NULL, "ns2:RelayOutput");
	case SOAP_TYPE_ns2__NetworkInterface:
		return soap_in_ns2__NetworkInterface(soap, NULL, NULL, "ns2:NetworkInterface");
	case SOAP_TYPE_ns2__AudioSource:
		return soap_in_ns2__AudioSource(soap, NULL, NULL, "ns2:AudioSource");
	case SOAP_TYPE_ns2__VideoSource:
		return soap_in_ns2__VideoSource(soap, NULL, NULL, "ns2:VideoSource");
	case SOAP_TYPE_ns2__MetadataType:
		return soap_in_ns2__MetadataType(soap, NULL, NULL, "ns2:MetadataType");
	case SOAP_TYPE_ns2__ReferenceParametersType:
		return soap_in_ns2__ReferenceParametersType(soap, NULL, NULL, "ns2:ReferenceParametersType");
	case SOAP_TYPE_ns2__AttributedURIType:
		return soap_in_ns2__AttributedURIType(soap, NULL, NULL, "ns2:AttributedURIType");
	case SOAP_TYPE_ns2__TopicExpressionType:
		return soap_in_ns2__TopicExpressionType(soap, NULL, NULL, "ns2:TopicExpressionType");
	case SOAP_TYPE_ns2__EndpointReferenceType:
		return soap_in_ns2__EndpointReferenceType(soap, NULL, NULL, "ns2:EndpointReferenceType");
	case SOAP_TYPE_ns2__EventStreamExtension:
		return soap_in_ns2__EventStreamExtension(soap, NULL, NULL, "ns2:EventStreamExtension");
	case SOAP_TYPE_ns2__NotificationMessageHolderType:
		return soap_in_ns2__NotificationMessageHolderType(soap, NULL, NULL, "ns2:NotificationMessageHolderType");
	case SOAP_TYPE_ns2__PTZStreamExtension:
		return soap_in_ns2__PTZStreamExtension(soap, NULL, NULL, "ns2:PTZStreamExtension");
	case SOAP_TYPE_ns2__VideoAnalyticsStreamExtension:
		return soap_in_ns2__VideoAnalyticsStreamExtension(soap, NULL, NULL, "ns2:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_ns2__MetadataStreamExtension:
		return soap_in_ns2__MetadataStreamExtension(soap, NULL, NULL, "ns2:MetadataStreamExtension");
	case SOAP_TYPE_ns2__EventStream:
		return soap_in_ns2__EventStream(soap, NULL, NULL, "ns2:EventStream");
	case SOAP_TYPE_ns2__PTZStream:
		return soap_in_ns2__PTZStream(soap, NULL, NULL, "ns2:PTZStream");
	case SOAP_TYPE_ns2__VideoAnalyticsStream:
		return soap_in_ns2__VideoAnalyticsStream(soap, NULL, NULL, "ns2:VideoAnalyticsStream");
	case SOAP_TYPE_ns2__MetadataStream:
		return soap_in_ns2__MetadataStream(soap, NULL, NULL, "ns2:MetadataStream");
	case SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension:
		return soap_in_ns2__SupportedAnalyticsModulesExtension(soap, NULL, NULL, "ns2:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_ns2__SupportedAnalyticsModules:
		return soap_in_ns2__SupportedAnalyticsModules(soap, NULL, NULL, "ns2:SupportedAnalyticsModules");
	case SOAP_TYPE_ns2__SupportedRulesExtension:
		return soap_in_ns2__SupportedRulesExtension(soap, NULL, NULL, "ns2:SupportedRulesExtension");
	case SOAP_TYPE_ns2__SupportedRules:
		return soap_in_ns2__SupportedRules(soap, NULL, NULL, "ns2:SupportedRules");
	case SOAP_TYPE_ns2__ConfigDescriptionExtension:
		return soap_in_ns2__ConfigDescriptionExtension(soap, NULL, NULL, "ns2:ConfigDescriptionExtension");
	case SOAP_TYPE_ns2__ConfigDescription:
		return soap_in_ns2__ConfigDescription(soap, NULL, NULL, "ns2:ConfigDescription");
	case SOAP_TYPE_ns2__RuleEngineConfigurationExtension:
		return soap_in_ns2__RuleEngineConfigurationExtension(soap, NULL, NULL, "ns2:RuleEngineConfigurationExtension");
	case SOAP_TYPE_ns2__RuleEngineConfiguration:
		return soap_in_ns2__RuleEngineConfiguration(soap, NULL, NULL, "ns2:RuleEngineConfiguration");
	case SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension:
		return soap_in_ns2__AnalyticsEngineConfigurationExtension(soap, NULL, NULL, "ns2:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_ns2__Config:
		return soap_in_ns2__Config(soap, NULL, NULL, "ns2:Config");
	case SOAP_TYPE_ns2__AnalyticsEngineConfiguration:
		return soap_in_ns2__AnalyticsEngineConfiguration(soap, NULL, NULL, "ns2:AnalyticsEngineConfiguration");
	case SOAP_TYPE_ns2__ObjectTreeExtension:
		return soap_in_ns2__ObjectTreeExtension(soap, NULL, NULL, "ns2:ObjectTreeExtension");
	case SOAP_TYPE_ns2__BehaviourExtension:
		return soap_in_ns2__BehaviourExtension(soap, NULL, NULL, "ns2:BehaviourExtension");
	case SOAP_TYPE_ns2__Behaviour:
		return soap_in_ns2__Behaviour(soap, NULL, NULL, "ns2:Behaviour");
	case SOAP_TYPE_ns2__Rename:
		return soap_in_ns2__Rename(soap, NULL, NULL, "ns2:Rename");
	case SOAP_TYPE_ns2__Split:
		return soap_in_ns2__Split(soap, NULL, NULL, "ns2:Split");
	case SOAP_TYPE_ns2__ObjectId:
		return soap_in_ns2__ObjectId(soap, NULL, NULL, "ns2:ObjectId");
	case SOAP_TYPE_ns2__Merge:
		return soap_in_ns2__Merge(soap, NULL, NULL, "ns2:Merge");
	case SOAP_TYPE_ns2__FrameExtension:
		return soap_in_ns2__FrameExtension(soap, NULL, NULL, "ns2:FrameExtension");
	case SOAP_TYPE_ns2__ObjectTree:
		return soap_in_ns2__ObjectTree(soap, NULL, NULL, "ns2:ObjectTree");
	case SOAP_TYPE_ns2__Object:
		return soap_in_ns2__Object(soap, NULL, NULL, "ns2:Object");
	case SOAP_TYPE_ns2__Frame:
		return soap_in_ns2__Frame(soap, NULL, NULL, "ns2:Frame");
	case SOAP_TYPE_ns2__TransformationExtension:
		return soap_in_ns2__TransformationExtension(soap, NULL, NULL, "ns2:TransformationExtension");
	case SOAP_TYPE_ns2__ObjectExtension:
		return soap_in_ns2__ObjectExtension(soap, NULL, NULL, "ns2:ObjectExtension");
	case SOAP_TYPE_ns2__ClassDescriptorExtension:
		return soap_in_ns2__ClassDescriptorExtension(soap, NULL, NULL, "ns2:ClassDescriptorExtension");
	case SOAP_TYPE_ns2__ColorDescriptorExtension:
		return soap_in_ns2__ColorDescriptorExtension(soap, NULL, NULL, "ns2:ColorDescriptorExtension");
	case SOAP_TYPE_ns2__ShapeDescriptorExtension:
		return soap_in_ns2__ShapeDescriptorExtension(soap, NULL, NULL, "ns2:ShapeDescriptorExtension");
	case SOAP_TYPE_ns2__AppearanceExtension:
		return soap_in_ns2__AppearanceExtension(soap, NULL, NULL, "ns2:AppearanceExtension");
	case SOAP_TYPE_ns2__ClassDescriptor:
		return soap_in_ns2__ClassDescriptor(soap, NULL, NULL, "ns2:ClassDescriptor");
	case SOAP_TYPE_ns2__ColorDescriptor:
		return soap_in_ns2__ColorDescriptor(soap, NULL, NULL, "ns2:ColorDescriptor");
	case SOAP_TYPE_ns2__ShapeDescriptor:
		return soap_in_ns2__ShapeDescriptor(soap, NULL, NULL, "ns2:ShapeDescriptor");
	case SOAP_TYPE_ns2__Transformation:
		return soap_in_ns2__Transformation(soap, NULL, NULL, "ns2:Transformation");
	case SOAP_TYPE_ns2__Appearance:
		return soap_in_ns2__Appearance(soap, NULL, NULL, "ns2:Appearance");
	case SOAP_TYPE_ns2__ColorCovariance:
		return soap_in_ns2__ColorCovariance(soap, NULL, NULL, "ns2:ColorCovariance");
	case SOAP_TYPE_ns2__Color:
		return soap_in_ns2__Color(soap, NULL, NULL, "ns2:Color");
	case SOAP_TYPE_ns2__Polyline:
		return soap_in_ns2__Polyline(soap, NULL, NULL, "ns2:Polyline");
	case SOAP_TYPE_ns2__Polygon:
		return soap_in_ns2__Polygon(soap, NULL, NULL, "ns2:Polygon");
	case SOAP_TYPE_ns2__Vector:
		return soap_in_ns2__Vector(soap, NULL, NULL, "ns2:Vector");
	case SOAP_TYPE_ns2__ItemListDescriptionExtension:
		return soap_in_ns2__ItemListDescriptionExtension(soap, NULL, NULL, "ns2:ItemListDescriptionExtension");
	case SOAP_TYPE_ns2__MessageDescriptionExtension:
		return soap_in_ns2__MessageDescriptionExtension(soap, NULL, NULL, "ns2:MessageDescriptionExtension");
	case SOAP_TYPE_ns2__ItemListDescription:
		return soap_in_ns2__ItemListDescription(soap, NULL, NULL, "ns2:ItemListDescription");
	case SOAP_TYPE_ns2__MessageDescription:
		return soap_in_ns2__MessageDescription(soap, NULL, NULL, "ns2:MessageDescription");
	case SOAP_TYPE_ns2__ItemListExtension:
		return soap_in_ns2__ItemListExtension(soap, NULL, NULL, "ns2:ItemListExtension");
	case SOAP_TYPE_ns2__ItemList:
		return soap_in_ns2__ItemList(soap, NULL, NULL, "ns2:ItemList");
	case SOAP_TYPE_ns2__MessageExtension:
		return soap_in_ns2__MessageExtension(soap, NULL, NULL, "ns2:MessageExtension");
	case SOAP_TYPE_ns2__FocusOptions20Extension:
		return soap_in_ns2__FocusOptions20Extension(soap, NULL, NULL, "ns2:FocusOptions20Extension");
	case SOAP_TYPE_ns2__WhiteBalanceOptions20Extension:
		return soap_in_ns2__WhiteBalanceOptions20Extension(soap, NULL, NULL, "ns2:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_ns2__FocusConfiguration20Extension:
		return soap_in_ns2__FocusConfiguration20Extension(soap, NULL, NULL, "ns2:FocusConfiguration20Extension");
	case SOAP_TYPE_ns2__WhiteBalance20Extension:
		return soap_in_ns2__WhiteBalance20Extension(soap, NULL, NULL, "ns2:WhiteBalance20Extension");
	case SOAP_TYPE_ns2__RelativeFocusOptions20:
		return soap_in_ns2__RelativeFocusOptions20(soap, NULL, NULL, "ns2:RelativeFocusOptions20");
	case SOAP_TYPE_ns2__MoveOptions20:
		return soap_in_ns2__MoveOptions20(soap, NULL, NULL, "ns2:MoveOptions20");
	case SOAP_TYPE_ns2__ImagingOptions20Extension:
		return soap_in_ns2__ImagingOptions20Extension(soap, NULL, NULL, "ns2:ImagingOptions20Extension");
	case SOAP_TYPE_ns2__WhiteBalanceOptions20:
		return soap_in_ns2__WhiteBalanceOptions20(soap, NULL, NULL, "ns2:WhiteBalanceOptions20");
	case SOAP_TYPE_ns2__WideDynamicRangeOptions20:
		return soap_in_ns2__WideDynamicRangeOptions20(soap, NULL, NULL, "ns2:WideDynamicRangeOptions20");
	case SOAP_TYPE_ns2__FocusOptions20:
		return soap_in_ns2__FocusOptions20(soap, NULL, NULL, "ns2:FocusOptions20");
	case SOAP_TYPE_ns2__ExposureOptions20:
		return soap_in_ns2__ExposureOptions20(soap, NULL, NULL, "ns2:ExposureOptions20");
	case SOAP_TYPE_ns2__BacklightCompensationOptions20:
		return soap_in_ns2__BacklightCompensationOptions20(soap, NULL, NULL, "ns2:BacklightCompensationOptions20");
	case SOAP_TYPE_ns2__ImagingOptions20:
		return soap_in_ns2__ImagingOptions20(soap, NULL, NULL, "ns2:ImagingOptions20");
	case SOAP_TYPE_ns2__ImagingSettingsExtension20:
		return soap_in_ns2__ImagingSettingsExtension20(soap, NULL, NULL, "ns2:ImagingSettingsExtension20");
	case SOAP_TYPE_ns2__WhiteBalance20:
		return soap_in_ns2__WhiteBalance20(soap, NULL, NULL, "ns2:WhiteBalance20");
	case SOAP_TYPE_ns2__WideDynamicRange20:
		return soap_in_ns2__WideDynamicRange20(soap, NULL, NULL, "ns2:WideDynamicRange20");
	case SOAP_TYPE_ns2__FocusConfiguration20:
		return soap_in_ns2__FocusConfiguration20(soap, NULL, NULL, "ns2:FocusConfiguration20");
	case SOAP_TYPE_ns2__Exposure20:
		return soap_in_ns2__Exposure20(soap, NULL, NULL, "ns2:Exposure20");
	case SOAP_TYPE_ns2__BacklightCompensation20:
		return soap_in_ns2__BacklightCompensation20(soap, NULL, NULL, "ns2:BacklightCompensation20");
	case SOAP_TYPE_ns2__ImagingSettings20:
		return soap_in_ns2__ImagingSettings20(soap, NULL, NULL, "ns2:ImagingSettings20");
	case SOAP_TYPE_ns2__FocusStatus20Extension:
		return soap_in_ns2__FocusStatus20Extension(soap, NULL, NULL, "ns2:FocusStatus20Extension");
	case SOAP_TYPE_ns2__ImagingStatus20Extension:
		return soap_in_ns2__ImagingStatus20Extension(soap, NULL, NULL, "ns2:ImagingStatus20Extension");
	case SOAP_TYPE_ns2__FocusStatus20:
		return soap_in_ns2__FocusStatus20(soap, NULL, NULL, "ns2:FocusStatus20");
	case SOAP_TYPE_ns2__ImagingStatus20:
		return soap_in_ns2__ImagingStatus20(soap, NULL, NULL, "ns2:ImagingStatus20");
	case SOAP_TYPE_ns2__ContinuousFocusOptions:
		return soap_in_ns2__ContinuousFocusOptions(soap, NULL, NULL, "ns2:ContinuousFocusOptions");
	case SOAP_TYPE_ns2__RelativeFocusOptions:
		return soap_in_ns2__RelativeFocusOptions(soap, NULL, NULL, "ns2:RelativeFocusOptions");
	case SOAP_TYPE_ns2__AbsoluteFocusOptions:
		return soap_in_ns2__AbsoluteFocusOptions(soap, NULL, NULL, "ns2:AbsoluteFocusOptions");
	case SOAP_TYPE_ns2__MoveOptions:
		return soap_in_ns2__MoveOptions(soap, NULL, NULL, "ns2:MoveOptions");
	case SOAP_TYPE_ns2__ContinuousFocus:
		return soap_in_ns2__ContinuousFocus(soap, NULL, NULL, "ns2:ContinuousFocus");
	case SOAP_TYPE_ns2__RelativeFocus:
		return soap_in_ns2__RelativeFocus(soap, NULL, NULL, "ns2:RelativeFocus");
	case SOAP_TYPE_ns2__AbsoluteFocus:
		return soap_in_ns2__AbsoluteFocus(soap, NULL, NULL, "ns2:AbsoluteFocus");
	case SOAP_TYPE_ns2__FocusMove:
		return soap_in_ns2__FocusMove(soap, NULL, NULL, "ns2:FocusMove");
	case SOAP_TYPE_ns2__WhiteBalanceOptions:
		return soap_in_ns2__WhiteBalanceOptions(soap, NULL, NULL, "ns2:WhiteBalanceOptions");
	case SOAP_TYPE_ns2__WideDynamicRangeOptions:
		return soap_in_ns2__WideDynamicRangeOptions(soap, NULL, NULL, "ns2:WideDynamicRangeOptions");
	case SOAP_TYPE_ns2__FocusOptions:
		return soap_in_ns2__FocusOptions(soap, NULL, NULL, "ns2:FocusOptions");
	case SOAP_TYPE_ns2__ExposureOptions:
		return soap_in_ns2__ExposureOptions(soap, NULL, NULL, "ns2:ExposureOptions");
	case SOAP_TYPE_ns2__BacklightCompensationOptions:
		return soap_in_ns2__BacklightCompensationOptions(soap, NULL, NULL, "ns2:BacklightCompensationOptions");
	case SOAP_TYPE_ns2__ImagingOptions:
		return soap_in_ns2__ImagingOptions(soap, NULL, NULL, "ns2:ImagingOptions");
	case SOAP_TYPE_ns2__Rectangle:
		return soap_in_ns2__Rectangle(soap, NULL, NULL, "ns2:Rectangle");
	case SOAP_TYPE_ns2__ImagingSettingsExtension:
		return soap_in_ns2__ImagingSettingsExtension(soap, NULL, NULL, "ns2:ImagingSettingsExtension");
	case SOAP_TYPE_ns2__WhiteBalance:
		return soap_in_ns2__WhiteBalance(soap, NULL, NULL, "ns2:WhiteBalance");
	case SOAP_TYPE_ns2__WideDynamicRange:
		return soap_in_ns2__WideDynamicRange(soap, NULL, NULL, "ns2:WideDynamicRange");
	case SOAP_TYPE_ns2__Exposure:
		return soap_in_ns2__Exposure(soap, NULL, NULL, "ns2:Exposure");
	case SOAP_TYPE_ns2__BacklightCompensation:
		return soap_in_ns2__BacklightCompensation(soap, NULL, NULL, "ns2:BacklightCompensation");
	case SOAP_TYPE_ns2__ImagingSettings:
		return soap_in_ns2__ImagingSettings(soap, NULL, NULL, "ns2:ImagingSettings");
	case SOAP_TYPE_ns2__FocusConfiguration:
		return soap_in_ns2__FocusConfiguration(soap, NULL, NULL, "ns2:FocusConfiguration");
	case SOAP_TYPE_ns2__FocusStatus:
		return soap_in_ns2__FocusStatus(soap, NULL, NULL, "ns2:FocusStatus");
	case SOAP_TYPE_ns2__ImagingStatus:
		return soap_in_ns2__ImagingStatus(soap, NULL, NULL, "ns2:ImagingStatus");
	case SOAP_TYPE_ns2__PTZPreset:
		return soap_in_ns2__PTZPreset(soap, NULL, NULL, "ns2:PTZPreset");
	case SOAP_TYPE_ns2__PTZMoveStatus:
		return soap_in_ns2__PTZMoveStatus(soap, NULL, NULL, "ns2:PTZMoveStatus");
	case SOAP_TYPE_ns2__PTZStatus:
		return soap_in_ns2__PTZStatus(soap, NULL, NULL, "ns2:PTZStatus");
	case SOAP_TYPE_ns2__PTZSpeed:
		return soap_in_ns2__PTZSpeed(soap, NULL, NULL, "ns2:PTZSpeed");
	case SOAP_TYPE_ns2__PTZVector:
		return soap_in_ns2__PTZVector(soap, NULL, NULL, "ns2:PTZVector");
	case SOAP_TYPE_ns2__Vector1D:
		return soap_in_ns2__Vector1D(soap, NULL, NULL, "ns2:Vector1D");
	case SOAP_TYPE_ns2__Vector2D:
		return soap_in_ns2__Vector2D(soap, NULL, NULL, "ns2:Vector2D");
	case SOAP_TYPE_ns2__PTZSpacesExtension:
		return soap_in_ns2__PTZSpacesExtension(soap, NULL, NULL, "ns2:PTZSpacesExtension");
	case SOAP_TYPE_ns2__Space1DDescription:
		return soap_in_ns2__Space1DDescription(soap, NULL, NULL, "ns2:Space1DDescription");
	case SOAP_TYPE_ns2__ZoomLimits:
		return soap_in_ns2__ZoomLimits(soap, NULL, NULL, "ns2:ZoomLimits");
	case SOAP_TYPE_ns2__Space2DDescription:
		return soap_in_ns2__Space2DDescription(soap, NULL, NULL, "ns2:Space2DDescription");
	case SOAP_TYPE_ns2__PanTiltLimits:
		return soap_in_ns2__PanTiltLimits(soap, NULL, NULL, "ns2:PanTiltLimits");
	case SOAP_TYPE_ns2__PTZSpaces:
		return soap_in_ns2__PTZSpaces(soap, NULL, NULL, "ns2:PTZSpaces");
	case SOAP_TYPE_ns2__PTZConfigurationOptions:
		return soap_in_ns2__PTZConfigurationOptions(soap, NULL, NULL, "ns2:PTZConfigurationOptions");
	case SOAP_TYPE_ns2__PTZConfigurationExtension:
		return soap_in_ns2__PTZConfigurationExtension(soap, NULL, NULL, "ns2:PTZConfigurationExtension");
	case SOAP_TYPE_ns2__PTZNodeExtension:
		return soap_in_ns2__PTZNodeExtension(soap, NULL, NULL, "ns2:PTZNodeExtension");
	case SOAP_TYPE_ns2__RelayOutputSettings:
		return soap_in_ns2__RelayOutputSettings(soap, NULL, NULL, "ns2:RelayOutputSettings");
	case SOAP_TYPE_ns2__CertificateStatus:
		return soap_in_ns2__CertificateStatus(soap, NULL, NULL, "ns2:CertificateStatus");
	case SOAP_TYPE_ns2__Certificate:
		return soap_in_ns2__Certificate(soap, NULL, NULL, "ns2:Certificate");
	case SOAP_TYPE_ns2__CertificateGenerationParametersExtension:
		return soap_in_ns2__CertificateGenerationParametersExtension(soap, NULL, NULL, "ns2:CertificateGenerationParametersExtension");
	case SOAP_TYPE_ns2__CertificateGenerationParameters:
		return soap_in_ns2__CertificateGenerationParameters(soap, NULL, NULL, "ns2:CertificateGenerationParameters");
	case SOAP_TYPE_ns2__Date:
		return soap_in_ns2__Date(soap, NULL, NULL, "ns2:Date");
	case SOAP_TYPE_ns2__Time:
		return soap_in_ns2__Time(soap, NULL, NULL, "ns2:Time");
	case SOAP_TYPE_ns2__SystemDateTimeExtension:
		return soap_in_ns2__SystemDateTimeExtension(soap, NULL, NULL, "ns2:SystemDateTimeExtension");
	case SOAP_TYPE_ns2__DateTime:
		return soap_in_ns2__DateTime(soap, NULL, NULL, "ns2:DateTime");
	case SOAP_TYPE_ns2__TimeZone:
		return soap_in_ns2__TimeZone(soap, NULL, NULL, "ns2:TimeZone");
	case SOAP_TYPE_ns2__SystemDateTime:
		return soap_in_ns2__SystemDateTime(soap, NULL, NULL, "ns2:SystemDateTime");
	case SOAP_TYPE_ns2__BackupFile:
		return soap_in_ns2__BackupFile(soap, NULL, NULL, "ns2:BackupFile");
	case SOAP_TYPE_ns2__BinaryData:
		return soap_in_ns2__BinaryData(soap, NULL, NULL, "ns2:BinaryData");
	case SOAP_TYPE_ns2__SupportInformation:
		return soap_in_ns2__SupportInformation(soap, NULL, NULL, "ns2:SupportInformation");
	case SOAP_TYPE_ns2__AttachmentData:
		return soap_in_ns2__AttachmentData(soap, NULL, NULL, "ns2:AttachmentData");
	case SOAP_TYPE_ns2__SystemLog:
		return soap_in_ns2__SystemLog(soap, NULL, NULL, "ns2:SystemLog");
	case SOAP_TYPE_ns2__SystemCapabilitiesExtension:
		return soap_in_ns2__SystemCapabilitiesExtension(soap, NULL, NULL, "ns2:SystemCapabilitiesExtension");
	case SOAP_TYPE_ns2__OnvifVersion:
		return soap_in_ns2__OnvifVersion(soap, NULL, NULL, "ns2:OnvifVersion");
	case SOAP_TYPE_ns2__StorageCapabilities:
		return soap_in_ns2__StorageCapabilities(soap, NULL, NULL, "ns2:StorageCapabilities");
	case SOAP_TYPE_ns2__SecurityCapabilitiesExtension:
		return soap_in_ns2__SecurityCapabilitiesExtension(soap, NULL, NULL, "ns2:SecurityCapabilitiesExtension");
	case SOAP_TYPE_ns2__NetworkCapabilitiesExtension:
		return soap_in_ns2__NetworkCapabilitiesExtension(soap, NULL, NULL, "ns2:NetworkCapabilitiesExtension");
	case SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension:
		return soap_in_ns2__RealTimeStreamingCapabilitiesExtension(soap, NULL, NULL, "ns2:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_ns2__ProfileCapabilities:
		return soap_in_ns2__ProfileCapabilities(soap, NULL, NULL, "ns2:ProfileCapabilities");
	case SOAP_TYPE_ns2__MediaCapabilitiesExtension:
		return soap_in_ns2__MediaCapabilitiesExtension(soap, NULL, NULL, "ns2:MediaCapabilitiesExtension");
	case SOAP_TYPE_ns2__RealTimeStreamingCapabilities:
		return soap_in_ns2__RealTimeStreamingCapabilities(soap, NULL, NULL, "ns2:RealTimeStreamingCapabilities");
	case SOAP_TYPE_ns2__IOCapabilitiesExtension:
		return soap_in_ns2__IOCapabilitiesExtension(soap, NULL, NULL, "ns2:IOCapabilitiesExtension");
	case SOAP_TYPE_ns2__DeviceCapabilitiesExtension:
		return soap_in_ns2__DeviceCapabilitiesExtension(soap, NULL, NULL, "ns2:DeviceCapabilitiesExtension");
	case SOAP_TYPE_ns2__SecurityCapabilities:
		return soap_in_ns2__SecurityCapabilities(soap, NULL, NULL, "ns2:SecurityCapabilities");
	case SOAP_TYPE_ns2__IOCapabilities:
		return soap_in_ns2__IOCapabilities(soap, NULL, NULL, "ns2:IOCapabilities");
	case SOAP_TYPE_ns2__SystemCapabilities:
		return soap_in_ns2__SystemCapabilities(soap, NULL, NULL, "ns2:SystemCapabilities");
	case SOAP_TYPE_ns2__NetworkCapabilities:
		return soap_in_ns2__NetworkCapabilities(soap, NULL, NULL, "ns2:NetworkCapabilities");
	case SOAP_TYPE_ns2__CapabilitiesExtension:
		return soap_in_ns2__CapabilitiesExtension(soap, NULL, NULL, "ns2:CapabilitiesExtension");
	case SOAP_TYPE_ns2__PTZCapabilities:
		return soap_in_ns2__PTZCapabilities(soap, NULL, NULL, "ns2:PTZCapabilities");
	case SOAP_TYPE_ns2__MediaCapabilities:
		return soap_in_ns2__MediaCapabilities(soap, NULL, NULL, "ns2:MediaCapabilities");
	case SOAP_TYPE_ns2__ImagingCapabilities:
		return soap_in_ns2__ImagingCapabilities(soap, NULL, NULL, "ns2:ImagingCapabilities");
	case SOAP_TYPE_ns2__EventCapabilities:
		return soap_in_ns2__EventCapabilities(soap, NULL, NULL, "ns2:EventCapabilities");
	case SOAP_TYPE_ns2__DeviceCapabilities:
		return soap_in_ns2__DeviceCapabilities(soap, NULL, NULL, "ns2:DeviceCapabilities");
	case SOAP_TYPE_ns2__AnalyticsCapabilities:
		return soap_in_ns2__AnalyticsCapabilities(soap, NULL, NULL, "ns2:AnalyticsCapabilities");
	case SOAP_TYPE_ns2__Capabilities:
		return soap_in_ns2__Capabilities(soap, NULL, NULL, "ns2:Capabilities");
	case SOAP_TYPE_ns2__IPAddressFilterExtension:
		return soap_in_ns2__IPAddressFilterExtension(soap, NULL, NULL, "ns2:IPAddressFilterExtension");
	case SOAP_TYPE_ns2__IPAddressFilter:
		return soap_in_ns2__IPAddressFilter(soap, NULL, NULL, "ns2:IPAddressFilter");
	case SOAP_TYPE_ns2__NetworkZeroConfigurationExtension:
		return soap_in_ns2__NetworkZeroConfigurationExtension(soap, NULL, NULL, "ns2:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_ns2__NetworkZeroConfiguration:
		return soap_in_ns2__NetworkZeroConfiguration(soap, NULL, NULL, "ns2:NetworkZeroConfiguration");
	case SOAP_TYPE_ns2__NetworkGateway:
		return soap_in_ns2__NetworkGateway(soap, NULL, NULL, "ns2:NetworkGateway");
	case SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension:
		return soap_in_ns2__NetworkInterfaceSetConfigurationExtension(soap, NULL, NULL, "ns2:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration:
		return soap_in_ns2__IPv6NetworkInterfaceSetConfiguration(soap, NULL, NULL, "ns2:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration:
		return soap_in_ns2__IPv4NetworkInterfaceSetConfiguration(soap, NULL, NULL, "ns2:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration:
		return soap_in_ns2__NetworkInterfaceSetConfiguration(soap, NULL, NULL, "ns2:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_ns2__DynamicDNSInformationExtension:
		return soap_in_ns2__DynamicDNSInformationExtension(soap, NULL, NULL, "ns2:DynamicDNSInformationExtension");
	case SOAP_TYPE_ns2__DynamicDNSInformation:
		return soap_in_ns2__DynamicDNSInformation(soap, NULL, NULL, "ns2:DynamicDNSInformation");
	case SOAP_TYPE_ns2__NTPInformationExtension:
		return soap_in_ns2__NTPInformationExtension(soap, NULL, NULL, "ns2:NTPInformationExtension");
	case SOAP_TYPE_ns2__NTPInformation:
		return soap_in_ns2__NTPInformation(soap, NULL, NULL, "ns2:NTPInformation");
	case SOAP_TYPE_ns2__DNSInformationExtension:
		return soap_in_ns2__DNSInformationExtension(soap, NULL, NULL, "ns2:DNSInformationExtension");
	case SOAP_TYPE_ns2__DNSInformation:
		return soap_in_ns2__DNSInformation(soap, NULL, NULL, "ns2:DNSInformation");
	case SOAP_TYPE_ns2__HostnameInformationExtension:
		return soap_in_ns2__HostnameInformationExtension(soap, NULL, NULL, "ns2:HostnameInformationExtension");
	case SOAP_TYPE_ns2__HostnameInformation:
		return soap_in_ns2__HostnameInformation(soap, NULL, NULL, "ns2:HostnameInformation");
	case SOAP_TYPE_ns2__NetworkHostExtension:
		return soap_in_ns2__NetworkHostExtension(soap, NULL, NULL, "ns2:NetworkHostExtension");
	case SOAP_TYPE_ns2__NetworkHost:
		return soap_in_ns2__NetworkHost(soap, NULL, NULL, "ns2:NetworkHost");
	case SOAP_TYPE_ns2__NetworkProtocolExtension:
		return soap_in_ns2__NetworkProtocolExtension(soap, NULL, NULL, "ns2:NetworkProtocolExtension");
	case SOAP_TYPE_ns2__NetworkProtocol:
		return soap_in_ns2__NetworkProtocol(soap, NULL, NULL, "ns2:NetworkProtocol");
	case SOAP_TYPE_ns2__IPv6ConfigurationExtension:
		return soap_in_ns2__IPv6ConfigurationExtension(soap, NULL, NULL, "ns2:IPv6ConfigurationExtension");
	case SOAP_TYPE_ns2__PrefixedIPv6Address:
		return soap_in_ns2__PrefixedIPv6Address(soap, NULL, NULL, "ns2:PrefixedIPv6Address");
	case SOAP_TYPE_ns2__PrefixedIPv4Address:
		return soap_in_ns2__PrefixedIPv4Address(soap, NULL, NULL, "ns2:PrefixedIPv4Address");
	case SOAP_TYPE_ns2__IPv4Configuration:
		return soap_in_ns2__IPv4Configuration(soap, NULL, NULL, "ns2:IPv4Configuration");
	case SOAP_TYPE_ns2__IPv4NetworkInterface:
		return soap_in_ns2__IPv4NetworkInterface(soap, NULL, NULL, "ns2:IPv4NetworkInterface");
	case SOAP_TYPE_ns2__IPv6Configuration:
		return soap_in_ns2__IPv6Configuration(soap, NULL, NULL, "ns2:IPv6Configuration");
	case SOAP_TYPE_ns2__IPv6NetworkInterface:
		return soap_in_ns2__IPv6NetworkInterface(soap, NULL, NULL, "ns2:IPv6NetworkInterface");
	case SOAP_TYPE_ns2__NetworkInterfaceInfo:
		return soap_in_ns2__NetworkInterfaceInfo(soap, NULL, NULL, "ns2:NetworkInterfaceInfo");
	case SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting:
		return soap_in_ns2__NetworkInterfaceConnectionSetting(soap, NULL, NULL, "ns2:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_ns2__NetworkInterfaceLink:
		return soap_in_ns2__NetworkInterfaceLink(soap, NULL, NULL, "ns2:NetworkInterfaceLink");
	case SOAP_TYPE_ns2__NetworkInterfaceExtension:
		return soap_in_ns2__NetworkInterfaceExtension(soap, NULL, NULL, "ns2:NetworkInterfaceExtension");
	case SOAP_TYPE_ns2__Scope:
		return soap_in_ns2__Scope(soap, NULL, NULL, "ns2:Scope");
	case SOAP_TYPE_ns2__Transport:
		return soap_in_ns2__Transport(soap, NULL, NULL, "ns2:Transport");
	case SOAP_TYPE_ns2__IPAddress:
		return soap_in_ns2__IPAddress(soap, NULL, NULL, "ns2:IPAddress");
	case SOAP_TYPE_ns2__MulticastConfiguration:
		return soap_in_ns2__MulticastConfiguration(soap, NULL, NULL, "ns2:MulticastConfiguration");
	case SOAP_TYPE_ns2__PTZStatusFilterOptions:
		return soap_in_ns2__PTZStatusFilterOptions(soap, NULL, NULL, "ns2:PTZStatusFilterOptions");
	case SOAP_TYPE_ns2__MetadataConfigurationOptions:
		return soap_in_ns2__MetadataConfigurationOptions(soap, NULL, NULL, "ns2:MetadataConfigurationOptions");
	case SOAP_TYPE_ns2__FilterType:
		return soap_in_ns2__FilterType(soap, NULL, NULL, "ns2:FilterType");
	case SOAP_TYPE_ns2__EventSubscription:
		return soap_in_ns2__EventSubscription(soap, NULL, NULL, "ns2:EventSubscription");
	case SOAP_TYPE_ns2__PTZFilter:
		return soap_in_ns2__PTZFilter(soap, NULL, NULL, "ns2:PTZFilter");
	case SOAP_TYPE_ns2__AudioEncoderConfigurationOption:
		return soap_in_ns2__AudioEncoderConfigurationOption(soap, NULL, NULL, "ns2:AudioEncoderConfigurationOption");
	case SOAP_TYPE_ns2__AudioEncoderConfigurationOptions:
		return soap_in_ns2__AudioEncoderConfigurationOptions(soap, NULL, NULL, "ns2:AudioEncoderConfigurationOptions");
	case SOAP_TYPE_ns2__AudioSourceOptionsExtension:
		return soap_in_ns2__AudioSourceOptionsExtension(soap, NULL, NULL, "ns2:AudioSourceOptionsExtension");
	case SOAP_TYPE_ns2__AudioSourceConfigurationOptions:
		return soap_in_ns2__AudioSourceConfigurationOptions(soap, NULL, NULL, "ns2:AudioSourceConfigurationOptions");
	case SOAP_TYPE_ns2__VideoEncoderOptionsExtension:
		return soap_in_ns2__VideoEncoderOptionsExtension(soap, NULL, NULL, "ns2:VideoEncoderOptionsExtension");
	case SOAP_TYPE_ns2__H264Options:
		return soap_in_ns2__H264Options(soap, NULL, NULL, "ns2:H264Options");
	case SOAP_TYPE_ns2__Mpeg4Options:
		return soap_in_ns2__Mpeg4Options(soap, NULL, NULL, "ns2:Mpeg4Options");
	case SOAP_TYPE_ns2__JpegOptions:
		return soap_in_ns2__JpegOptions(soap, NULL, NULL, "ns2:JpegOptions");
	case SOAP_TYPE_ns2__H264Configuration:
		return soap_in_ns2__H264Configuration(soap, NULL, NULL, "ns2:H264Configuration");
	case SOAP_TYPE_ns2__Mpeg4Configuration:
		return soap_in_ns2__Mpeg4Configuration(soap, NULL, NULL, "ns2:Mpeg4Configuration");
	case SOAP_TYPE_ns2__VideoRateControl:
		return soap_in_ns2__VideoRateControl(soap, NULL, NULL, "ns2:VideoRateControl");
	case SOAP_TYPE_ns2__VideoResolution:
		return soap_in_ns2__VideoResolution(soap, NULL, NULL, "ns2:VideoResolution");
	case SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension:
		return soap_in_ns2__VideoSourceConfigurationOptionsExtension(soap, NULL, NULL, "ns2:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_ns2__VideoSourceConfigurationOptions:
		return soap_in_ns2__VideoSourceConfigurationOptions(soap, NULL, NULL, "ns2:VideoSourceConfigurationOptions");
	case SOAP_TYPE_ns2__ConfigurationEntity:
		return soap_in_ns2__ConfigurationEntity(soap, NULL, NULL, "ns2:ConfigurationEntity");
	case SOAP_TYPE_ns2__ProfileExtension:
		return soap_in_ns2__ProfileExtension(soap, NULL, NULL, "ns2:ProfileExtension");
	case SOAP_TYPE_ns2__MetadataConfiguration:
		return soap_in_ns2__MetadataConfiguration(soap, NULL, NULL, "ns2:MetadataConfiguration");
	case SOAP_TYPE_ns2__PTZConfiguration:
		return soap_in_ns2__PTZConfiguration(soap, NULL, NULL, "ns2:PTZConfiguration");
	case SOAP_TYPE_ns2__VideoAnalyticsConfiguration:
		return soap_in_ns2__VideoAnalyticsConfiguration(soap, NULL, NULL, "ns2:VideoAnalyticsConfiguration");
	case SOAP_TYPE_ns2__AudioEncoderConfiguration:
		return soap_in_ns2__AudioEncoderConfiguration(soap, NULL, NULL, "ns2:AudioEncoderConfiguration");
	case SOAP_TYPE_ns2__AudioSourceConfiguration:
		return soap_in_ns2__AudioSourceConfiguration(soap, NULL, NULL, "ns2:AudioSourceConfiguration");
	case SOAP_TYPE_ns2__VideoSourceConfiguration:
		return soap_in_ns2__VideoSourceConfiguration(soap, NULL, NULL, "ns2:VideoSourceConfiguration");
	case SOAP_TYPE_ns2__VideoSourceExtension:
		return soap_in_ns2__VideoSourceExtension(soap, NULL, NULL, "ns2:VideoSourceExtension");
	case SOAP_TYPE_ns2__IntList:
		return soap_in_ns2__IntList(soap, NULL, NULL, "ns2:IntList");
	case SOAP_TYPE_ns2__DurationRange:
		return soap_in_ns2__DurationRange(soap, NULL, NULL, "ns2:DurationRange");
	case SOAP_TYPE_ns2__FloatRange:
		return soap_in_ns2__FloatRange(soap, NULL, NULL, "ns2:FloatRange");
	case SOAP_TYPE_ns2__IntRange:
		return soap_in_ns2__IntRange(soap, NULL, NULL, "ns2:IntRange");
	case SOAP_TYPE_ns2__IntRectangleRange:
		return soap_in_ns2__IntRectangleRange(soap, NULL, NULL, "ns2:IntRectangleRange");
	case SOAP_TYPE_ns2__IntRectangle:
		return soap_in_ns2__IntRectangle(soap, NULL, NULL, "ns2:IntRectangle");
	case SOAP_TYPE_ns2__DeviceEntity:
		return soap_in_ns2__DeviceEntity(soap, NULL, NULL, "ns2:DeviceEntity");
	case SOAP_TYPE_ns2__UserExtension:
		return soap_in_ns2__UserExtension(soap, NULL, NULL, "ns2:UserExtension");
	case SOAP_TYPE_ns2__User:
		return soap_in_ns2__User(soap, NULL, NULL, "ns2:User");
	case SOAP_TYPE_ns2__VideoEncoderConfiguration:
		return soap_in_ns2__VideoEncoderConfiguration(soap, NULL, NULL, "ns2:VideoEncoderConfiguration");
	case SOAP_TYPE_ns2__VideoEncoderConfigurationOptions:
		return soap_in_ns2__VideoEncoderConfigurationOptions(soap, NULL, NULL, "ns2:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_ns2__MediaUri:
		return soap_in_ns2__MediaUri(soap, NULL, NULL, "ns2:MediaUri");
	case SOAP_TYPE_ns2__StreamSetup:
		return soap_in_ns2__StreamSetup(soap, NULL, NULL, "ns2:StreamSetup");
	case SOAP_TYPE_ns2__Profile:
		return soap_in_ns2__Profile(soap, NULL, NULL, "ns2:Profile");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_in_xenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_in_xenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_in_xenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_in_xenc__EncryptedType(soap, NULL, NULL, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_ns1__GetSnapshotUriResponse:
		return soap_in_PointerTo_ns1__GetSnapshotUriResponse(soap, NULL, NULL, "ns1:GetSnapshotUriResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSnapshotUri:
		return soap_in_PointerTo_ns1__GetSnapshotUri(soap, NULL, NULL, "ns1:GetSnapshotUri");
	case SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfigurationResponse:
		return soap_in_PointerTo_ns1__SetVideoEncoderConfigurationResponse(soap, NULL, NULL, "ns1:SetVideoEncoderConfigurationResponse");
	case SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfiguration:
		return soap_in_PointerTo_ns1__SetVideoEncoderConfiguration(soap, NULL, NULL, "ns1:SetVideoEncoderConfiguration");
	case SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse:
		return soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(soap, NULL, NULL, "ns1:GetVideoEncoderConfigurationOptionsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptions:
		return soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, NULL, NULL, "ns1:GetVideoEncoderConfigurationOptions");
	case SOAP_TYPE_PointerTo_ns1__GetStreamUriResponse:
		return soap_in_PointerTo_ns1__GetStreamUriResponse(soap, NULL, NULL, "ns1:GetStreamUriResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStreamUri:
		return soap_in_PointerTo_ns1__GetStreamUri(soap, NULL, NULL, "ns1:GetStreamUri");
	case SOAP_TYPE_PointerTo_ns1__GetProfilesResponse:
		return soap_in_PointerTo_ns1__GetProfilesResponse(soap, NULL, NULL, "ns1:GetProfilesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProfiles:
		return soap_in_PointerTo_ns1__GetProfiles(soap, NULL, NULL, "ns1:GetProfiles");
	case SOAP_TYPE_PointerTons2__ObjectExtension:
		return soap_in_PointerTons2__ObjectExtension(soap, NULL, NULL, "ns2:ObjectExtension");
	case SOAP_TYPE_PointerTons2__Behaviour:
		return soap_in_PointerTons2__Behaviour(soap, NULL, NULL, "ns2:Behaviour");
	case SOAP_TYPE_PointerTons2__Appearance:
		return soap_in_PointerTons2__Appearance(soap, NULL, NULL, "ns2:Appearance");
	case SOAP_TYPE_PointerTons2__PTZConfigurationExtension:
		return soap_in_PointerTons2__PTZConfigurationExtension(soap, NULL, NULL, "ns2:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTons2__ZoomLimits:
		return soap_in_PointerTons2__ZoomLimits(soap, NULL, NULL, "ns2:ZoomLimits");
	case SOAP_TYPE_PointerTons2__PanTiltLimits:
		return soap_in_PointerTons2__PanTiltLimits(soap, NULL, NULL, "ns2:PanTiltLimits");
	case SOAP_TYPE_PointerTons2__PTZSpeed:
		return soap_in_PointerTons2__PTZSpeed(soap, NULL, NULL, "ns2:PTZSpeed");
	case SOAP_TYPE_PointerTons2__PTZNodeExtension:
		return soap_in_PointerTons2__PTZNodeExtension(soap, NULL, NULL, "ns2:PTZNodeExtension");
	case SOAP_TYPE_PointerTons2__AuxiliaryData:
		return soap_in_PointerTons2__AuxiliaryData(soap, NULL, NULL, "ns2:AuxiliaryData");
	case SOAP_TYPE_PointerTons2__RelayOutputSettings:
		return soap_in_PointerTons2__RelayOutputSettings(soap, NULL, NULL, "ns2:RelayOutputSettings");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceExtension:
		return soap_in_PointerTons2__NetworkInterfaceExtension(soap, NULL, NULL, "ns2:NetworkInterfaceExtension");
	case SOAP_TYPE_PointerTons2__IPv6NetworkInterface:
		return soap_in_PointerTons2__IPv6NetworkInterface(soap, NULL, NULL, "ns2:IPv6NetworkInterface");
	case SOAP_TYPE_PointerTons2__IPv4NetworkInterface:
		return soap_in_PointerTons2__IPv4NetworkInterface(soap, NULL, NULL, "ns2:IPv4NetworkInterface");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceLink:
		return soap_in_PointerTons2__NetworkInterfaceLink(soap, NULL, NULL, "ns2:NetworkInterfaceLink");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceInfo:
		return soap_in_PointerTons2__NetworkInterfaceInfo(soap, NULL, NULL, "ns2:NetworkInterfaceInfo");
	case SOAP_TYPE_PointerTons2__EventSubscription:
		return soap_in_PointerTons2__EventSubscription(soap, NULL, NULL, "ns2:EventSubscription");
	case SOAP_TYPE_PointerTons2__PTZFilter:
		return soap_in_PointerTons2__PTZFilter(soap, NULL, NULL, "ns2:PTZFilter");
	case SOAP_TYPE_PointerTons2__RuleEngineConfiguration:
		return soap_in_PointerTons2__RuleEngineConfiguration(soap, NULL, NULL, "ns2:RuleEngineConfiguration");
	case SOAP_TYPE_PointerTons2__AnalyticsEngineConfiguration:
		return soap_in_PointerTons2__AnalyticsEngineConfiguration(soap, NULL, NULL, "ns2:AnalyticsEngineConfiguration");
	case SOAP_TYPE_PointerTons2__MulticastConfiguration:
		return soap_in_PointerTons2__MulticastConfiguration(soap, NULL, NULL, "ns2:MulticastConfiguration");
	case SOAP_TYPE_PointerTons2__H264Configuration:
		return soap_in_PointerTons2__H264Configuration(soap, NULL, NULL, "ns2:H264Configuration");
	case SOAP_TYPE_PointerTons2__Mpeg4Configuration:
		return soap_in_PointerTons2__Mpeg4Configuration(soap, NULL, NULL, "ns2:Mpeg4Configuration");
	case SOAP_TYPE_PointerTons2__VideoRateControl:
		return soap_in_PointerTons2__VideoRateControl(soap, NULL, NULL, "ns2:VideoRateControl");
	case SOAP_TYPE_PointerTons2__IntRectangle:
		return soap_in_PointerTons2__IntRectangle(soap, NULL, NULL, "ns2:IntRectangle");
	case SOAP_TYPE_PointerTons2__VideoSourceExtension:
		return soap_in_PointerTons2__VideoSourceExtension(soap, NULL, NULL, "ns2:VideoSourceExtension");
	case SOAP_TYPE_PointerTons2__ImagingSettings:
		return soap_in_PointerTons2__ImagingSettings(soap, NULL, NULL, "ns2:ImagingSettings");
	case SOAP_TYPE_PointerTons2__PropertyOperation:
		return soap_in_PointerTons2__PropertyOperation(soap, NULL, NULL, "ns2:PropertyOperation");
	case SOAP_TYPE_PointerTons2__MessageExtension:
		return soap_in_PointerTons2__MessageExtension(soap, NULL, NULL, "ns2:MessageExtension");
	case SOAP_TYPE_PointerTons2__MetadataType:
		return soap_in_PointerTons2__MetadataType(soap, NULL, NULL, "ns2:MetadataType");
	case SOAP_TYPE_PointerTons2__ReferenceParametersType:
		return soap_in_PointerTons2__ReferenceParametersType(soap, NULL, NULL, "ns2:ReferenceParametersType");
	case SOAP_TYPE_PointerTons2__AttributedURIType:
		return soap_in_PointerTons2__AttributedURIType(soap, NULL, NULL, "ns2:AttributedURIType");
	case SOAP_TYPE_PointerTons2__TopicExpressionType:
		return soap_in_PointerTons2__TopicExpressionType(soap, NULL, NULL, "ns2:TopicExpressionType");
	case SOAP_TYPE_PointerTons2__EndpointReferenceType:
		return soap_in_PointerTons2__EndpointReferenceType(soap, NULL, NULL, "ns2:EndpointReferenceType");
	case SOAP_TYPE_PointerTons2__EventStreamExtension:
		return soap_in_PointerTons2__EventStreamExtension(soap, NULL, NULL, "ns2:EventStreamExtension");
	case SOAP_TYPE_PointerTons2__NotificationMessageHolderType:
		return soap_in_PointerTons2__NotificationMessageHolderType(soap, NULL, NULL, "ns2:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTons2__PTZStreamExtension:
		return soap_in_PointerTons2__PTZStreamExtension(soap, NULL, NULL, "ns2:PTZStreamExtension");
	case SOAP_TYPE_PointerTons2__VideoAnalyticsStreamExtension:
		return soap_in_PointerTons2__VideoAnalyticsStreamExtension(soap, NULL, NULL, "ns2:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_PointerTons2__Frame:
		return soap_in_PointerTons2__Frame(soap, NULL, NULL, "ns2:Frame");
	case SOAP_TYPE_PointerTons2__MetadataStreamExtension:
		return soap_in_PointerTons2__MetadataStreamExtension(soap, NULL, NULL, "ns2:MetadataStreamExtension");
	case SOAP_TYPE_PointerTons2__EventStream:
		return soap_in_PointerTons2__EventStream(soap, NULL, NULL, "ns2:EventStream");
	case SOAP_TYPE_PointerTons2__PTZStream:
		return soap_in_PointerTons2__PTZStream(soap, NULL, NULL, "ns2:PTZStream");
	case SOAP_TYPE_PointerTons2__VideoAnalyticsStream:
		return soap_in_PointerTons2__VideoAnalyticsStream(soap, NULL, NULL, "ns2:VideoAnalyticsStream");
	case SOAP_TYPE_PointerTons2__SupportedAnalyticsModulesExtension:
		return soap_in_PointerTons2__SupportedAnalyticsModulesExtension(soap, NULL, NULL, "ns2:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_PointerTons2__SupportedRulesExtension:
		return soap_in_PointerTons2__SupportedRulesExtension(soap, NULL, NULL, "ns2:SupportedRulesExtension");
	case SOAP_TYPE_PointerTons2__ConfigDescription:
		return soap_in_PointerTons2__ConfigDescription(soap, NULL, NULL, "ns2:ConfigDescription");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTons2__ConfigDescriptionExtension:
		return soap_in_PointerTons2__ConfigDescriptionExtension(soap, NULL, NULL, "ns2:ConfigDescriptionExtension");
	case SOAP_TYPE_PointerTo_ns2__ConfigDescription_Messages:
		return soap_in_PointerTo_ns2__ConfigDescription_Messages(soap, NULL, NULL, "ns2:ConfigDescription-Messages");
	case SOAP_TYPE_PointerTons2__ItemList:
		return soap_in_PointerTons2__ItemList(soap, NULL, NULL, "ns2:ItemList");
	case SOAP_TYPE_PointerTons2__RuleEngineConfigurationExtension:
		return soap_in_PointerTons2__RuleEngineConfigurationExtension(soap, NULL, NULL, "ns2:RuleEngineConfigurationExtension");
	case SOAP_TYPE_PointerTons2__AnalyticsEngineConfigurationExtension:
		return soap_in_PointerTons2__AnalyticsEngineConfigurationExtension(soap, NULL, NULL, "ns2:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_PointerTons2__Config:
		return soap_in_PointerTons2__Config(soap, NULL, NULL, "ns2:Config");
	case SOAP_TYPE_PointerTons2__ObjectTreeExtension:
		return soap_in_PointerTons2__ObjectTreeExtension(soap, NULL, NULL, "ns2:ObjectTreeExtension");
	case SOAP_TYPE_PointerTons2__Merge:
		return soap_in_PointerTons2__Merge(soap, NULL, NULL, "ns2:Merge");
	case SOAP_TYPE_PointerTons2__Split:
		return soap_in_PointerTons2__Split(soap, NULL, NULL, "ns2:Split");
	case SOAP_TYPE_PointerTons2__Rename:
		return soap_in_PointerTons2__Rename(soap, NULL, NULL, "ns2:Rename");
	case SOAP_TYPE_PointerTons2__BehaviourExtension:
		return soap_in_PointerTons2__BehaviourExtension(soap, NULL, NULL, "ns2:BehaviourExtension");
	case SOAP_TYPE_PointerTo_ns2__Behaviour_Idle:
		return soap_in_PointerTo_ns2__Behaviour_Idle(soap, NULL, NULL, "ns2:Behaviour-Idle");
	case SOAP_TYPE_PointerTo_ns2__Behaviour_Removed:
		return soap_in_PointerTo_ns2__Behaviour_Removed(soap, NULL, NULL, "ns2:Behaviour-Removed");
	case SOAP_TYPE_PointerTons2__ObjectId:
		return soap_in_PointerTons2__ObjectId(soap, NULL, NULL, "ns2:ObjectId");
	case SOAP_TYPE_PointerTons2__FrameExtension:
		return soap_in_PointerTons2__FrameExtension(soap, NULL, NULL, "ns2:FrameExtension");
	case SOAP_TYPE_PointerTons2__ObjectTree:
		return soap_in_PointerTons2__ObjectTree(soap, NULL, NULL, "ns2:ObjectTree");
	case SOAP_TYPE_PointerTons2__Object:
		return soap_in_PointerTons2__Object(soap, NULL, NULL, "ns2:Object");
	case SOAP_TYPE_PointerTons2__PTZStatus:
		return soap_in_PointerTons2__PTZStatus(soap, NULL, NULL, "ns2:PTZStatus");
	case SOAP_TYPE_PointerTons2__TransformationExtension:
		return soap_in_PointerTons2__TransformationExtension(soap, NULL, NULL, "ns2:TransformationExtension");
	case SOAP_TYPE_PointerTons2__ClassDescriptorExtension:
		return soap_in_PointerTons2__ClassDescriptorExtension(soap, NULL, NULL, "ns2:ClassDescriptorExtension");
	case SOAP_TYPE_PointerTo_ns2__ClassDescriptor_ClassCandidate:
		return soap_in_PointerTo_ns2__ClassDescriptor_ClassCandidate(soap, NULL, NULL, "ns2:ClassDescriptor-ClassCandidate");
	case SOAP_TYPE_PointerTons2__ColorDescriptorExtension:
		return soap_in_PointerTons2__ColorDescriptorExtension(soap, NULL, NULL, "ns2:ColorDescriptorExtension");
	case SOAP_TYPE_PointerTo_ns2__ColorDescriptor_ColorCluster:
		return soap_in_PointerTo_ns2__ColorDescriptor_ColorCluster(soap, NULL, NULL, "ns2:ColorDescriptor-ColorCluster");
	case SOAP_TYPE_PointerTons2__ColorCovariance:
		return soap_in_PointerTons2__ColorCovariance(soap, NULL, NULL, "ns2:ColorCovariance");
	case SOAP_TYPE_PointerTons2__Color:
		return soap_in_PointerTons2__Color(soap, NULL, NULL, "ns2:Color");
	case SOAP_TYPE_PointerTons2__ShapeDescriptorExtension:
		return soap_in_PointerTons2__ShapeDescriptorExtension(soap, NULL, NULL, "ns2:ShapeDescriptorExtension");
	case SOAP_TYPE_PointerTons2__Polygon:
		return soap_in_PointerTons2__Polygon(soap, NULL, NULL, "ns2:Polygon");
	case SOAP_TYPE_PointerTons2__AppearanceExtension:
		return soap_in_PointerTons2__AppearanceExtension(soap, NULL, NULL, "ns2:AppearanceExtension");
	case SOAP_TYPE_PointerTons2__ClassDescriptor:
		return soap_in_PointerTons2__ClassDescriptor(soap, NULL, NULL, "ns2:ClassDescriptor");
	case SOAP_TYPE_PointerTons2__ColorDescriptor:
		return soap_in_PointerTons2__ColorDescriptor(soap, NULL, NULL, "ns2:ColorDescriptor");
	case SOAP_TYPE_PointerTons2__ShapeDescriptor:
		return soap_in_PointerTons2__ShapeDescriptor(soap, NULL, NULL, "ns2:ShapeDescriptor");
	case SOAP_TYPE_PointerTons2__Transformation:
		return soap_in_PointerTons2__Transformation(soap, NULL, NULL, "ns2:Transformation");
	case SOAP_TYPE_PointerTons2__Vector:
		return soap_in_PointerTons2__Vector(soap, NULL, NULL, "ns2:Vector");
	case SOAP_TYPE_PointerTons2__ItemListDescriptionExtension:
		return soap_in_PointerTons2__ItemListDescriptionExtension(soap, NULL, NULL, "ns2:ItemListDescriptionExtension");
	case SOAP_TYPE_PointerTo_ns2__ItemListDescription_ElementItemDescription:
		return soap_in_PointerTo_ns2__ItemListDescription_ElementItemDescription(soap, NULL, NULL, "ns2:ItemListDescription-ElementItemDescription");
	case SOAP_TYPE_PointerTo_ns2__ItemListDescription_SimpleItemDescription:
		return soap_in_PointerTo_ns2__ItemListDescription_SimpleItemDescription(soap, NULL, NULL, "ns2:ItemListDescription-SimpleItemDescription");
	case SOAP_TYPE_PointerTons2__MessageDescriptionExtension:
		return soap_in_PointerTons2__MessageDescriptionExtension(soap, NULL, NULL, "ns2:MessageDescriptionExtension");
	case SOAP_TYPE_PointerTons2__ItemListDescription:
		return soap_in_PointerTons2__ItemListDescription(soap, NULL, NULL, "ns2:ItemListDescription");
	case SOAP_TYPE_PointerTons2__ItemListExtension:
		return soap_in_PointerTons2__ItemListExtension(soap, NULL, NULL, "ns2:ItemListExtension");
	case SOAP_TYPE_PointerTo_ns2__ItemList_ElementItem:
		return soap_in_PointerTo_ns2__ItemList_ElementItem(soap, NULL, NULL, "ns2:ItemList-ElementItem");
	case SOAP_TYPE_PointerTo_ns2__ItemList_SimpleItem:
		return soap_in_PointerTo_ns2__ItemList_SimpleItem(soap, NULL, NULL, "ns2:ItemList-SimpleItem");
	case SOAP_TYPE_PointerTons2__FocusOptions20Extension:
		return soap_in_PointerTons2__FocusOptions20Extension(soap, NULL, NULL, "ns2:FocusOptions20Extension");
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions20Extension:
		return soap_in_PointerTons2__WhiteBalanceOptions20Extension(soap, NULL, NULL, "ns2:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_PointerTons2__FocusConfiguration20Extension:
		return soap_in_PointerTons2__FocusConfiguration20Extension(soap, NULL, NULL, "ns2:FocusConfiguration20Extension");
	case SOAP_TYPE_PointerTons2__WhiteBalance20Extension:
		return soap_in_PointerTons2__WhiteBalance20Extension(soap, NULL, NULL, "ns2:WhiteBalance20Extension");
	case SOAP_TYPE_PointerTons2__RelativeFocusOptions20:
		return soap_in_PointerTons2__RelativeFocusOptions20(soap, NULL, NULL, "ns2:RelativeFocusOptions20");
	case SOAP_TYPE_PointerTons2__BacklightCompensationMode:
		return soap_in_PointerTons2__BacklightCompensationMode(soap, NULL, NULL, "ns2:BacklightCompensationMode");
	case SOAP_TYPE_PointerTons2__ImagingOptions20Extension:
		return soap_in_PointerTons2__ImagingOptions20Extension(soap, NULL, NULL, "ns2:ImagingOptions20Extension");
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions20:
		return soap_in_PointerTons2__WhiteBalanceOptions20(soap, NULL, NULL, "ns2:WhiteBalanceOptions20");
	case SOAP_TYPE_PointerTons2__WideDynamicRangeOptions20:
		return soap_in_PointerTons2__WideDynamicRangeOptions20(soap, NULL, NULL, "ns2:WideDynamicRangeOptions20");
	case SOAP_TYPE_PointerTons2__FocusOptions20:
		return soap_in_PointerTons2__FocusOptions20(soap, NULL, NULL, "ns2:FocusOptions20");
	case SOAP_TYPE_PointerTons2__ExposureOptions20:
		return soap_in_PointerTons2__ExposureOptions20(soap, NULL, NULL, "ns2:ExposureOptions20");
	case SOAP_TYPE_PointerTons2__BacklightCompensationOptions20:
		return soap_in_PointerTons2__BacklightCompensationOptions20(soap, NULL, NULL, "ns2:BacklightCompensationOptions20");
	case SOAP_TYPE_PointerTons2__ImagingSettingsExtension20:
		return soap_in_PointerTons2__ImagingSettingsExtension20(soap, NULL, NULL, "ns2:ImagingSettingsExtension20");
	case SOAP_TYPE_PointerTons2__WhiteBalance20:
		return soap_in_PointerTons2__WhiteBalance20(soap, NULL, NULL, "ns2:WhiteBalance20");
	case SOAP_TYPE_PointerTons2__WideDynamicRange20:
		return soap_in_PointerTons2__WideDynamicRange20(soap, NULL, NULL, "ns2:WideDynamicRange20");
	case SOAP_TYPE_PointerTons2__FocusConfiguration20:
		return soap_in_PointerTons2__FocusConfiguration20(soap, NULL, NULL, "ns2:FocusConfiguration20");
	case SOAP_TYPE_PointerTons2__Exposure20:
		return soap_in_PointerTons2__Exposure20(soap, NULL, NULL, "ns2:Exposure20");
	case SOAP_TYPE_PointerTons2__BacklightCompensation20:
		return soap_in_PointerTons2__BacklightCompensation20(soap, NULL, NULL, "ns2:BacklightCompensation20");
	case SOAP_TYPE_PointerTons2__FocusStatus20Extension:
		return soap_in_PointerTons2__FocusStatus20Extension(soap, NULL, NULL, "ns2:FocusStatus20Extension");
	case SOAP_TYPE_PointerTons2__ImagingStatus20Extension:
		return soap_in_PointerTons2__ImagingStatus20Extension(soap, NULL, NULL, "ns2:ImagingStatus20Extension");
	case SOAP_TYPE_PointerTons2__FocusStatus20:
		return soap_in_PointerTons2__FocusStatus20(soap, NULL, NULL, "ns2:FocusStatus20");
	case SOAP_TYPE_PointerTons2__ContinuousFocusOptions:
		return soap_in_PointerTons2__ContinuousFocusOptions(soap, NULL, NULL, "ns2:ContinuousFocusOptions");
	case SOAP_TYPE_PointerTons2__RelativeFocusOptions:
		return soap_in_PointerTons2__RelativeFocusOptions(soap, NULL, NULL, "ns2:RelativeFocusOptions");
	case SOAP_TYPE_PointerTons2__AbsoluteFocusOptions:
		return soap_in_PointerTons2__AbsoluteFocusOptions(soap, NULL, NULL, "ns2:AbsoluteFocusOptions");
	case SOAP_TYPE_PointerTons2__ContinuousFocus:
		return soap_in_PointerTons2__ContinuousFocus(soap, NULL, NULL, "ns2:ContinuousFocus");
	case SOAP_TYPE_PointerTons2__RelativeFocus:
		return soap_in_PointerTons2__RelativeFocus(soap, NULL, NULL, "ns2:RelativeFocus");
	case SOAP_TYPE_PointerTons2__AbsoluteFocus:
		return soap_in_PointerTons2__AbsoluteFocus(soap, NULL, NULL, "ns2:AbsoluteFocus");
	case SOAP_TYPE_PointerTons2__WhiteBalanceMode:
		return soap_in_PointerTons2__WhiteBalanceMode(soap, NULL, NULL, "ns2:WhiteBalanceMode");
	case SOAP_TYPE_PointerTons2__ExposurePriority:
		return soap_in_PointerTons2__ExposurePriority(soap, NULL, NULL, "ns2:ExposurePriority");
	case SOAP_TYPE_PointerTons2__ExposureMode:
		return soap_in_PointerTons2__ExposureMode(soap, NULL, NULL, "ns2:ExposureMode");
	case SOAP_TYPE_PointerTons2__AutoFocusMode:
		return soap_in_PointerTons2__AutoFocusMode(soap, NULL, NULL, "ns2:AutoFocusMode");
	case SOAP_TYPE_PointerTons2__WideDynamicMode:
		return soap_in_PointerTons2__WideDynamicMode(soap, NULL, NULL, "ns2:WideDynamicMode");
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions:
		return soap_in_PointerTons2__WhiteBalanceOptions(soap, NULL, NULL, "ns2:WhiteBalanceOptions");
	case SOAP_TYPE_PointerTons2__WideDynamicRangeOptions:
		return soap_in_PointerTons2__WideDynamicRangeOptions(soap, NULL, NULL, "ns2:WideDynamicRangeOptions");
	case SOAP_TYPE_PointerTons2__FocusOptions:
		return soap_in_PointerTons2__FocusOptions(soap, NULL, NULL, "ns2:FocusOptions");
	case SOAP_TYPE_PointerTons2__ExposureOptions:
		return soap_in_PointerTons2__ExposureOptions(soap, NULL, NULL, "ns2:ExposureOptions");
	case SOAP_TYPE_PointerTons2__BacklightCompensationOptions:
		return soap_in_PointerTons2__BacklightCompensationOptions(soap, NULL, NULL, "ns2:BacklightCompensationOptions");
	case SOAP_TYPE_PointerTons2__Rectangle:
		return soap_in_PointerTons2__Rectangle(soap, NULL, NULL, "ns2:Rectangle");
	case SOAP_TYPE_PointerTons2__ImagingSettingsExtension:
		return soap_in_PointerTons2__ImagingSettingsExtension(soap, NULL, NULL, "ns2:ImagingSettingsExtension");
	case SOAP_TYPE_PointerTons2__WhiteBalance:
		return soap_in_PointerTons2__WhiteBalance(soap, NULL, NULL, "ns2:WhiteBalance");
	case SOAP_TYPE_PointerTons2__WideDynamicRange:
		return soap_in_PointerTons2__WideDynamicRange(soap, NULL, NULL, "ns2:WideDynamicRange");
	case SOAP_TYPE_PointerTons2__IrCutFilterMode:
		return soap_in_PointerTons2__IrCutFilterMode(soap, NULL, NULL, "ns2:IrCutFilterMode");
	case SOAP_TYPE_PointerTons2__FocusConfiguration:
		return soap_in_PointerTons2__FocusConfiguration(soap, NULL, NULL, "ns2:FocusConfiguration");
	case SOAP_TYPE_PointerTons2__Exposure:
		return soap_in_PointerTons2__Exposure(soap, NULL, NULL, "ns2:Exposure");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerTons2__BacklightCompensation:
		return soap_in_PointerTons2__BacklightCompensation(soap, NULL, NULL, "ns2:BacklightCompensation");
	case SOAP_TYPE_PointerTons2__FocusStatus:
		return soap_in_PointerTons2__FocusStatus(soap, NULL, NULL, "ns2:FocusStatus");
	case SOAP_TYPE_PointerTons2__MoveStatus:
		return soap_in_PointerTons2__MoveStatus(soap, NULL, NULL, "ns2:MoveStatus");
	case SOAP_TYPE_PointerTons2__PTZMoveStatus:
		return soap_in_PointerTons2__PTZMoveStatus(soap, NULL, NULL, "ns2:PTZMoveStatus");
	case SOAP_TYPE_PointerTons2__PTZVector:
		return soap_in_PointerTons2__PTZVector(soap, NULL, NULL, "ns2:PTZVector");
	case SOAP_TYPE_PointerTons2__Vector1D:
		return soap_in_PointerTons2__Vector1D(soap, NULL, NULL, "ns2:Vector1D");
	case SOAP_TYPE_PointerTons2__Vector2D:
		return soap_in_PointerTons2__Vector2D(soap, NULL, NULL, "ns2:Vector2D");
	case SOAP_TYPE_PointerTons2__FloatRange:
		return soap_in_PointerTons2__FloatRange(soap, NULL, NULL, "ns2:FloatRange");
	case SOAP_TYPE_PointerTons2__PTZSpacesExtension:
		return soap_in_PointerTons2__PTZSpacesExtension(soap, NULL, NULL, "ns2:PTZSpacesExtension");
	case SOAP_TYPE_PointerTons2__Space1DDescription:
		return soap_in_PointerTons2__Space1DDescription(soap, NULL, NULL, "ns2:Space1DDescription");
	case SOAP_TYPE_PointerTons2__Space2DDescription:
		return soap_in_PointerTons2__Space2DDescription(soap, NULL, NULL, "ns2:Space2DDescription");
	case SOAP_TYPE_PointerTons2__DurationRange:
		return soap_in_PointerTons2__DurationRange(soap, NULL, NULL, "ns2:DurationRange");
	case SOAP_TYPE_PointerTons2__PTZSpaces:
		return soap_in_PointerTons2__PTZSpaces(soap, NULL, NULL, "ns2:PTZSpaces");
	case SOAP_TYPE_PointerTons2__BinaryData:
		return soap_in_PointerTons2__BinaryData(soap, NULL, NULL, "ns2:BinaryData");
	case SOAP_TYPE_PointerTons2__CertificateGenerationParametersExtension:
		return soap_in_PointerTons2__CertificateGenerationParametersExtension(soap, NULL, NULL, "ns2:CertificateGenerationParametersExtension");
	case SOAP_TYPE_PointerTons2__Date:
		return soap_in_PointerTons2__Date(soap, NULL, NULL, "ns2:Date");
	case SOAP_TYPE_PointerTons2__Time:
		return soap_in_PointerTons2__Time(soap, NULL, NULL, "ns2:Time");
	case SOAP_TYPE_PointerTons2__SystemDateTimeExtension:
		return soap_in_PointerTons2__SystemDateTimeExtension(soap, NULL, NULL, "ns2:SystemDateTimeExtension");
	case SOAP_TYPE_PointerTons2__DateTime:
		return soap_in_PointerTons2__DateTime(soap, NULL, NULL, "ns2:DateTime");
	case SOAP_TYPE_PointerTons2__TimeZone:
		return soap_in_PointerTons2__TimeZone(soap, NULL, NULL, "ns2:TimeZone");
	case SOAP_TYPE_PointerTons2__AttachmentData:
		return soap_in_PointerTons2__AttachmentData(soap, NULL, NULL, "ns2:AttachmentData");
	case SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension:
		return soap_in_PointerTons2__SystemCapabilitiesExtension(soap, NULL, NULL, "ns2:SystemCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__OnvifVersion:
		return soap_in_PointerTons2__OnvifVersion(soap, NULL, NULL, "ns2:OnvifVersion");
	case SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension:
		return soap_in_PointerTons2__SecurityCapabilitiesExtension(soap, NULL, NULL, "ns2:SecurityCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension:
		return soap_in_PointerTons2__NetworkCapabilitiesExtension(soap, NULL, NULL, "ns2:NetworkCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilitiesExtension:
		return soap_in_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, NULL, NULL, "ns2:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__ProfileCapabilities:
		return soap_in_PointerTons2__ProfileCapabilities(soap, NULL, NULL, "ns2:ProfileCapabilities");
	case SOAP_TYPE_PointerTons2__MediaCapabilitiesExtension:
		return soap_in_PointerTons2__MediaCapabilitiesExtension(soap, NULL, NULL, "ns2:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilities:
		return soap_in_PointerTons2__RealTimeStreamingCapabilities(soap, NULL, NULL, "ns2:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTons2__IOCapabilitiesExtension:
		return soap_in_PointerTons2__IOCapabilitiesExtension(soap, NULL, NULL, "ns2:IOCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__DeviceCapabilitiesExtension:
		return soap_in_PointerTons2__DeviceCapabilitiesExtension(soap, NULL, NULL, "ns2:DeviceCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__SecurityCapabilities:
		return soap_in_PointerTons2__SecurityCapabilities(soap, NULL, NULL, "ns2:SecurityCapabilities");
	case SOAP_TYPE_PointerTons2__IOCapabilities:
		return soap_in_PointerTons2__IOCapabilities(soap, NULL, NULL, "ns2:IOCapabilities");
	case SOAP_TYPE_PointerTons2__SystemCapabilities:
		return soap_in_PointerTons2__SystemCapabilities(soap, NULL, NULL, "ns2:SystemCapabilities");
	case SOAP_TYPE_PointerTons2__NetworkCapabilities:
		return soap_in_PointerTons2__NetworkCapabilities(soap, NULL, NULL, "ns2:NetworkCapabilities");
	case SOAP_TYPE_PointerTons2__CapabilitiesExtension:
		return soap_in_PointerTons2__CapabilitiesExtension(soap, NULL, NULL, "ns2:CapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__PTZCapabilities:
		return soap_in_PointerTons2__PTZCapabilities(soap, NULL, NULL, "ns2:PTZCapabilities");
	case SOAP_TYPE_PointerTons2__MediaCapabilities:
		return soap_in_PointerTons2__MediaCapabilities(soap, NULL, NULL, "ns2:MediaCapabilities");
	case SOAP_TYPE_PointerTons2__ImagingCapabilities:
		return soap_in_PointerTons2__ImagingCapabilities(soap, NULL, NULL, "ns2:ImagingCapabilities");
	case SOAP_TYPE_PointerTons2__EventCapabilities:
		return soap_in_PointerTons2__EventCapabilities(soap, NULL, NULL, "ns2:EventCapabilities");
	case SOAP_TYPE_PointerTons2__DeviceCapabilities:
		return soap_in_PointerTons2__DeviceCapabilities(soap, NULL, NULL, "ns2:DeviceCapabilities");
	case SOAP_TYPE_PointerTons2__AnalyticsCapabilities:
		return soap_in_PointerTons2__AnalyticsCapabilities(soap, NULL, NULL, "ns2:AnalyticsCapabilities");
	case SOAP_TYPE_PointerTons2__IPAddressFilterExtension:
		return soap_in_PointerTons2__IPAddressFilterExtension(soap, NULL, NULL, "ns2:IPAddressFilterExtension");
	case SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension:
		return soap_in_PointerTons2__NetworkZeroConfigurationExtension(soap, NULL, NULL, "ns2:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_PointerTons2__IPv6DHCPConfiguration:
		return soap_in_PointerTons2__IPv6DHCPConfiguration(soap, NULL, NULL, "ns2:IPv6DHCPConfiguration");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension:
		return soap_in_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, NULL, NULL, "ns2:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_PointerTons2__IPv6NetworkInterfaceSetConfiguration:
		return soap_in_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, NULL, NULL, "ns2:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTons2__IPv4NetworkInterfaceSetConfiguration:
		return soap_in_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, NULL, NULL, "ns2:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTons2__DynamicDNSInformationExtension:
		return soap_in_PointerTons2__DynamicDNSInformationExtension(soap, NULL, NULL, "ns2:DynamicDNSInformationExtension");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTons2__NTPInformationExtension:
		return soap_in_PointerTons2__NTPInformationExtension(soap, NULL, NULL, "ns2:NTPInformationExtension");
	case SOAP_TYPE_PointerTons2__NetworkHost:
		return soap_in_PointerTons2__NetworkHost(soap, NULL, NULL, "ns2:NetworkHost");
	case SOAP_TYPE_PointerTons2__DNSInformationExtension:
		return soap_in_PointerTons2__DNSInformationExtension(soap, NULL, NULL, "ns2:DNSInformationExtension");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_in_PointerToxsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_PointerTons2__HostnameInformationExtension:
		return soap_in_PointerTons2__HostnameInformationExtension(soap, NULL, NULL, "ns2:HostnameInformationExtension");
	case SOAP_TYPE_PointerTons2__NetworkHostExtension:
		return soap_in_PointerTons2__NetworkHostExtension(soap, NULL, NULL, "ns2:NetworkHostExtension");
	case SOAP_TYPE_PointerTons2__DNSName:
		return soap_in_PointerTons2__DNSName(soap, NULL, NULL, "ns2:DNSName");
	case SOAP_TYPE_PointerTons2__IPv6Address:
		return soap_in_PointerTons2__IPv6Address(soap, NULL, NULL, "ns2:IPv6Address");
	case SOAP_TYPE_PointerTons2__IPv4Address:
		return soap_in_PointerTons2__IPv4Address(soap, NULL, NULL, "ns2:IPv4Address");
	case SOAP_TYPE_PointerTons2__NetworkProtocolExtension:
		return soap_in_PointerTons2__NetworkProtocolExtension(soap, NULL, NULL, "ns2:NetworkProtocolExtension");
	case SOAP_TYPE_PointerTons2__IPv6ConfigurationExtension:
		return soap_in_PointerTons2__IPv6ConfigurationExtension(soap, NULL, NULL, "ns2:IPv6ConfigurationExtension");
	case SOAP_TYPE_PointerTons2__PrefixedIPv6Address:
		return soap_in_PointerTons2__PrefixedIPv6Address(soap, NULL, NULL, "ns2:PrefixedIPv6Address");
	case SOAP_TYPE_PointerTons2__PrefixedIPv4Address:
		return soap_in_PointerTons2__PrefixedIPv4Address(soap, NULL, NULL, "ns2:PrefixedIPv4Address");
	case SOAP_TYPE_PointerTons2__IPv4Configuration:
		return soap_in_PointerTons2__IPv4Configuration(soap, NULL, NULL, "ns2:IPv4Configuration");
	case SOAP_TYPE_PointerTons2__IPv6Configuration:
		return soap_in_PointerTons2__IPv6Configuration(soap, NULL, NULL, "ns2:IPv6Configuration");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceConnectionSetting:
		return soap_in_PointerTons2__NetworkInterfaceConnectionSetting(soap, NULL, NULL, "ns2:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_PointerTons2__Transport:
		return soap_in_PointerTons2__Transport(soap, NULL, NULL, "ns2:Transport");
	case SOAP_TYPE_PointerTons2__IPAddress:
		return soap_in_PointerTons2__IPAddress(soap, NULL, NULL, "ns2:IPAddress");
	case SOAP_TYPE_PointerTons2__PTZStatusFilterOptions:
		return soap_in_PointerTons2__PTZStatusFilterOptions(soap, NULL, NULL, "ns2:PTZStatusFilterOptions");
	case SOAP_TYPE_PointerTo_ns2__EventSubscription_SubscriptionPolicy:
		return soap_in_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, NULL, NULL, "ns2:EventSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTons2__FilterType:
		return soap_in_PointerTons2__FilterType(soap, NULL, NULL, "ns2:FilterType");
	case SOAP_TYPE_PointerTons2__IntList:
		return soap_in_PointerTons2__IntList(soap, NULL, NULL, "ns2:IntList");
	case SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOption:
		return soap_in_PointerTons2__AudioEncoderConfigurationOption(soap, NULL, NULL, "ns2:AudioEncoderConfigurationOption");
	case SOAP_TYPE_PointerTons2__AudioSourceOptionsExtension:
		return soap_in_PointerTons2__AudioSourceOptionsExtension(soap, NULL, NULL, "ns2:AudioSourceOptionsExtension");
	case SOAP_TYPE_PointerTons2__H264Profile:
		return soap_in_PointerTons2__H264Profile(soap, NULL, NULL, "ns2:H264Profile");
	case SOAP_TYPE_PointerTons2__Mpeg4Profile:
		return soap_in_PointerTons2__Mpeg4Profile(soap, NULL, NULL, "ns2:Mpeg4Profile");
	case SOAP_TYPE_PointerTons2__VideoResolution:
		return soap_in_PointerTons2__VideoResolution(soap, NULL, NULL, "ns2:VideoResolution");
	case SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension:
		return soap_in_PointerTons2__VideoEncoderOptionsExtension(soap, NULL, NULL, "ns2:VideoEncoderOptionsExtension");
	case SOAP_TYPE_PointerTons2__H264Options:
		return soap_in_PointerTons2__H264Options(soap, NULL, NULL, "ns2:H264Options");
	case SOAP_TYPE_PointerTons2__Mpeg4Options:
		return soap_in_PointerTons2__Mpeg4Options(soap, NULL, NULL, "ns2:Mpeg4Options");
	case SOAP_TYPE_PointerTons2__JpegOptions:
		return soap_in_PointerTons2__JpegOptions(soap, NULL, NULL, "ns2:JpegOptions");
	case SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension:
		return soap_in_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, NULL, NULL, "ns2:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_PointerTons2__ReferenceToken:
		return soap_in_PointerTons2__ReferenceToken(soap, NULL, NULL, "ns2:ReferenceToken");
	case SOAP_TYPE_PointerTons2__IntRectangleRange:
		return soap_in_PointerTons2__IntRectangleRange(soap, NULL, NULL, "ns2:IntRectangleRange");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__ProfileExtension:
		return soap_in_PointerTons2__ProfileExtension(soap, NULL, NULL, "ns2:ProfileExtension");
	case SOAP_TYPE_PointerTons2__MetadataConfiguration:
		return soap_in_PointerTons2__MetadataConfiguration(soap, NULL, NULL, "ns2:MetadataConfiguration");
	case SOAP_TYPE_PointerTons2__PTZConfiguration:
		return soap_in_PointerTons2__PTZConfiguration(soap, NULL, NULL, "ns2:PTZConfiguration");
	case SOAP_TYPE_PointerTons2__VideoAnalyticsConfiguration:
		return soap_in_PointerTons2__VideoAnalyticsConfiguration(soap, NULL, NULL, "ns2:VideoAnalyticsConfiguration");
	case SOAP_TYPE_PointerTons2__AudioEncoderConfiguration:
		return soap_in_PointerTons2__AudioEncoderConfiguration(soap, NULL, NULL, "ns2:AudioEncoderConfiguration");
	case SOAP_TYPE_PointerTons2__AudioSourceConfiguration:
		return soap_in_PointerTons2__AudioSourceConfiguration(soap, NULL, NULL, "ns2:AudioSourceConfiguration");
	case SOAP_TYPE_PointerTons2__VideoSourceConfiguration:
		return soap_in_PointerTons2__VideoSourceConfiguration(soap, NULL, NULL, "ns2:VideoSourceConfiguration");
	case SOAP_TYPE_PointerTons2__IntRange:
		return soap_in_PointerTons2__IntRange(soap, NULL, NULL, "ns2:IntRange");
	case SOAP_TYPE_PointerTons2__UserExtension:
		return soap_in_PointerTons2__UserExtension(soap, NULL, NULL, "ns2:UserExtension");
	case SOAP_TYPE_PointerTons2__VideoEncoderConfiguration:
		return soap_in_PointerTons2__VideoEncoderConfiguration(soap, NULL, NULL, "ns2:VideoEncoderConfiguration");
	case SOAP_TYPE_PointerTons2__VideoEncoderConfigurationOptions:
		return soap_in_PointerTons2__VideoEncoderConfigurationOptions(soap, NULL, NULL, "ns2:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_PointerTons2__MediaUri:
		return soap_in_PointerTons2__MediaUri(soap, NULL, NULL, "ns2:MediaUri");
	case SOAP_TYPE_PointerTons2__StreamSetup:
		return soap_in_PointerTons2__StreamSetup(soap, NULL, NULL, "ns2:StreamSetup");
	case SOAP_TYPE_PointerTons2__Profile:
		return soap_in_PointerTons2__Profile(soap, NULL, NULL, "ns2:Profile");
	case SOAP_TYPE_ns2__TopicNamespaceLocation:
	{	char **s;
		s = soap_in_ns2__TopicNamespaceLocation(soap, NULL, NULL, "ns2:TopicNamespaceLocation");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__AuxiliaryData:
	{	char **s;
		s = soap_in_ns2__AuxiliaryData(soap, NULL, NULL, "ns2:AuxiliaryData");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__Domain:
	{	char **s;
		s = soap_in_ns2__Domain(soap, NULL, NULL, "ns2:Domain");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__DNSName:
	{	char **s;
		s = soap_in_ns2__DNSName(soap, NULL, NULL, "ns2:DNSName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__HwAddress:
	{	char **s;
		s = soap_in_ns2__HwAddress(soap, NULL, NULL, "ns2:HwAddress");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__IPv6Address:
	{	char **s;
		s = soap_in_ns2__IPv6Address(soap, NULL, NULL, "ns2:IPv6Address");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__IPv4Address:
	{	char **s;
		s = soap_in_ns2__IPv4Address(soap, NULL, NULL, "ns2:IPv4Address");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__Name:
	{	char **s;
		s = soap_in_ns2__Name(soap, NULL, NULL, "ns2:Name");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__ReferenceToken:
	{	char **s;
		s = soap_in_ns2__ReferenceToken(soap, NULL, NULL, "ns2:ReferenceToken");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{	char **s;
		s = soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{	char **s;
		s = soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anySimpleType:
	{	char **s;
		s = soap_in_xsd__anySimpleType(soap, NULL, NULL, "xsd:anySimpleType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_in_PointerToxenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_in_PointerTo_xenc__ReferenceList(soap, NULL, NULL, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_in_PointerToxenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_in_PointerToxenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_in_PointerToxenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_in_PointerToxenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_in_PointerToxenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_in_PointerToxenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_in_PointerTo_ds__KeyInfo(soap, NULL, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_in_PointerToxenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IANA-IfTypes"))
		{	*type = SOAP_TYPE_ns2__IANA_IfTypes;
			return soap_in_ns2__IANA_IfTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClassType"))
		{	*type = SOAP_TYPE_ns2__ClassType;
			return soap_in_ns2__ClassType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Direction"))
		{	*type = SOAP_TYPE_ns2__Direction;
			return soap_in_ns2__Direction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PropertyOperation"))
		{	*type = SOAP_TYPE_ns2__PropertyOperation;
			return soap_in_ns2__PropertyOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IrCutFilterMode"))
		{	*type = SOAP_TYPE_ns2__IrCutFilterMode;
			return soap_in_ns2__IrCutFilterMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalanceMode"))
		{	*type = SOAP_TYPE_ns2__WhiteBalanceMode;
			return soap_in_ns2__WhiteBalanceMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Enabled"))
		{	*type = SOAP_TYPE_ns2__Enabled;
			return soap_in_ns2__Enabled(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExposureMode"))
		{	*type = SOAP_TYPE_ns2__ExposureMode;
			return soap_in_ns2__ExposureMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExposurePriority"))
		{	*type = SOAP_TYPE_ns2__ExposurePriority;
			return soap_in_ns2__ExposurePriority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BacklightCompensationMode"))
		{	*type = SOAP_TYPE_ns2__BacklightCompensationMode;
			return soap_in_ns2__BacklightCompensationMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WideDynamicMode"))
		{	*type = SOAP_TYPE_ns2__WideDynamicMode;
			return soap_in_ns2__WideDynamicMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AutoFocusMode"))
		{	*type = SOAP_TYPE_ns2__AutoFocusMode;
			return soap_in_ns2__AutoFocusMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MoveStatus"))
		{	*type = SOAP_TYPE_ns2__MoveStatus;
			return soap_in_ns2__MoveStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelayMode"))
		{	*type = SOAP_TYPE_ns2__RelayMode;
			return soap_in_ns2__RelayMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelayIdleState"))
		{	*type = SOAP_TYPE_ns2__RelayIdleState;
			return soap_in_ns2__RelayIdleState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelayLogicalState"))
		{	*type = SOAP_TYPE_ns2__RelayLogicalState;
			return soap_in_ns2__RelayLogicalState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SetDateTimeType"))
		{	*type = SOAP_TYPE_ns2__SetDateTimeType;
			return soap_in_ns2__SetDateTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FactoryDefaultType"))
		{	*type = SOAP_TYPE_ns2__FactoryDefaultType;
			return soap_in_ns2__FactoryDefaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SystemLogType"))
		{	*type = SOAP_TYPE_ns2__SystemLogType;
			return soap_in_ns2__SystemLogType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CapabilityCategory"))
		{	*type = SOAP_TYPE_ns2__CapabilityCategory;
			return soap_in_ns2__CapabilityCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DynamicDNSType"))
		{	*type = SOAP_TYPE_ns2__DynamicDNSType;
			return soap_in_ns2__DynamicDNSType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPAddressFilterType"))
		{	*type = SOAP_TYPE_ns2__IPAddressFilterType;
			return soap_in_ns2__IPAddressFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPType"))
		{	*type = SOAP_TYPE_ns2__IPType;
			return soap_in_ns2__IPType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkHostType"))
		{	*type = SOAP_TYPE_ns2__NetworkHostType;
			return soap_in_ns2__NetworkHostType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkProtocolType"))
		{	*type = SOAP_TYPE_ns2__NetworkProtocolType;
			return soap_in_ns2__NetworkProtocolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv6DHCPConfiguration"))
		{	*type = SOAP_TYPE_ns2__IPv6DHCPConfiguration;
			return soap_in_ns2__IPv6DHCPConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Duplex"))
		{	*type = SOAP_TYPE_ns2__Duplex;
			return soap_in_ns2__Duplex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DiscoveryMode"))
		{	*type = SOAP_TYPE_ns2__DiscoveryMode;
			return soap_in_ns2__DiscoveryMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ScopeDefinition"))
		{	*type = SOAP_TYPE_ns2__ScopeDefinition;
			return soap_in_ns2__ScopeDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TransportProtocol"))
		{	*type = SOAP_TYPE_ns2__TransportProtocol;
			return soap_in_ns2__TransportProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StreamType"))
		{	*type = SOAP_TYPE_ns2__StreamType;
			return soap_in_ns2__StreamType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioEncoding"))
		{	*type = SOAP_TYPE_ns2__AudioEncoding;
			return soap_in_ns2__AudioEncoding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:H264Profile"))
		{	*type = SOAP_TYPE_ns2__H264Profile;
			return soap_in_ns2__H264Profile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Mpeg4Profile"))
		{	*type = SOAP_TYPE_ns2__Mpeg4Profile;
			return soap_in_ns2__Mpeg4Profile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoEncoding"))
		{	*type = SOAP_TYPE_ns2__VideoEncoding;
			return soap_in_ns2__VideoEncoding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UserLevel"))
		{	*type = SOAP_TYPE_ns2__UserLevel;
			return soap_in_ns2__UserLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZNode"))
		{	*type = SOAP_TYPE_ns2__PTZNode;
			return soap_in_ns2__PTZNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelayOutput"))
		{	*type = SOAP_TYPE_ns2__RelayOutput;
			return soap_in_ns2__RelayOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterface"))
		{	*type = SOAP_TYPE_ns2__NetworkInterface;
			return soap_in_ns2__NetworkInterface(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioSource"))
		{	*type = SOAP_TYPE_ns2__AudioSource;
			return soap_in_ns2__AudioSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoSource"))
		{	*type = SOAP_TYPE_ns2__VideoSource;
			return soap_in_ns2__VideoSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MetadataType"))
		{	*type = SOAP_TYPE_ns2__MetadataType;
			return soap_in_ns2__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReferenceParametersType"))
		{	*type = SOAP_TYPE_ns2__ReferenceParametersType;
			return soap_in_ns2__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttributedURIType"))
		{	*type = SOAP_TYPE_ns2__AttributedURIType;
			return soap_in_ns2__AttributedURIType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TopicExpressionType"))
		{	*type = SOAP_TYPE_ns2__TopicExpressionType;
			return soap_in_ns2__TopicExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EndpointReferenceType"))
		{	*type = SOAP_TYPE_ns2__EndpointReferenceType;
			return soap_in_ns2__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventStreamExtension"))
		{	*type = SOAP_TYPE_ns2__EventStreamExtension;
			return soap_in_ns2__EventStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_ns2__NotificationMessageHolderType;
			return soap_in_ns2__NotificationMessageHolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZStreamExtension"))
		{	*type = SOAP_TYPE_ns2__PTZStreamExtension;
			return soap_in_ns2__PTZStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoAnalyticsStreamExtension"))
		{	*type = SOAP_TYPE_ns2__VideoAnalyticsStreamExtension;
			return soap_in_ns2__VideoAnalyticsStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MetadataStreamExtension"))
		{	*type = SOAP_TYPE_ns2__MetadataStreamExtension;
			return soap_in_ns2__MetadataStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventStream"))
		{	*type = SOAP_TYPE_ns2__EventStream;
			return soap_in_ns2__EventStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZStream"))
		{	*type = SOAP_TYPE_ns2__PTZStream;
			return soap_in_ns2__PTZStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoAnalyticsStream"))
		{	*type = SOAP_TYPE_ns2__VideoAnalyticsStream;
			return soap_in_ns2__VideoAnalyticsStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MetadataStream"))
		{	*type = SOAP_TYPE_ns2__MetadataStream;
			return soap_in_ns2__MetadataStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SupportedAnalyticsModulesExtension"))
		{	*type = SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension;
			return soap_in_ns2__SupportedAnalyticsModulesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SupportedAnalyticsModules"))
		{	*type = SOAP_TYPE_ns2__SupportedAnalyticsModules;
			return soap_in_ns2__SupportedAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SupportedRulesExtension"))
		{	*type = SOAP_TYPE_ns2__SupportedRulesExtension;
			return soap_in_ns2__SupportedRulesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SupportedRules"))
		{	*type = SOAP_TYPE_ns2__SupportedRules;
			return soap_in_ns2__SupportedRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConfigDescriptionExtension"))
		{	*type = SOAP_TYPE_ns2__ConfigDescriptionExtension;
			return soap_in_ns2__ConfigDescriptionExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConfigDescription"))
		{	*type = SOAP_TYPE_ns2__ConfigDescription;
			return soap_in_ns2__ConfigDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RuleEngineConfigurationExtension"))
		{	*type = SOAP_TYPE_ns2__RuleEngineConfigurationExtension;
			return soap_in_ns2__RuleEngineConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RuleEngineConfiguration"))
		{	*type = SOAP_TYPE_ns2__RuleEngineConfiguration;
			return soap_in_ns2__RuleEngineConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnalyticsEngineConfigurationExtension"))
		{	*type = SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension;
			return soap_in_ns2__AnalyticsEngineConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Config"))
		{	*type = SOAP_TYPE_ns2__Config;
			return soap_in_ns2__Config(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnalyticsEngineConfiguration"))
		{	*type = SOAP_TYPE_ns2__AnalyticsEngineConfiguration;
			return soap_in_ns2__AnalyticsEngineConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObjectTreeExtension"))
		{	*type = SOAP_TYPE_ns2__ObjectTreeExtension;
			return soap_in_ns2__ObjectTreeExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BehaviourExtension"))
		{	*type = SOAP_TYPE_ns2__BehaviourExtension;
			return soap_in_ns2__BehaviourExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Behaviour"))
		{	*type = SOAP_TYPE_ns2__Behaviour;
			return soap_in_ns2__Behaviour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Rename"))
		{	*type = SOAP_TYPE_ns2__Rename;
			return soap_in_ns2__Rename(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Split"))
		{	*type = SOAP_TYPE_ns2__Split;
			return soap_in_ns2__Split(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObjectId"))
		{	*type = SOAP_TYPE_ns2__ObjectId;
			return soap_in_ns2__ObjectId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Merge"))
		{	*type = SOAP_TYPE_ns2__Merge;
			return soap_in_ns2__Merge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FrameExtension"))
		{	*type = SOAP_TYPE_ns2__FrameExtension;
			return soap_in_ns2__FrameExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObjectTree"))
		{	*type = SOAP_TYPE_ns2__ObjectTree;
			return soap_in_ns2__ObjectTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Object"))
		{	*type = SOAP_TYPE_ns2__Object;
			return soap_in_ns2__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Frame"))
		{	*type = SOAP_TYPE_ns2__Frame;
			return soap_in_ns2__Frame(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TransformationExtension"))
		{	*type = SOAP_TYPE_ns2__TransformationExtension;
			return soap_in_ns2__TransformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObjectExtension"))
		{	*type = SOAP_TYPE_ns2__ObjectExtension;
			return soap_in_ns2__ObjectExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClassDescriptorExtension"))
		{	*type = SOAP_TYPE_ns2__ClassDescriptorExtension;
			return soap_in_ns2__ClassDescriptorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ColorDescriptorExtension"))
		{	*type = SOAP_TYPE_ns2__ColorDescriptorExtension;
			return soap_in_ns2__ColorDescriptorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShapeDescriptorExtension"))
		{	*type = SOAP_TYPE_ns2__ShapeDescriptorExtension;
			return soap_in_ns2__ShapeDescriptorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AppearanceExtension"))
		{	*type = SOAP_TYPE_ns2__AppearanceExtension;
			return soap_in_ns2__AppearanceExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClassDescriptor"))
		{	*type = SOAP_TYPE_ns2__ClassDescriptor;
			return soap_in_ns2__ClassDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ColorDescriptor"))
		{	*type = SOAP_TYPE_ns2__ColorDescriptor;
			return soap_in_ns2__ColorDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShapeDescriptor"))
		{	*type = SOAP_TYPE_ns2__ShapeDescriptor;
			return soap_in_ns2__ShapeDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Transformation"))
		{	*type = SOAP_TYPE_ns2__Transformation;
			return soap_in_ns2__Transformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Appearance"))
		{	*type = SOAP_TYPE_ns2__Appearance;
			return soap_in_ns2__Appearance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ColorCovariance"))
		{	*type = SOAP_TYPE_ns2__ColorCovariance;
			return soap_in_ns2__ColorCovariance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Color"))
		{	*type = SOAP_TYPE_ns2__Color;
			return soap_in_ns2__Color(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Polyline"))
		{	*type = SOAP_TYPE_ns2__Polyline;
			return soap_in_ns2__Polyline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Polygon"))
		{	*type = SOAP_TYPE_ns2__Polygon;
			return soap_in_ns2__Polygon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Vector"))
		{	*type = SOAP_TYPE_ns2__Vector;
			return soap_in_ns2__Vector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemListDescriptionExtension"))
		{	*type = SOAP_TYPE_ns2__ItemListDescriptionExtension;
			return soap_in_ns2__ItemListDescriptionExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MessageDescriptionExtension"))
		{	*type = SOAP_TYPE_ns2__MessageDescriptionExtension;
			return soap_in_ns2__MessageDescriptionExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemListDescription"))
		{	*type = SOAP_TYPE_ns2__ItemListDescription;
			return soap_in_ns2__ItemListDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MessageDescription"))
		{	*type = SOAP_TYPE_ns2__MessageDescription;
			return soap_in_ns2__MessageDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemListExtension"))
		{	*type = SOAP_TYPE_ns2__ItemListExtension;
			return soap_in_ns2__ItemListExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemList"))
		{	*type = SOAP_TYPE_ns2__ItemList;
			return soap_in_ns2__ItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MessageExtension"))
		{	*type = SOAP_TYPE_ns2__MessageExtension;
			return soap_in_ns2__MessageExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusOptions20Extension"))
		{	*type = SOAP_TYPE_ns2__FocusOptions20Extension;
			return soap_in_ns2__FocusOptions20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalanceOptions20Extension"))
		{	*type = SOAP_TYPE_ns2__WhiteBalanceOptions20Extension;
			return soap_in_ns2__WhiteBalanceOptions20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusConfiguration20Extension"))
		{	*type = SOAP_TYPE_ns2__FocusConfiguration20Extension;
			return soap_in_ns2__FocusConfiguration20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalance20Extension"))
		{	*type = SOAP_TYPE_ns2__WhiteBalance20Extension;
			return soap_in_ns2__WhiteBalance20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelativeFocusOptions20"))
		{	*type = SOAP_TYPE_ns2__RelativeFocusOptions20;
			return soap_in_ns2__RelativeFocusOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MoveOptions20"))
		{	*type = SOAP_TYPE_ns2__MoveOptions20;
			return soap_in_ns2__MoveOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingOptions20Extension"))
		{	*type = SOAP_TYPE_ns2__ImagingOptions20Extension;
			return soap_in_ns2__ImagingOptions20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalanceOptions20"))
		{	*type = SOAP_TYPE_ns2__WhiteBalanceOptions20;
			return soap_in_ns2__WhiteBalanceOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WideDynamicRangeOptions20"))
		{	*type = SOAP_TYPE_ns2__WideDynamicRangeOptions20;
			return soap_in_ns2__WideDynamicRangeOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusOptions20"))
		{	*type = SOAP_TYPE_ns2__FocusOptions20;
			return soap_in_ns2__FocusOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExposureOptions20"))
		{	*type = SOAP_TYPE_ns2__ExposureOptions20;
			return soap_in_ns2__ExposureOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BacklightCompensationOptions20"))
		{	*type = SOAP_TYPE_ns2__BacklightCompensationOptions20;
			return soap_in_ns2__BacklightCompensationOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingOptions20"))
		{	*type = SOAP_TYPE_ns2__ImagingOptions20;
			return soap_in_ns2__ImagingOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingSettingsExtension20"))
		{	*type = SOAP_TYPE_ns2__ImagingSettingsExtension20;
			return soap_in_ns2__ImagingSettingsExtension20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalance20"))
		{	*type = SOAP_TYPE_ns2__WhiteBalance20;
			return soap_in_ns2__WhiteBalance20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WideDynamicRange20"))
		{	*type = SOAP_TYPE_ns2__WideDynamicRange20;
			return soap_in_ns2__WideDynamicRange20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusConfiguration20"))
		{	*type = SOAP_TYPE_ns2__FocusConfiguration20;
			return soap_in_ns2__FocusConfiguration20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Exposure20"))
		{	*type = SOAP_TYPE_ns2__Exposure20;
			return soap_in_ns2__Exposure20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BacklightCompensation20"))
		{	*type = SOAP_TYPE_ns2__BacklightCompensation20;
			return soap_in_ns2__BacklightCompensation20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingSettings20"))
		{	*type = SOAP_TYPE_ns2__ImagingSettings20;
			return soap_in_ns2__ImagingSettings20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusStatus20Extension"))
		{	*type = SOAP_TYPE_ns2__FocusStatus20Extension;
			return soap_in_ns2__FocusStatus20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingStatus20Extension"))
		{	*type = SOAP_TYPE_ns2__ImagingStatus20Extension;
			return soap_in_ns2__ImagingStatus20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusStatus20"))
		{	*type = SOAP_TYPE_ns2__FocusStatus20;
			return soap_in_ns2__FocusStatus20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingStatus20"))
		{	*type = SOAP_TYPE_ns2__ImagingStatus20;
			return soap_in_ns2__ImagingStatus20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContinuousFocusOptions"))
		{	*type = SOAP_TYPE_ns2__ContinuousFocusOptions;
			return soap_in_ns2__ContinuousFocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelativeFocusOptions"))
		{	*type = SOAP_TYPE_ns2__RelativeFocusOptions;
			return soap_in_ns2__RelativeFocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbsoluteFocusOptions"))
		{	*type = SOAP_TYPE_ns2__AbsoluteFocusOptions;
			return soap_in_ns2__AbsoluteFocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MoveOptions"))
		{	*type = SOAP_TYPE_ns2__MoveOptions;
			return soap_in_ns2__MoveOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContinuousFocus"))
		{	*type = SOAP_TYPE_ns2__ContinuousFocus;
			return soap_in_ns2__ContinuousFocus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelativeFocus"))
		{	*type = SOAP_TYPE_ns2__RelativeFocus;
			return soap_in_ns2__RelativeFocus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbsoluteFocus"))
		{	*type = SOAP_TYPE_ns2__AbsoluteFocus;
			return soap_in_ns2__AbsoluteFocus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusMove"))
		{	*type = SOAP_TYPE_ns2__FocusMove;
			return soap_in_ns2__FocusMove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalanceOptions"))
		{	*type = SOAP_TYPE_ns2__WhiteBalanceOptions;
			return soap_in_ns2__WhiteBalanceOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WideDynamicRangeOptions"))
		{	*type = SOAP_TYPE_ns2__WideDynamicRangeOptions;
			return soap_in_ns2__WideDynamicRangeOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusOptions"))
		{	*type = SOAP_TYPE_ns2__FocusOptions;
			return soap_in_ns2__FocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExposureOptions"))
		{	*type = SOAP_TYPE_ns2__ExposureOptions;
			return soap_in_ns2__ExposureOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BacklightCompensationOptions"))
		{	*type = SOAP_TYPE_ns2__BacklightCompensationOptions;
			return soap_in_ns2__BacklightCompensationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingOptions"))
		{	*type = SOAP_TYPE_ns2__ImagingOptions;
			return soap_in_ns2__ImagingOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Rectangle"))
		{	*type = SOAP_TYPE_ns2__Rectangle;
			return soap_in_ns2__Rectangle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingSettingsExtension"))
		{	*type = SOAP_TYPE_ns2__ImagingSettingsExtension;
			return soap_in_ns2__ImagingSettingsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WhiteBalance"))
		{	*type = SOAP_TYPE_ns2__WhiteBalance;
			return soap_in_ns2__WhiteBalance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WideDynamicRange"))
		{	*type = SOAP_TYPE_ns2__WideDynamicRange;
			return soap_in_ns2__WideDynamicRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Exposure"))
		{	*type = SOAP_TYPE_ns2__Exposure;
			return soap_in_ns2__Exposure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BacklightCompensation"))
		{	*type = SOAP_TYPE_ns2__BacklightCompensation;
			return soap_in_ns2__BacklightCompensation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingSettings"))
		{	*type = SOAP_TYPE_ns2__ImagingSettings;
			return soap_in_ns2__ImagingSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusConfiguration"))
		{	*type = SOAP_TYPE_ns2__FocusConfiguration;
			return soap_in_ns2__FocusConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FocusStatus"))
		{	*type = SOAP_TYPE_ns2__FocusStatus;
			return soap_in_ns2__FocusStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingStatus"))
		{	*type = SOAP_TYPE_ns2__ImagingStatus;
			return soap_in_ns2__ImagingStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZPreset"))
		{	*type = SOAP_TYPE_ns2__PTZPreset;
			return soap_in_ns2__PTZPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZMoveStatus"))
		{	*type = SOAP_TYPE_ns2__PTZMoveStatus;
			return soap_in_ns2__PTZMoveStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZStatus"))
		{	*type = SOAP_TYPE_ns2__PTZStatus;
			return soap_in_ns2__PTZStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZSpeed"))
		{	*type = SOAP_TYPE_ns2__PTZSpeed;
			return soap_in_ns2__PTZSpeed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZVector"))
		{	*type = SOAP_TYPE_ns2__PTZVector;
			return soap_in_ns2__PTZVector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Vector1D"))
		{	*type = SOAP_TYPE_ns2__Vector1D;
			return soap_in_ns2__Vector1D(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Vector2D"))
		{	*type = SOAP_TYPE_ns2__Vector2D;
			return soap_in_ns2__Vector2D(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZSpacesExtension"))
		{	*type = SOAP_TYPE_ns2__PTZSpacesExtension;
			return soap_in_ns2__PTZSpacesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Space1DDescription"))
		{	*type = SOAP_TYPE_ns2__Space1DDescription;
			return soap_in_ns2__Space1DDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ZoomLimits"))
		{	*type = SOAP_TYPE_ns2__ZoomLimits;
			return soap_in_ns2__ZoomLimits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Space2DDescription"))
		{	*type = SOAP_TYPE_ns2__Space2DDescription;
			return soap_in_ns2__Space2DDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PanTiltLimits"))
		{	*type = SOAP_TYPE_ns2__PanTiltLimits;
			return soap_in_ns2__PanTiltLimits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZSpaces"))
		{	*type = SOAP_TYPE_ns2__PTZSpaces;
			return soap_in_ns2__PTZSpaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZConfigurationOptions"))
		{	*type = SOAP_TYPE_ns2__PTZConfigurationOptions;
			return soap_in_ns2__PTZConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZConfigurationExtension"))
		{	*type = SOAP_TYPE_ns2__PTZConfigurationExtension;
			return soap_in_ns2__PTZConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZNodeExtension"))
		{	*type = SOAP_TYPE_ns2__PTZNodeExtension;
			return soap_in_ns2__PTZNodeExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RelayOutputSettings"))
		{	*type = SOAP_TYPE_ns2__RelayOutputSettings;
			return soap_in_ns2__RelayOutputSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CertificateStatus"))
		{	*type = SOAP_TYPE_ns2__CertificateStatus;
			return soap_in_ns2__CertificateStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Certificate"))
		{	*type = SOAP_TYPE_ns2__Certificate;
			return soap_in_ns2__Certificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CertificateGenerationParametersExtension"))
		{	*type = SOAP_TYPE_ns2__CertificateGenerationParametersExtension;
			return soap_in_ns2__CertificateGenerationParametersExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CertificateGenerationParameters"))
		{	*type = SOAP_TYPE_ns2__CertificateGenerationParameters;
			return soap_in_ns2__CertificateGenerationParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Date"))
		{	*type = SOAP_TYPE_ns2__Date;
			return soap_in_ns2__Date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Time"))
		{	*type = SOAP_TYPE_ns2__Time;
			return soap_in_ns2__Time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SystemDateTimeExtension"))
		{	*type = SOAP_TYPE_ns2__SystemDateTimeExtension;
			return soap_in_ns2__SystemDateTimeExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DateTime"))
		{	*type = SOAP_TYPE_ns2__DateTime;
			return soap_in_ns2__DateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TimeZone"))
		{	*type = SOAP_TYPE_ns2__TimeZone;
			return soap_in_ns2__TimeZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SystemDateTime"))
		{	*type = SOAP_TYPE_ns2__SystemDateTime;
			return soap_in_ns2__SystemDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BackupFile"))
		{	*type = SOAP_TYPE_ns2__BackupFile;
			return soap_in_ns2__BackupFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BinaryData"))
		{	*type = SOAP_TYPE_ns2__BinaryData;
			return soap_in_ns2__BinaryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SupportInformation"))
		{	*type = SOAP_TYPE_ns2__SupportInformation;
			return soap_in_ns2__SupportInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AttachmentData"))
		{	*type = SOAP_TYPE_ns2__AttachmentData;
			return soap_in_ns2__AttachmentData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SystemLog"))
		{	*type = SOAP_TYPE_ns2__SystemLog;
			return soap_in_ns2__SystemLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SystemCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__SystemCapabilitiesExtension;
			return soap_in_ns2__SystemCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OnvifVersion"))
		{	*type = SOAP_TYPE_ns2__OnvifVersion;
			return soap_in_ns2__OnvifVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StorageCapabilities"))
		{	*type = SOAP_TYPE_ns2__StorageCapabilities;
			return soap_in_ns2__StorageCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SecurityCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__SecurityCapabilitiesExtension;
			return soap_in_ns2__SecurityCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__NetworkCapabilitiesExtension;
			return soap_in_ns2__NetworkCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RealTimeStreamingCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension;
			return soap_in_ns2__RealTimeStreamingCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ProfileCapabilities"))
		{	*type = SOAP_TYPE_ns2__ProfileCapabilities;
			return soap_in_ns2__ProfileCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MediaCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__MediaCapabilitiesExtension;
			return soap_in_ns2__MediaCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RealTimeStreamingCapabilities"))
		{	*type = SOAP_TYPE_ns2__RealTimeStreamingCapabilities;
			return soap_in_ns2__RealTimeStreamingCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IOCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__IOCapabilitiesExtension;
			return soap_in_ns2__IOCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeviceCapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__DeviceCapabilitiesExtension;
			return soap_in_ns2__DeviceCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SecurityCapabilities"))
		{	*type = SOAP_TYPE_ns2__SecurityCapabilities;
			return soap_in_ns2__SecurityCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IOCapabilities"))
		{	*type = SOAP_TYPE_ns2__IOCapabilities;
			return soap_in_ns2__IOCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SystemCapabilities"))
		{	*type = SOAP_TYPE_ns2__SystemCapabilities;
			return soap_in_ns2__SystemCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkCapabilities"))
		{	*type = SOAP_TYPE_ns2__NetworkCapabilities;
			return soap_in_ns2__NetworkCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CapabilitiesExtension"))
		{	*type = SOAP_TYPE_ns2__CapabilitiesExtension;
			return soap_in_ns2__CapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZCapabilities"))
		{	*type = SOAP_TYPE_ns2__PTZCapabilities;
			return soap_in_ns2__PTZCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MediaCapabilities"))
		{	*type = SOAP_TYPE_ns2__MediaCapabilities;
			return soap_in_ns2__MediaCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImagingCapabilities"))
		{	*type = SOAP_TYPE_ns2__ImagingCapabilities;
			return soap_in_ns2__ImagingCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventCapabilities"))
		{	*type = SOAP_TYPE_ns2__EventCapabilities;
			return soap_in_ns2__EventCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeviceCapabilities"))
		{	*type = SOAP_TYPE_ns2__DeviceCapabilities;
			return soap_in_ns2__DeviceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnalyticsCapabilities"))
		{	*type = SOAP_TYPE_ns2__AnalyticsCapabilities;
			return soap_in_ns2__AnalyticsCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Capabilities"))
		{	*type = SOAP_TYPE_ns2__Capabilities;
			return soap_in_ns2__Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPAddressFilterExtension"))
		{	*type = SOAP_TYPE_ns2__IPAddressFilterExtension;
			return soap_in_ns2__IPAddressFilterExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPAddressFilter"))
		{	*type = SOAP_TYPE_ns2__IPAddressFilter;
			return soap_in_ns2__IPAddressFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkZeroConfigurationExtension"))
		{	*type = SOAP_TYPE_ns2__NetworkZeroConfigurationExtension;
			return soap_in_ns2__NetworkZeroConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkZeroConfiguration"))
		{	*type = SOAP_TYPE_ns2__NetworkZeroConfiguration;
			return soap_in_ns2__NetworkZeroConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkGateway"))
		{	*type = SOAP_TYPE_ns2__NetworkGateway;
			return soap_in_ns2__NetworkGateway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterfaceSetConfigurationExtension"))
		{	*type = SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension;
			return soap_in_ns2__NetworkInterfaceSetConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv6NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration;
			return soap_in_ns2__IPv6NetworkInterfaceSetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv4NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration;
			return soap_in_ns2__IPv4NetworkInterfaceSetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration;
			return soap_in_ns2__NetworkInterfaceSetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DynamicDNSInformationExtension"))
		{	*type = SOAP_TYPE_ns2__DynamicDNSInformationExtension;
			return soap_in_ns2__DynamicDNSInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DynamicDNSInformation"))
		{	*type = SOAP_TYPE_ns2__DynamicDNSInformation;
			return soap_in_ns2__DynamicDNSInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NTPInformationExtension"))
		{	*type = SOAP_TYPE_ns2__NTPInformationExtension;
			return soap_in_ns2__NTPInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NTPInformation"))
		{	*type = SOAP_TYPE_ns2__NTPInformation;
			return soap_in_ns2__NTPInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DNSInformationExtension"))
		{	*type = SOAP_TYPE_ns2__DNSInformationExtension;
			return soap_in_ns2__DNSInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DNSInformation"))
		{	*type = SOAP_TYPE_ns2__DNSInformation;
			return soap_in_ns2__DNSInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HostnameInformationExtension"))
		{	*type = SOAP_TYPE_ns2__HostnameInformationExtension;
			return soap_in_ns2__HostnameInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HostnameInformation"))
		{	*type = SOAP_TYPE_ns2__HostnameInformation;
			return soap_in_ns2__HostnameInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkHostExtension"))
		{	*type = SOAP_TYPE_ns2__NetworkHostExtension;
			return soap_in_ns2__NetworkHostExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkHost"))
		{	*type = SOAP_TYPE_ns2__NetworkHost;
			return soap_in_ns2__NetworkHost(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkProtocolExtension"))
		{	*type = SOAP_TYPE_ns2__NetworkProtocolExtension;
			return soap_in_ns2__NetworkProtocolExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkProtocol"))
		{	*type = SOAP_TYPE_ns2__NetworkProtocol;
			return soap_in_ns2__NetworkProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv6ConfigurationExtension"))
		{	*type = SOAP_TYPE_ns2__IPv6ConfigurationExtension;
			return soap_in_ns2__IPv6ConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PrefixedIPv6Address"))
		{	*type = SOAP_TYPE_ns2__PrefixedIPv6Address;
			return soap_in_ns2__PrefixedIPv6Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PrefixedIPv4Address"))
		{	*type = SOAP_TYPE_ns2__PrefixedIPv4Address;
			return soap_in_ns2__PrefixedIPv4Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv4Configuration"))
		{	*type = SOAP_TYPE_ns2__IPv4Configuration;
			return soap_in_ns2__IPv4Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv4NetworkInterface"))
		{	*type = SOAP_TYPE_ns2__IPv4NetworkInterface;
			return soap_in_ns2__IPv4NetworkInterface(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv6Configuration"))
		{	*type = SOAP_TYPE_ns2__IPv6Configuration;
			return soap_in_ns2__IPv6Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPv6NetworkInterface"))
		{	*type = SOAP_TYPE_ns2__IPv6NetworkInterface;
			return soap_in_ns2__IPv6NetworkInterface(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterfaceInfo"))
		{	*type = SOAP_TYPE_ns2__NetworkInterfaceInfo;
			return soap_in_ns2__NetworkInterfaceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterfaceConnectionSetting"))
		{	*type = SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting;
			return soap_in_ns2__NetworkInterfaceConnectionSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterfaceLink"))
		{	*type = SOAP_TYPE_ns2__NetworkInterfaceLink;
			return soap_in_ns2__NetworkInterfaceLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NetworkInterfaceExtension"))
		{	*type = SOAP_TYPE_ns2__NetworkInterfaceExtension;
			return soap_in_ns2__NetworkInterfaceExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Scope"))
		{	*type = SOAP_TYPE_ns2__Scope;
			return soap_in_ns2__Scope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Transport"))
		{	*type = SOAP_TYPE_ns2__Transport;
			return soap_in_ns2__Transport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IPAddress"))
		{	*type = SOAP_TYPE_ns2__IPAddress;
			return soap_in_ns2__IPAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MulticastConfiguration"))
		{	*type = SOAP_TYPE_ns2__MulticastConfiguration;
			return soap_in_ns2__MulticastConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZStatusFilterOptions"))
		{	*type = SOAP_TYPE_ns2__PTZStatusFilterOptions;
			return soap_in_ns2__PTZStatusFilterOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MetadataConfigurationOptions"))
		{	*type = SOAP_TYPE_ns2__MetadataConfigurationOptions;
			return soap_in_ns2__MetadataConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FilterType"))
		{	*type = SOAP_TYPE_ns2__FilterType;
			return soap_in_ns2__FilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventSubscription"))
		{	*type = SOAP_TYPE_ns2__EventSubscription;
			return soap_in_ns2__EventSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZFilter"))
		{	*type = SOAP_TYPE_ns2__PTZFilter;
			return soap_in_ns2__PTZFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioEncoderConfigurationOption"))
		{	*type = SOAP_TYPE_ns2__AudioEncoderConfigurationOption;
			return soap_in_ns2__AudioEncoderConfigurationOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioEncoderConfigurationOptions"))
		{	*type = SOAP_TYPE_ns2__AudioEncoderConfigurationOptions;
			return soap_in_ns2__AudioEncoderConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioSourceOptionsExtension"))
		{	*type = SOAP_TYPE_ns2__AudioSourceOptionsExtension;
			return soap_in_ns2__AudioSourceOptionsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioSourceConfigurationOptions"))
		{	*type = SOAP_TYPE_ns2__AudioSourceConfigurationOptions;
			return soap_in_ns2__AudioSourceConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoEncoderOptionsExtension"))
		{	*type = SOAP_TYPE_ns2__VideoEncoderOptionsExtension;
			return soap_in_ns2__VideoEncoderOptionsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:H264Options"))
		{	*type = SOAP_TYPE_ns2__H264Options;
			return soap_in_ns2__H264Options(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Mpeg4Options"))
		{	*type = SOAP_TYPE_ns2__Mpeg4Options;
			return soap_in_ns2__Mpeg4Options(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:JpegOptions"))
		{	*type = SOAP_TYPE_ns2__JpegOptions;
			return soap_in_ns2__JpegOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:H264Configuration"))
		{	*type = SOAP_TYPE_ns2__H264Configuration;
			return soap_in_ns2__H264Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Mpeg4Configuration"))
		{	*type = SOAP_TYPE_ns2__Mpeg4Configuration;
			return soap_in_ns2__Mpeg4Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoRateControl"))
		{	*type = SOAP_TYPE_ns2__VideoRateControl;
			return soap_in_ns2__VideoRateControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoResolution"))
		{	*type = SOAP_TYPE_ns2__VideoResolution;
			return soap_in_ns2__VideoResolution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoSourceConfigurationOptionsExtension"))
		{	*type = SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension;
			return soap_in_ns2__VideoSourceConfigurationOptionsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoSourceConfigurationOptions"))
		{	*type = SOAP_TYPE_ns2__VideoSourceConfigurationOptions;
			return soap_in_ns2__VideoSourceConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConfigurationEntity"))
		{	*type = SOAP_TYPE_ns2__ConfigurationEntity;
			return soap_in_ns2__ConfigurationEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ProfileExtension"))
		{	*type = SOAP_TYPE_ns2__ProfileExtension;
			return soap_in_ns2__ProfileExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MetadataConfiguration"))
		{	*type = SOAP_TYPE_ns2__MetadataConfiguration;
			return soap_in_ns2__MetadataConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PTZConfiguration"))
		{	*type = SOAP_TYPE_ns2__PTZConfiguration;
			return soap_in_ns2__PTZConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoAnalyticsConfiguration"))
		{	*type = SOAP_TYPE_ns2__VideoAnalyticsConfiguration;
			return soap_in_ns2__VideoAnalyticsConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioEncoderConfiguration"))
		{	*type = SOAP_TYPE_ns2__AudioEncoderConfiguration;
			return soap_in_ns2__AudioEncoderConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AudioSourceConfiguration"))
		{	*type = SOAP_TYPE_ns2__AudioSourceConfiguration;
			return soap_in_ns2__AudioSourceConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoSourceConfiguration"))
		{	*type = SOAP_TYPE_ns2__VideoSourceConfiguration;
			return soap_in_ns2__VideoSourceConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoSourceExtension"))
		{	*type = SOAP_TYPE_ns2__VideoSourceExtension;
			return soap_in_ns2__VideoSourceExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IntList"))
		{	*type = SOAP_TYPE_ns2__IntList;
			return soap_in_ns2__IntList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DurationRange"))
		{	*type = SOAP_TYPE_ns2__DurationRange;
			return soap_in_ns2__DurationRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FloatRange"))
		{	*type = SOAP_TYPE_ns2__FloatRange;
			return soap_in_ns2__FloatRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IntRange"))
		{	*type = SOAP_TYPE_ns2__IntRange;
			return soap_in_ns2__IntRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IntRectangleRange"))
		{	*type = SOAP_TYPE_ns2__IntRectangleRange;
			return soap_in_ns2__IntRectangleRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IntRectangle"))
		{	*type = SOAP_TYPE_ns2__IntRectangle;
			return soap_in_ns2__IntRectangle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeviceEntity"))
		{	*type = SOAP_TYPE_ns2__DeviceEntity;
			return soap_in_ns2__DeviceEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UserExtension"))
		{	*type = SOAP_TYPE_ns2__UserExtension;
			return soap_in_ns2__UserExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:User"))
		{	*type = SOAP_TYPE_ns2__User;
			return soap_in_ns2__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoEncoderConfiguration"))
		{	*type = SOAP_TYPE_ns2__VideoEncoderConfiguration;
			return soap_in_ns2__VideoEncoderConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VideoEncoderConfigurationOptions"))
		{	*type = SOAP_TYPE_ns2__VideoEncoderConfigurationOptions;
			return soap_in_ns2__VideoEncoderConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MediaUri"))
		{	*type = SOAP_TYPE_ns2__MediaUri;
			return soap_in_ns2__MediaUri(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StreamSetup"))
		{	*type = SOAP_TYPE_ns2__StreamSetup;
			return soap_in_ns2__StreamSetup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Profile"))
		{	*type = SOAP_TYPE_ns2__Profile;
			return soap_in_ns2__Profile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertyType;
			return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertiesType;
			return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceType"))
		{	*type = SOAP_TYPE_xenc__ReferenceType;
			return soap_in_xenc__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:AgreementMethodType"))
		{	*type = SOAP_TYPE_xenc__AgreementMethodType;
			return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType"))
		{	*type = SOAP_TYPE_xenc__EncryptedKeyType;
			return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedDataType"))
		{	*type = SOAP_TYPE_xenc__EncryptedDataType;
			return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:TransformsType"))
		{	*type = SOAP_TYPE_xenc__TransformsType;
			return soap_in_xenc__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherReferenceType"))
		{	*type = SOAP_TYPE_xenc__CipherReferenceType;
			return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherDataType"))
		{	*type = SOAP_TYPE_xenc__CipherDataType;
			return soap_in_xenc__CipherDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType"))
		{	*type = SOAP_TYPE_xenc__EncryptionMethodType;
			return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedType"))
		{	*type = SOAP_TYPE_xenc__EncryptedType;
			return soap_in_xenc__EncryptedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TopicNamespaceLocation"))
		{	char **s;
			*type = SOAP_TYPE_ns2__TopicNamespaceLocation;
			s = soap_in_ns2__TopicNamespaceLocation(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:AuxiliaryData"))
		{	char **s;
			*type = SOAP_TYPE_ns2__AuxiliaryData;
			s = soap_in_ns2__AuxiliaryData(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:Domain"))
		{	char **s;
			*type = SOAP_TYPE_ns2__Domain;
			s = soap_in_ns2__Domain(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:DNSName"))
		{	char **s;
			*type = SOAP_TYPE_ns2__DNSName;
			s = soap_in_ns2__DNSName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:HwAddress"))
		{	char **s;
			*type = SOAP_TYPE_ns2__HwAddress;
			s = soap_in_ns2__HwAddress(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:IPv6Address"))
		{	char **s;
			*type = SOAP_TYPE_ns2__IPv6Address;
			s = soap_in_ns2__IPv6Address(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:IPv4Address"))
		{	char **s;
			*type = SOAP_TYPE_ns2__IPv4Address;
			s = soap_in_ns2__IPv4Address(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:Name"))
		{	char **s;
			*type = SOAP_TYPE_ns2__Name;
			s = soap_in_ns2__Name(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:ReferenceToken"))
		{	char **s;
			*type = SOAP_TYPE_ns2__ReferenceToken;
			s = soap_in_ns2__ReferenceToken(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	char **s;
			*type = SOAP_TYPE_xsd__token;
			s = soap_in_xsd__token(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	char **s;
			*type = SOAP_TYPE_xsd__integer;
			s = soap_in_xsd__integer(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anySimpleType;
			s = soap_in_xsd__anySimpleType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:Message"))
		{	*type = SOAP_TYPE__ns2__Message;
			return soap_in__ns2__Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__ns2__NotificationMessageHolderType_Message;
			return soap_in__ns2__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConfigDescription-Messages"))
		{	*type = SOAP_TYPE__ns2__ConfigDescription_Messages;
			return soap_in__ns2__ConfigDescription_Messages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Behaviour-Idle"))
		{	*type = SOAP_TYPE__ns2__Behaviour_Idle;
			return soap_in__ns2__Behaviour_Idle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Behaviour-Removed"))
		{	*type = SOAP_TYPE__ns2__Behaviour_Removed;
			return soap_in__ns2__Behaviour_Removed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClassDescriptor-ClassCandidate"))
		{	*type = SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate;
			return soap_in__ns2__ClassDescriptor_ClassCandidate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ColorDescriptor-ColorCluster"))
		{	*type = SOAP_TYPE__ns2__ColorDescriptor_ColorCluster;
			return soap_in__ns2__ColorDescriptor_ColorCluster(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemListDescription-ElementItemDescription"))
		{	*type = SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription;
			return soap_in__ns2__ItemListDescription_ElementItemDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemListDescription-SimpleItemDescription"))
		{	*type = SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription;
			return soap_in__ns2__ItemListDescription_SimpleItemDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemList-ElementItem"))
		{	*type = SOAP_TYPE__ns2__ItemList_ElementItem;
			return soap_in__ns2__ItemList_ElementItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ItemList-SimpleItem"))
		{	*type = SOAP_TYPE__ns2__ItemList_SimpleItem;
			return soap_in__ns2__ItemList_SimpleItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventSubscription-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy;
			return soap_in__ns2__EventSubscription_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSnapshotUriResponse"))
		{	*type = SOAP_TYPE__ns1__GetSnapshotUriResponse;
			return soap_in__ns1__GetSnapshotUriResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSnapshotUri"))
		{	*type = SOAP_TYPE__ns1__GetSnapshotUri;
			return soap_in__ns1__GetSnapshotUri(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetVideoEncoderConfigurationResponse"))
		{	*type = SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse;
			return soap_in__ns1__SetVideoEncoderConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetVideoEncoderConfiguration"))
		{	*type = SOAP_TYPE__ns1__SetVideoEncoderConfiguration;
			return soap_in__ns1__SetVideoEncoderConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVideoEncoderConfigurationOptionsResponse"))
		{	*type = SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse;
			return soap_in__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVideoEncoderConfigurationOptions"))
		{	*type = SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions;
			return soap_in__ns1__GetVideoEncoderConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStreamUriResponse"))
		{	*type = SOAP_TYPE__ns1__GetStreamUriResponse;
			return soap_in__ns1__GetStreamUriResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStreamUri"))
		{	*type = SOAP_TYPE__ns1__GetStreamUri;
			return soap_in__ns1__GetStreamUri(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProfilesResponse"))
		{	*type = SOAP_TYPE__ns1__GetProfilesResponse;
			return soap_in__ns1__GetProfilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProfiles"))
		{	*type = SOAP_TYPE__ns1__GetProfiles;
			return soap_in__ns1__GetProfiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceList"))
		{	*type = SOAP_TYPE__xenc__ReferenceList;
			return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfo"))
		{	*type = SOAP_TYPE__ds__KeyInfo;
			return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Transform"))
		{	*type = SOAP_TYPE__ds__Transform;
			return soap_in__ds__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Signature"))
		{	*type = SOAP_TYPE__ds__Signature;
			return soap_in__ds__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns2__IANA_IfTypes:
		return soap_out_ns2__IANA_IfTypes(soap, tag, id, (const int *)ptr, "ns2:IANA-IfTypes");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns2__ClassType:
		return soap_out_ns2__ClassType(soap, tag, id, (const enum ns2__ClassType *)ptr, "ns2:ClassType");
	case SOAP_TYPE_ns2__Direction:
		return soap_out_ns2__Direction(soap, tag, id, (const enum ns2__Direction *)ptr, "ns2:Direction");
	case SOAP_TYPE_ns2__PropertyOperation:
		return soap_out_ns2__PropertyOperation(soap, tag, id, (const enum ns2__PropertyOperation *)ptr, "ns2:PropertyOperation");
	case SOAP_TYPE_ns2__IrCutFilterMode:
		return soap_out_ns2__IrCutFilterMode(soap, tag, id, (const enum ns2__IrCutFilterMode *)ptr, "ns2:IrCutFilterMode");
	case SOAP_TYPE_ns2__WhiteBalanceMode:
		return soap_out_ns2__WhiteBalanceMode(soap, tag, id, (const enum ns2__WhiteBalanceMode *)ptr, "ns2:WhiteBalanceMode");
	case SOAP_TYPE_ns2__Enabled:
		return soap_out_ns2__Enabled(soap, tag, id, (const enum ns2__Enabled *)ptr, "ns2:Enabled");
	case SOAP_TYPE_ns2__ExposureMode:
		return soap_out_ns2__ExposureMode(soap, tag, id, (const enum ns2__ExposureMode *)ptr, "ns2:ExposureMode");
	case SOAP_TYPE_ns2__ExposurePriority:
		return soap_out_ns2__ExposurePriority(soap, tag, id, (const enum ns2__ExposurePriority *)ptr, "ns2:ExposurePriority");
	case SOAP_TYPE_ns2__BacklightCompensationMode:
		return soap_out_ns2__BacklightCompensationMode(soap, tag, id, (const enum ns2__BacklightCompensationMode *)ptr, "ns2:BacklightCompensationMode");
	case SOAP_TYPE_ns2__WideDynamicMode:
		return soap_out_ns2__WideDynamicMode(soap, tag, id, (const enum ns2__WideDynamicMode *)ptr, "ns2:WideDynamicMode");
	case SOAP_TYPE_ns2__AutoFocusMode:
		return soap_out_ns2__AutoFocusMode(soap, tag, id, (const enum ns2__AutoFocusMode *)ptr, "ns2:AutoFocusMode");
	case SOAP_TYPE_ns2__MoveStatus:
		return soap_out_ns2__MoveStatus(soap, tag, id, (const enum ns2__MoveStatus *)ptr, "ns2:MoveStatus");
	case SOAP_TYPE_ns2__RelayMode:
		return soap_out_ns2__RelayMode(soap, tag, id, (const enum ns2__RelayMode *)ptr, "ns2:RelayMode");
	case SOAP_TYPE_ns2__RelayIdleState:
		return soap_out_ns2__RelayIdleState(soap, tag, id, (const enum ns2__RelayIdleState *)ptr, "ns2:RelayIdleState");
	case SOAP_TYPE_ns2__RelayLogicalState:
		return soap_out_ns2__RelayLogicalState(soap, tag, id, (const enum ns2__RelayLogicalState *)ptr, "ns2:RelayLogicalState");
	case SOAP_TYPE_ns2__SetDateTimeType:
		return soap_out_ns2__SetDateTimeType(soap, tag, id, (const enum ns2__SetDateTimeType *)ptr, "ns2:SetDateTimeType");
	case SOAP_TYPE_ns2__FactoryDefaultType:
		return soap_out_ns2__FactoryDefaultType(soap, tag, id, (const enum ns2__FactoryDefaultType *)ptr, "ns2:FactoryDefaultType");
	case SOAP_TYPE_ns2__SystemLogType:
		return soap_out_ns2__SystemLogType(soap, tag, id, (const enum ns2__SystemLogType *)ptr, "ns2:SystemLogType");
	case SOAP_TYPE_ns2__CapabilityCategory:
		return soap_out_ns2__CapabilityCategory(soap, tag, id, (const enum ns2__CapabilityCategory *)ptr, "ns2:CapabilityCategory");
	case SOAP_TYPE_ns2__DynamicDNSType:
		return soap_out_ns2__DynamicDNSType(soap, tag, id, (const enum ns2__DynamicDNSType *)ptr, "ns2:DynamicDNSType");
	case SOAP_TYPE_ns2__IPAddressFilterType:
		return soap_out_ns2__IPAddressFilterType(soap, tag, id, (const enum ns2__IPAddressFilterType *)ptr, "ns2:IPAddressFilterType");
	case SOAP_TYPE_ns2__IPType:
		return soap_out_ns2__IPType(soap, tag, id, (const enum ns2__IPType *)ptr, "ns2:IPType");
	case SOAP_TYPE_ns2__NetworkHostType:
		return soap_out_ns2__NetworkHostType(soap, tag, id, (const enum ns2__NetworkHostType *)ptr, "ns2:NetworkHostType");
	case SOAP_TYPE_ns2__NetworkProtocolType:
		return soap_out_ns2__NetworkProtocolType(soap, tag, id, (const enum ns2__NetworkProtocolType *)ptr, "ns2:NetworkProtocolType");
	case SOAP_TYPE_ns2__IPv6DHCPConfiguration:
		return soap_out_ns2__IPv6DHCPConfiguration(soap, tag, id, (const enum ns2__IPv6DHCPConfiguration *)ptr, "ns2:IPv6DHCPConfiguration");
	case SOAP_TYPE_ns2__Duplex:
		return soap_out_ns2__Duplex(soap, tag, id, (const enum ns2__Duplex *)ptr, "ns2:Duplex");
	case SOAP_TYPE_ns2__DiscoveryMode:
		return soap_out_ns2__DiscoveryMode(soap, tag, id, (const enum ns2__DiscoveryMode *)ptr, "ns2:DiscoveryMode");
	case SOAP_TYPE_ns2__ScopeDefinition:
		return soap_out_ns2__ScopeDefinition(soap, tag, id, (const enum ns2__ScopeDefinition *)ptr, "ns2:ScopeDefinition");
	case SOAP_TYPE_ns2__TransportProtocol:
		return soap_out_ns2__TransportProtocol(soap, tag, id, (const enum ns2__TransportProtocol *)ptr, "ns2:TransportProtocol");
	case SOAP_TYPE_ns2__StreamType:
		return soap_out_ns2__StreamType(soap, tag, id, (const enum ns2__StreamType *)ptr, "ns2:StreamType");
	case SOAP_TYPE_ns2__AudioEncoding:
		return soap_out_ns2__AudioEncoding(soap, tag, id, (const enum ns2__AudioEncoding *)ptr, "ns2:AudioEncoding");
	case SOAP_TYPE_ns2__H264Profile:
		return soap_out_ns2__H264Profile(soap, tag, id, (const enum ns2__H264Profile *)ptr, "ns2:H264Profile");
	case SOAP_TYPE_ns2__Mpeg4Profile:
		return soap_out_ns2__Mpeg4Profile(soap, tag, id, (const enum ns2__Mpeg4Profile *)ptr, "ns2:Mpeg4Profile");
	case SOAP_TYPE_ns2__VideoEncoding:
		return soap_out_ns2__VideoEncoding(soap, tag, id, (const enum ns2__VideoEncoding *)ptr, "ns2:VideoEncoding");
	case SOAP_TYPE_ns2__UserLevel:
		return soap_out_ns2__UserLevel(soap, tag, id, (const enum ns2__UserLevel *)ptr, "ns2:UserLevel");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_ns2__PTZNode:
		return soap_out_ns2__PTZNode(soap, tag, id, (const struct ns2__PTZNode *)ptr, "ns2:PTZNode");
	case SOAP_TYPE_ns2__RelayOutput:
		return soap_out_ns2__RelayOutput(soap, tag, id, (const struct ns2__RelayOutput *)ptr, "ns2:RelayOutput");
	case SOAP_TYPE_ns2__NetworkInterface:
		return soap_out_ns2__NetworkInterface(soap, tag, id, (const struct ns2__NetworkInterface *)ptr, "ns2:NetworkInterface");
	case SOAP_TYPE_ns2__AudioSource:
		return soap_out_ns2__AudioSource(soap, tag, id, (const struct ns2__AudioSource *)ptr, "ns2:AudioSource");
	case SOAP_TYPE_ns2__VideoSource:
		return soap_out_ns2__VideoSource(soap, tag, id, (const struct ns2__VideoSource *)ptr, "ns2:VideoSource");
	case SOAP_TYPE__ns2__Message:
		return soap_out__ns2__Message(soap, "ns2:Message", id, (const struct _ns2__Message *)ptr, NULL);
	case SOAP_TYPE_ns2__MetadataType:
		return soap_out_ns2__MetadataType(soap, tag, id, (const struct ns2__MetadataType *)ptr, "ns2:MetadataType");
	case SOAP_TYPE_ns2__ReferenceParametersType:
		return soap_out_ns2__ReferenceParametersType(soap, tag, id, (const struct ns2__ReferenceParametersType *)ptr, "ns2:ReferenceParametersType");
	case SOAP_TYPE_ns2__AttributedURIType:
		return soap_out_ns2__AttributedURIType(soap, tag, id, (const struct ns2__AttributedURIType *)ptr, "ns2:AttributedURIType");
	case SOAP_TYPE__ns2__NotificationMessageHolderType_Message:
		return soap_out__ns2__NotificationMessageHolderType_Message(soap, "ns2:NotificationMessageHolderType-Message", id, (const struct _ns2__NotificationMessageHolderType_Message *)ptr, NULL);
	case SOAP_TYPE_ns2__TopicExpressionType:
		return soap_out_ns2__TopicExpressionType(soap, tag, id, (const struct ns2__TopicExpressionType *)ptr, "ns2:TopicExpressionType");
	case SOAP_TYPE_ns2__EndpointReferenceType:
		return soap_out_ns2__EndpointReferenceType(soap, tag, id, (const struct ns2__EndpointReferenceType *)ptr, "ns2:EndpointReferenceType");
	case SOAP_TYPE_ns2__EventStreamExtension:
		return soap_out_ns2__EventStreamExtension(soap, tag, id, (const struct ns2__EventStreamExtension *)ptr, "ns2:EventStreamExtension");
	case SOAP_TYPE_ns2__NotificationMessageHolderType:
		return soap_out_ns2__NotificationMessageHolderType(soap, tag, id, (const struct ns2__NotificationMessageHolderType *)ptr, "ns2:NotificationMessageHolderType");
	case SOAP_TYPE_ns2__PTZStreamExtension:
		return soap_out_ns2__PTZStreamExtension(soap, tag, id, (const struct ns2__PTZStreamExtension *)ptr, "ns2:PTZStreamExtension");
	case SOAP_TYPE_ns2__VideoAnalyticsStreamExtension:
		return soap_out_ns2__VideoAnalyticsStreamExtension(soap, tag, id, (const struct ns2__VideoAnalyticsStreamExtension *)ptr, "ns2:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_ns2__MetadataStreamExtension:
		return soap_out_ns2__MetadataStreamExtension(soap, tag, id, (const struct ns2__MetadataStreamExtension *)ptr, "ns2:MetadataStreamExtension");
	case SOAP_TYPE_ns2__EventStream:
		return soap_out_ns2__EventStream(soap, tag, id, (const struct ns2__EventStream *)ptr, "ns2:EventStream");
	case SOAP_TYPE_ns2__PTZStream:
		return soap_out_ns2__PTZStream(soap, tag, id, (const struct ns2__PTZStream *)ptr, "ns2:PTZStream");
	case SOAP_TYPE_ns2__VideoAnalyticsStream:
		return soap_out_ns2__VideoAnalyticsStream(soap, tag, id, (const struct ns2__VideoAnalyticsStream *)ptr, "ns2:VideoAnalyticsStream");
	case SOAP_TYPE_ns2__MetadataStream:
		return soap_out_ns2__MetadataStream(soap, tag, id, (const struct ns2__MetadataStream *)ptr, "ns2:MetadataStream");
	case SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension:
		return soap_out_ns2__SupportedAnalyticsModulesExtension(soap, tag, id, (const struct ns2__SupportedAnalyticsModulesExtension *)ptr, "ns2:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_ns2__SupportedAnalyticsModules:
		return soap_out_ns2__SupportedAnalyticsModules(soap, tag, id, (const struct ns2__SupportedAnalyticsModules *)ptr, "ns2:SupportedAnalyticsModules");
	case SOAP_TYPE_ns2__SupportedRulesExtension:
		return soap_out_ns2__SupportedRulesExtension(soap, tag, id, (const struct ns2__SupportedRulesExtension *)ptr, "ns2:SupportedRulesExtension");
	case SOAP_TYPE_ns2__SupportedRules:
		return soap_out_ns2__SupportedRules(soap, tag, id, (const struct ns2__SupportedRules *)ptr, "ns2:SupportedRules");
	case SOAP_TYPE_ns2__ConfigDescriptionExtension:
		return soap_out_ns2__ConfigDescriptionExtension(soap, tag, id, (const struct ns2__ConfigDescriptionExtension *)ptr, "ns2:ConfigDescriptionExtension");
	case SOAP_TYPE__ns2__ConfigDescription_Messages:
		return soap_out__ns2__ConfigDescription_Messages(soap, "ns2:ConfigDescription-Messages", id, (const struct _ns2__ConfigDescription_Messages *)ptr, NULL);
	case SOAP_TYPE_ns2__ConfigDescription:
		return soap_out_ns2__ConfigDescription(soap, tag, id, (const struct ns2__ConfigDescription *)ptr, "ns2:ConfigDescription");
	case SOAP_TYPE_ns2__RuleEngineConfigurationExtension:
		return soap_out_ns2__RuleEngineConfigurationExtension(soap, tag, id, (const struct ns2__RuleEngineConfigurationExtension *)ptr, "ns2:RuleEngineConfigurationExtension");
	case SOAP_TYPE_ns2__RuleEngineConfiguration:
		return soap_out_ns2__RuleEngineConfiguration(soap, tag, id, (const struct ns2__RuleEngineConfiguration *)ptr, "ns2:RuleEngineConfiguration");
	case SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension:
		return soap_out_ns2__AnalyticsEngineConfigurationExtension(soap, tag, id, (const struct ns2__AnalyticsEngineConfigurationExtension *)ptr, "ns2:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_ns2__Config:
		return soap_out_ns2__Config(soap, tag, id, (const struct ns2__Config *)ptr, "ns2:Config");
	case SOAP_TYPE_ns2__AnalyticsEngineConfiguration:
		return soap_out_ns2__AnalyticsEngineConfiguration(soap, tag, id, (const struct ns2__AnalyticsEngineConfiguration *)ptr, "ns2:AnalyticsEngineConfiguration");
	case SOAP_TYPE_ns2__ObjectTreeExtension:
		return soap_out_ns2__ObjectTreeExtension(soap, tag, id, (const struct ns2__ObjectTreeExtension *)ptr, "ns2:ObjectTreeExtension");
	case SOAP_TYPE_ns2__BehaviourExtension:
		return soap_out_ns2__BehaviourExtension(soap, tag, id, (const struct ns2__BehaviourExtension *)ptr, "ns2:BehaviourExtension");
	case SOAP_TYPE__ns2__Behaviour_Idle:
		return soap_out__ns2__Behaviour_Idle(soap, "ns2:Behaviour-Idle", id, (const struct _ns2__Behaviour_Idle *)ptr, NULL);
	case SOAP_TYPE__ns2__Behaviour_Removed:
		return soap_out__ns2__Behaviour_Removed(soap, "ns2:Behaviour-Removed", id, (const struct _ns2__Behaviour_Removed *)ptr, NULL);
	case SOAP_TYPE_ns2__Behaviour:
		return soap_out_ns2__Behaviour(soap, tag, id, (const struct ns2__Behaviour *)ptr, "ns2:Behaviour");
	case SOAP_TYPE_ns2__Rename:
		return soap_out_ns2__Rename(soap, tag, id, (const struct ns2__Rename *)ptr, "ns2:Rename");
	case SOAP_TYPE_ns2__Split:
		return soap_out_ns2__Split(soap, tag, id, (const struct ns2__Split *)ptr, "ns2:Split");
	case SOAP_TYPE_ns2__ObjectId:
		return soap_out_ns2__ObjectId(soap, tag, id, (const struct ns2__ObjectId *)ptr, "ns2:ObjectId");
	case SOAP_TYPE_ns2__Merge:
		return soap_out_ns2__Merge(soap, tag, id, (const struct ns2__Merge *)ptr, "ns2:Merge");
	case SOAP_TYPE_ns2__FrameExtension:
		return soap_out_ns2__FrameExtension(soap, tag, id, (const struct ns2__FrameExtension *)ptr, "ns2:FrameExtension");
	case SOAP_TYPE_ns2__ObjectTree:
		return soap_out_ns2__ObjectTree(soap, tag, id, (const struct ns2__ObjectTree *)ptr, "ns2:ObjectTree");
	case SOAP_TYPE_ns2__Object:
		return soap_out_ns2__Object(soap, tag, id, (const struct ns2__Object *)ptr, "ns2:Object");
	case SOAP_TYPE_ns2__Frame:
		return soap_out_ns2__Frame(soap, tag, id, (const struct ns2__Frame *)ptr, "ns2:Frame");
	case SOAP_TYPE_ns2__TransformationExtension:
		return soap_out_ns2__TransformationExtension(soap, tag, id, (const struct ns2__TransformationExtension *)ptr, "ns2:TransformationExtension");
	case SOAP_TYPE_ns2__ObjectExtension:
		return soap_out_ns2__ObjectExtension(soap, tag, id, (const struct ns2__ObjectExtension *)ptr, "ns2:ObjectExtension");
	case SOAP_TYPE_ns2__ClassDescriptorExtension:
		return soap_out_ns2__ClassDescriptorExtension(soap, tag, id, (const struct ns2__ClassDescriptorExtension *)ptr, "ns2:ClassDescriptorExtension");
	case SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate:
		return soap_out__ns2__ClassDescriptor_ClassCandidate(soap, "ns2:ClassDescriptor-ClassCandidate", id, (const struct _ns2__ClassDescriptor_ClassCandidate *)ptr, NULL);
	case SOAP_TYPE_ns2__ColorDescriptorExtension:
		return soap_out_ns2__ColorDescriptorExtension(soap, tag, id, (const struct ns2__ColorDescriptorExtension *)ptr, "ns2:ColorDescriptorExtension");
	case SOAP_TYPE__ns2__ColorDescriptor_ColorCluster:
		return soap_out__ns2__ColorDescriptor_ColorCluster(soap, "ns2:ColorDescriptor-ColorCluster", id, (const struct _ns2__ColorDescriptor_ColorCluster *)ptr, NULL);
	case SOAP_TYPE_ns2__ShapeDescriptorExtension:
		return soap_out_ns2__ShapeDescriptorExtension(soap, tag, id, (const struct ns2__ShapeDescriptorExtension *)ptr, "ns2:ShapeDescriptorExtension");
	case SOAP_TYPE_ns2__AppearanceExtension:
		return soap_out_ns2__AppearanceExtension(soap, tag, id, (const struct ns2__AppearanceExtension *)ptr, "ns2:AppearanceExtension");
	case SOAP_TYPE_ns2__ClassDescriptor:
		return soap_out_ns2__ClassDescriptor(soap, tag, id, (const struct ns2__ClassDescriptor *)ptr, "ns2:ClassDescriptor");
	case SOAP_TYPE_ns2__ColorDescriptor:
		return soap_out_ns2__ColorDescriptor(soap, tag, id, (const struct ns2__ColorDescriptor *)ptr, "ns2:ColorDescriptor");
	case SOAP_TYPE_ns2__ShapeDescriptor:
		return soap_out_ns2__ShapeDescriptor(soap, tag, id, (const struct ns2__ShapeDescriptor *)ptr, "ns2:ShapeDescriptor");
	case SOAP_TYPE_ns2__Transformation:
		return soap_out_ns2__Transformation(soap, tag, id, (const struct ns2__Transformation *)ptr, "ns2:Transformation");
	case SOAP_TYPE_ns2__Appearance:
		return soap_out_ns2__Appearance(soap, tag, id, (const struct ns2__Appearance *)ptr, "ns2:Appearance");
	case SOAP_TYPE_ns2__ColorCovariance:
		return soap_out_ns2__ColorCovariance(soap, tag, id, (const struct ns2__ColorCovariance *)ptr, "ns2:ColorCovariance");
	case SOAP_TYPE_ns2__Color:
		return soap_out_ns2__Color(soap, tag, id, (const struct ns2__Color *)ptr, "ns2:Color");
	case SOAP_TYPE_ns2__Polyline:
		return soap_out_ns2__Polyline(soap, tag, id, (const struct ns2__Polyline *)ptr, "ns2:Polyline");
	case SOAP_TYPE_ns2__Polygon:
		return soap_out_ns2__Polygon(soap, tag, id, (const struct ns2__Polygon *)ptr, "ns2:Polygon");
	case SOAP_TYPE_ns2__Vector:
		return soap_out_ns2__Vector(soap, tag, id, (const struct ns2__Vector *)ptr, "ns2:Vector");
	case SOAP_TYPE_ns2__ItemListDescriptionExtension:
		return soap_out_ns2__ItemListDescriptionExtension(soap, tag, id, (const struct ns2__ItemListDescriptionExtension *)ptr, "ns2:ItemListDescriptionExtension");
	case SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription:
		return soap_out__ns2__ItemListDescription_ElementItemDescription(soap, "ns2:ItemListDescription-ElementItemDescription", id, (const struct _ns2__ItemListDescription_ElementItemDescription *)ptr, NULL);
	case SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription:
		return soap_out__ns2__ItemListDescription_SimpleItemDescription(soap, "ns2:ItemListDescription-SimpleItemDescription", id, (const struct _ns2__ItemListDescription_SimpleItemDescription *)ptr, NULL);
	case SOAP_TYPE_ns2__MessageDescriptionExtension:
		return soap_out_ns2__MessageDescriptionExtension(soap, tag, id, (const struct ns2__MessageDescriptionExtension *)ptr, "ns2:MessageDescriptionExtension");
	case SOAP_TYPE_ns2__ItemListDescription:
		return soap_out_ns2__ItemListDescription(soap, tag, id, (const struct ns2__ItemListDescription *)ptr, "ns2:ItemListDescription");
	case SOAP_TYPE_ns2__MessageDescription:
		return soap_out_ns2__MessageDescription(soap, tag, id, (const struct ns2__MessageDescription *)ptr, "ns2:MessageDescription");
	case SOAP_TYPE_ns2__ItemListExtension:
		return soap_out_ns2__ItemListExtension(soap, tag, id, (const struct ns2__ItemListExtension *)ptr, "ns2:ItemListExtension");
	case SOAP_TYPE__ns2__ItemList_ElementItem:
		return soap_out__ns2__ItemList_ElementItem(soap, "ns2:ItemList-ElementItem", id, (const struct _ns2__ItemList_ElementItem *)ptr, NULL);
	case SOAP_TYPE__ns2__ItemList_SimpleItem:
		return soap_out__ns2__ItemList_SimpleItem(soap, "ns2:ItemList-SimpleItem", id, (const struct _ns2__ItemList_SimpleItem *)ptr, NULL);
	case SOAP_TYPE_ns2__ItemList:
		return soap_out_ns2__ItemList(soap, tag, id, (const struct ns2__ItemList *)ptr, "ns2:ItemList");
	case SOAP_TYPE_ns2__MessageExtension:
		return soap_out_ns2__MessageExtension(soap, tag, id, (const struct ns2__MessageExtension *)ptr, "ns2:MessageExtension");
	case SOAP_TYPE_ns2__FocusOptions20Extension:
		return soap_out_ns2__FocusOptions20Extension(soap, tag, id, (const struct ns2__FocusOptions20Extension *)ptr, "ns2:FocusOptions20Extension");
	case SOAP_TYPE_ns2__WhiteBalanceOptions20Extension:
		return soap_out_ns2__WhiteBalanceOptions20Extension(soap, tag, id, (const struct ns2__WhiteBalanceOptions20Extension *)ptr, "ns2:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_ns2__FocusConfiguration20Extension:
		return soap_out_ns2__FocusConfiguration20Extension(soap, tag, id, (const struct ns2__FocusConfiguration20Extension *)ptr, "ns2:FocusConfiguration20Extension");
	case SOAP_TYPE_ns2__WhiteBalance20Extension:
		return soap_out_ns2__WhiteBalance20Extension(soap, tag, id, (const struct ns2__WhiteBalance20Extension *)ptr, "ns2:WhiteBalance20Extension");
	case SOAP_TYPE_ns2__RelativeFocusOptions20:
		return soap_out_ns2__RelativeFocusOptions20(soap, tag, id, (const struct ns2__RelativeFocusOptions20 *)ptr, "ns2:RelativeFocusOptions20");
	case SOAP_TYPE_ns2__MoveOptions20:
		return soap_out_ns2__MoveOptions20(soap, tag, id, (const struct ns2__MoveOptions20 *)ptr, "ns2:MoveOptions20");
	case SOAP_TYPE_ns2__ImagingOptions20Extension:
		return soap_out_ns2__ImagingOptions20Extension(soap, tag, id, (const struct ns2__ImagingOptions20Extension *)ptr, "ns2:ImagingOptions20Extension");
	case SOAP_TYPE_ns2__WhiteBalanceOptions20:
		return soap_out_ns2__WhiteBalanceOptions20(soap, tag, id, (const struct ns2__WhiteBalanceOptions20 *)ptr, "ns2:WhiteBalanceOptions20");
	case SOAP_TYPE_ns2__WideDynamicRangeOptions20:
		return soap_out_ns2__WideDynamicRangeOptions20(soap, tag, id, (const struct ns2__WideDynamicRangeOptions20 *)ptr, "ns2:WideDynamicRangeOptions20");
	case SOAP_TYPE_ns2__FocusOptions20:
		return soap_out_ns2__FocusOptions20(soap, tag, id, (const struct ns2__FocusOptions20 *)ptr, "ns2:FocusOptions20");
	case SOAP_TYPE_ns2__ExposureOptions20:
		return soap_out_ns2__ExposureOptions20(soap, tag, id, (const struct ns2__ExposureOptions20 *)ptr, "ns2:ExposureOptions20");
	case SOAP_TYPE_ns2__BacklightCompensationOptions20:
		return soap_out_ns2__BacklightCompensationOptions20(soap, tag, id, (const struct ns2__BacklightCompensationOptions20 *)ptr, "ns2:BacklightCompensationOptions20");
	case SOAP_TYPE_ns2__ImagingOptions20:
		return soap_out_ns2__ImagingOptions20(soap, tag, id, (const struct ns2__ImagingOptions20 *)ptr, "ns2:ImagingOptions20");
	case SOAP_TYPE_ns2__ImagingSettingsExtension20:
		return soap_out_ns2__ImagingSettingsExtension20(soap, tag, id, (const struct ns2__ImagingSettingsExtension20 *)ptr, "ns2:ImagingSettingsExtension20");
	case SOAP_TYPE_ns2__WhiteBalance20:
		return soap_out_ns2__WhiteBalance20(soap, tag, id, (const struct ns2__WhiteBalance20 *)ptr, "ns2:WhiteBalance20");
	case SOAP_TYPE_ns2__WideDynamicRange20:
		return soap_out_ns2__WideDynamicRange20(soap, tag, id, (const struct ns2__WideDynamicRange20 *)ptr, "ns2:WideDynamicRange20");
	case SOAP_TYPE_ns2__FocusConfiguration20:
		return soap_out_ns2__FocusConfiguration20(soap, tag, id, (const struct ns2__FocusConfiguration20 *)ptr, "ns2:FocusConfiguration20");
	case SOAP_TYPE_ns2__Exposure20:
		return soap_out_ns2__Exposure20(soap, tag, id, (const struct ns2__Exposure20 *)ptr, "ns2:Exposure20");
	case SOAP_TYPE_ns2__BacklightCompensation20:
		return soap_out_ns2__BacklightCompensation20(soap, tag, id, (const struct ns2__BacklightCompensation20 *)ptr, "ns2:BacklightCompensation20");
	case SOAP_TYPE_ns2__ImagingSettings20:
		return soap_out_ns2__ImagingSettings20(soap, tag, id, (const struct ns2__ImagingSettings20 *)ptr, "ns2:ImagingSettings20");
	case SOAP_TYPE_ns2__FocusStatus20Extension:
		return soap_out_ns2__FocusStatus20Extension(soap, tag, id, (const struct ns2__FocusStatus20Extension *)ptr, "ns2:FocusStatus20Extension");
	case SOAP_TYPE_ns2__ImagingStatus20Extension:
		return soap_out_ns2__ImagingStatus20Extension(soap, tag, id, (const struct ns2__ImagingStatus20Extension *)ptr, "ns2:ImagingStatus20Extension");
	case SOAP_TYPE_ns2__FocusStatus20:
		return soap_out_ns2__FocusStatus20(soap, tag, id, (const struct ns2__FocusStatus20 *)ptr, "ns2:FocusStatus20");
	case SOAP_TYPE_ns2__ImagingStatus20:
		return soap_out_ns2__ImagingStatus20(soap, tag, id, (const struct ns2__ImagingStatus20 *)ptr, "ns2:ImagingStatus20");
	case SOAP_TYPE_ns2__ContinuousFocusOptions:
		return soap_out_ns2__ContinuousFocusOptions(soap, tag, id, (const struct ns2__ContinuousFocusOptions *)ptr, "ns2:ContinuousFocusOptions");
	case SOAP_TYPE_ns2__RelativeFocusOptions:
		return soap_out_ns2__RelativeFocusOptions(soap, tag, id, (const struct ns2__RelativeFocusOptions *)ptr, "ns2:RelativeFocusOptions");
	case SOAP_TYPE_ns2__AbsoluteFocusOptions:
		return soap_out_ns2__AbsoluteFocusOptions(soap, tag, id, (const struct ns2__AbsoluteFocusOptions *)ptr, "ns2:AbsoluteFocusOptions");
	case SOAP_TYPE_ns2__MoveOptions:
		return soap_out_ns2__MoveOptions(soap, tag, id, (const struct ns2__MoveOptions *)ptr, "ns2:MoveOptions");
	case SOAP_TYPE_ns2__ContinuousFocus:
		return soap_out_ns2__ContinuousFocus(soap, tag, id, (const struct ns2__ContinuousFocus *)ptr, "ns2:ContinuousFocus");
	case SOAP_TYPE_ns2__RelativeFocus:
		return soap_out_ns2__RelativeFocus(soap, tag, id, (const struct ns2__RelativeFocus *)ptr, "ns2:RelativeFocus");
	case SOAP_TYPE_ns2__AbsoluteFocus:
		return soap_out_ns2__AbsoluteFocus(soap, tag, id, (const struct ns2__AbsoluteFocus *)ptr, "ns2:AbsoluteFocus");
	case SOAP_TYPE_ns2__FocusMove:
		return soap_out_ns2__FocusMove(soap, tag, id, (const struct ns2__FocusMove *)ptr, "ns2:FocusMove");
	case SOAP_TYPE_ns2__WhiteBalanceOptions:
		return soap_out_ns2__WhiteBalanceOptions(soap, tag, id, (const struct ns2__WhiteBalanceOptions *)ptr, "ns2:WhiteBalanceOptions");
	case SOAP_TYPE_ns2__WideDynamicRangeOptions:
		return soap_out_ns2__WideDynamicRangeOptions(soap, tag, id, (const struct ns2__WideDynamicRangeOptions *)ptr, "ns2:WideDynamicRangeOptions");
	case SOAP_TYPE_ns2__FocusOptions:
		return soap_out_ns2__FocusOptions(soap, tag, id, (const struct ns2__FocusOptions *)ptr, "ns2:FocusOptions");
	case SOAP_TYPE_ns2__ExposureOptions:
		return soap_out_ns2__ExposureOptions(soap, tag, id, (const struct ns2__ExposureOptions *)ptr, "ns2:ExposureOptions");
	case SOAP_TYPE_ns2__BacklightCompensationOptions:
		return soap_out_ns2__BacklightCompensationOptions(soap, tag, id, (const struct ns2__BacklightCompensationOptions *)ptr, "ns2:BacklightCompensationOptions");
	case SOAP_TYPE_ns2__ImagingOptions:
		return soap_out_ns2__ImagingOptions(soap, tag, id, (const struct ns2__ImagingOptions *)ptr, "ns2:ImagingOptions");
	case SOAP_TYPE_ns2__Rectangle:
		return soap_out_ns2__Rectangle(soap, tag, id, (const struct ns2__Rectangle *)ptr, "ns2:Rectangle");
	case SOAP_TYPE_ns2__ImagingSettingsExtension:
		return soap_out_ns2__ImagingSettingsExtension(soap, tag, id, (const struct ns2__ImagingSettingsExtension *)ptr, "ns2:ImagingSettingsExtension");
	case SOAP_TYPE_ns2__WhiteBalance:
		return soap_out_ns2__WhiteBalance(soap, tag, id, (const struct ns2__WhiteBalance *)ptr, "ns2:WhiteBalance");
	case SOAP_TYPE_ns2__WideDynamicRange:
		return soap_out_ns2__WideDynamicRange(soap, tag, id, (const struct ns2__WideDynamicRange *)ptr, "ns2:WideDynamicRange");
	case SOAP_TYPE_ns2__Exposure:
		return soap_out_ns2__Exposure(soap, tag, id, (const struct ns2__Exposure *)ptr, "ns2:Exposure");
	case SOAP_TYPE_ns2__BacklightCompensation:
		return soap_out_ns2__BacklightCompensation(soap, tag, id, (const struct ns2__BacklightCompensation *)ptr, "ns2:BacklightCompensation");
	case SOAP_TYPE_ns2__ImagingSettings:
		return soap_out_ns2__ImagingSettings(soap, tag, id, (const struct ns2__ImagingSettings *)ptr, "ns2:ImagingSettings");
	case SOAP_TYPE_ns2__FocusConfiguration:
		return soap_out_ns2__FocusConfiguration(soap, tag, id, (const struct ns2__FocusConfiguration *)ptr, "ns2:FocusConfiguration");
	case SOAP_TYPE_ns2__FocusStatus:
		return soap_out_ns2__FocusStatus(soap, tag, id, (const struct ns2__FocusStatus *)ptr, "ns2:FocusStatus");
	case SOAP_TYPE_ns2__ImagingStatus:
		return soap_out_ns2__ImagingStatus(soap, tag, id, (const struct ns2__ImagingStatus *)ptr, "ns2:ImagingStatus");
	case SOAP_TYPE_ns2__PTZPreset:
		return soap_out_ns2__PTZPreset(soap, tag, id, (const struct ns2__PTZPreset *)ptr, "ns2:PTZPreset");
	case SOAP_TYPE_ns2__PTZMoveStatus:
		return soap_out_ns2__PTZMoveStatus(soap, tag, id, (const struct ns2__PTZMoveStatus *)ptr, "ns2:PTZMoveStatus");
	case SOAP_TYPE_ns2__PTZStatus:
		return soap_out_ns2__PTZStatus(soap, tag, id, (const struct ns2__PTZStatus *)ptr, "ns2:PTZStatus");
	case SOAP_TYPE_ns2__PTZSpeed:
		return soap_out_ns2__PTZSpeed(soap, tag, id, (const struct ns2__PTZSpeed *)ptr, "ns2:PTZSpeed");
	case SOAP_TYPE_ns2__PTZVector:
		return soap_out_ns2__PTZVector(soap, tag, id, (const struct ns2__PTZVector *)ptr, "ns2:PTZVector");
	case SOAP_TYPE_ns2__Vector1D:
		return soap_out_ns2__Vector1D(soap, tag, id, (const struct ns2__Vector1D *)ptr, "ns2:Vector1D");
	case SOAP_TYPE_ns2__Vector2D:
		return soap_out_ns2__Vector2D(soap, tag, id, (const struct ns2__Vector2D *)ptr, "ns2:Vector2D");
	case SOAP_TYPE_ns2__PTZSpacesExtension:
		return soap_out_ns2__PTZSpacesExtension(soap, tag, id, (const struct ns2__PTZSpacesExtension *)ptr, "ns2:PTZSpacesExtension");
	case SOAP_TYPE_ns2__Space1DDescription:
		return soap_out_ns2__Space1DDescription(soap, tag, id, (const struct ns2__Space1DDescription *)ptr, "ns2:Space1DDescription");
	case SOAP_TYPE_ns2__ZoomLimits:
		return soap_out_ns2__ZoomLimits(soap, tag, id, (const struct ns2__ZoomLimits *)ptr, "ns2:ZoomLimits");
	case SOAP_TYPE_ns2__Space2DDescription:
		return soap_out_ns2__Space2DDescription(soap, tag, id, (const struct ns2__Space2DDescription *)ptr, "ns2:Space2DDescription");
	case SOAP_TYPE_ns2__PanTiltLimits:
		return soap_out_ns2__PanTiltLimits(soap, tag, id, (const struct ns2__PanTiltLimits *)ptr, "ns2:PanTiltLimits");
	case SOAP_TYPE_ns2__PTZSpaces:
		return soap_out_ns2__PTZSpaces(soap, tag, id, (const struct ns2__PTZSpaces *)ptr, "ns2:PTZSpaces");
	case SOAP_TYPE_ns2__PTZConfigurationOptions:
		return soap_out_ns2__PTZConfigurationOptions(soap, tag, id, (const struct ns2__PTZConfigurationOptions *)ptr, "ns2:PTZConfigurationOptions");
	case SOAP_TYPE_ns2__PTZConfigurationExtension:
		return soap_out_ns2__PTZConfigurationExtension(soap, tag, id, (const struct ns2__PTZConfigurationExtension *)ptr, "ns2:PTZConfigurationExtension");
	case SOAP_TYPE_ns2__PTZNodeExtension:
		return soap_out_ns2__PTZNodeExtension(soap, tag, id, (const struct ns2__PTZNodeExtension *)ptr, "ns2:PTZNodeExtension");
	case SOAP_TYPE_ns2__RelayOutputSettings:
		return soap_out_ns2__RelayOutputSettings(soap, tag, id, (const struct ns2__RelayOutputSettings *)ptr, "ns2:RelayOutputSettings");
	case SOAP_TYPE_ns2__CertificateStatus:
		return soap_out_ns2__CertificateStatus(soap, tag, id, (const struct ns2__CertificateStatus *)ptr, "ns2:CertificateStatus");
	case SOAP_TYPE_ns2__Certificate:
		return soap_out_ns2__Certificate(soap, tag, id, (const struct ns2__Certificate *)ptr, "ns2:Certificate");
	case SOAP_TYPE_ns2__CertificateGenerationParametersExtension:
		return soap_out_ns2__CertificateGenerationParametersExtension(soap, tag, id, (const struct ns2__CertificateGenerationParametersExtension *)ptr, "ns2:CertificateGenerationParametersExtension");
	case SOAP_TYPE_ns2__CertificateGenerationParameters:
		return soap_out_ns2__CertificateGenerationParameters(soap, tag, id, (const struct ns2__CertificateGenerationParameters *)ptr, "ns2:CertificateGenerationParameters");
	case SOAP_TYPE_ns2__Date:
		return soap_out_ns2__Date(soap, tag, id, (const struct ns2__Date *)ptr, "ns2:Date");
	case SOAP_TYPE_ns2__Time:
		return soap_out_ns2__Time(soap, tag, id, (const struct ns2__Time *)ptr, "ns2:Time");
	case SOAP_TYPE_ns2__SystemDateTimeExtension:
		return soap_out_ns2__SystemDateTimeExtension(soap, tag, id, (const struct ns2__SystemDateTimeExtension *)ptr, "ns2:SystemDateTimeExtension");
	case SOAP_TYPE_ns2__DateTime:
		return soap_out_ns2__DateTime(soap, tag, id, (const struct ns2__DateTime *)ptr, "ns2:DateTime");
	case SOAP_TYPE_ns2__TimeZone:
		return soap_out_ns2__TimeZone(soap, tag, id, (const struct ns2__TimeZone *)ptr, "ns2:TimeZone");
	case SOAP_TYPE_ns2__SystemDateTime:
		return soap_out_ns2__SystemDateTime(soap, tag, id, (const struct ns2__SystemDateTime *)ptr, "ns2:SystemDateTime");
	case SOAP_TYPE_ns2__BackupFile:
		return soap_out_ns2__BackupFile(soap, tag, id, (const struct ns2__BackupFile *)ptr, "ns2:BackupFile");
	case SOAP_TYPE_ns2__BinaryData:
		return soap_out_ns2__BinaryData(soap, tag, id, (const struct ns2__BinaryData *)ptr, "ns2:BinaryData");
	case SOAP_TYPE_ns2__SupportInformation:
		return soap_out_ns2__SupportInformation(soap, tag, id, (const struct ns2__SupportInformation *)ptr, "ns2:SupportInformation");
	case SOAP_TYPE_ns2__AttachmentData:
		return soap_out_ns2__AttachmentData(soap, tag, id, (const struct ns2__AttachmentData *)ptr, "ns2:AttachmentData");
	case SOAP_TYPE_ns2__SystemLog:
		return soap_out_ns2__SystemLog(soap, tag, id, (const struct ns2__SystemLog *)ptr, "ns2:SystemLog");
	case SOAP_TYPE_ns2__SystemCapabilitiesExtension:
		return soap_out_ns2__SystemCapabilitiesExtension(soap, tag, id, (const struct ns2__SystemCapabilitiesExtension *)ptr, "ns2:SystemCapabilitiesExtension");
	case SOAP_TYPE_ns2__OnvifVersion:
		return soap_out_ns2__OnvifVersion(soap, tag, id, (const struct ns2__OnvifVersion *)ptr, "ns2:OnvifVersion");
	case SOAP_TYPE_ns2__StorageCapabilities:
		return soap_out_ns2__StorageCapabilities(soap, tag, id, (const struct ns2__StorageCapabilities *)ptr, "ns2:StorageCapabilities");
	case SOAP_TYPE_ns2__SecurityCapabilitiesExtension:
		return soap_out_ns2__SecurityCapabilitiesExtension(soap, tag, id, (const struct ns2__SecurityCapabilitiesExtension *)ptr, "ns2:SecurityCapabilitiesExtension");
	case SOAP_TYPE_ns2__NetworkCapabilitiesExtension:
		return soap_out_ns2__NetworkCapabilitiesExtension(soap, tag, id, (const struct ns2__NetworkCapabilitiesExtension *)ptr, "ns2:NetworkCapabilitiesExtension");
	case SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension:
		return soap_out_ns2__RealTimeStreamingCapabilitiesExtension(soap, tag, id, (const struct ns2__RealTimeStreamingCapabilitiesExtension *)ptr, "ns2:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_ns2__ProfileCapabilities:
		return soap_out_ns2__ProfileCapabilities(soap, tag, id, (const struct ns2__ProfileCapabilities *)ptr, "ns2:ProfileCapabilities");
	case SOAP_TYPE_ns2__MediaCapabilitiesExtension:
		return soap_out_ns2__MediaCapabilitiesExtension(soap, tag, id, (const struct ns2__MediaCapabilitiesExtension *)ptr, "ns2:MediaCapabilitiesExtension");
	case SOAP_TYPE_ns2__RealTimeStreamingCapabilities:
		return soap_out_ns2__RealTimeStreamingCapabilities(soap, tag, id, (const struct ns2__RealTimeStreamingCapabilities *)ptr, "ns2:RealTimeStreamingCapabilities");
	case SOAP_TYPE_ns2__IOCapabilitiesExtension:
		return soap_out_ns2__IOCapabilitiesExtension(soap, tag, id, (const struct ns2__IOCapabilitiesExtension *)ptr, "ns2:IOCapabilitiesExtension");
	case SOAP_TYPE_ns2__DeviceCapabilitiesExtension:
		return soap_out_ns2__DeviceCapabilitiesExtension(soap, tag, id, (const struct ns2__DeviceCapabilitiesExtension *)ptr, "ns2:DeviceCapabilitiesExtension");
	case SOAP_TYPE_ns2__SecurityCapabilities:
		return soap_out_ns2__SecurityCapabilities(soap, tag, id, (const struct ns2__SecurityCapabilities *)ptr, "ns2:SecurityCapabilities");
	case SOAP_TYPE_ns2__IOCapabilities:
		return soap_out_ns2__IOCapabilities(soap, tag, id, (const struct ns2__IOCapabilities *)ptr, "ns2:IOCapabilities");
	case SOAP_TYPE_ns2__SystemCapabilities:
		return soap_out_ns2__SystemCapabilities(soap, tag, id, (const struct ns2__SystemCapabilities *)ptr, "ns2:SystemCapabilities");
	case SOAP_TYPE_ns2__NetworkCapabilities:
		return soap_out_ns2__NetworkCapabilities(soap, tag, id, (const struct ns2__NetworkCapabilities *)ptr, "ns2:NetworkCapabilities");
	case SOAP_TYPE_ns2__CapabilitiesExtension:
		return soap_out_ns2__CapabilitiesExtension(soap, tag, id, (const struct ns2__CapabilitiesExtension *)ptr, "ns2:CapabilitiesExtension");
	case SOAP_TYPE_ns2__PTZCapabilities:
		return soap_out_ns2__PTZCapabilities(soap, tag, id, (const struct ns2__PTZCapabilities *)ptr, "ns2:PTZCapabilities");
	case SOAP_TYPE_ns2__MediaCapabilities:
		return soap_out_ns2__MediaCapabilities(soap, tag, id, (const struct ns2__MediaCapabilities *)ptr, "ns2:MediaCapabilities");
	case SOAP_TYPE_ns2__ImagingCapabilities:
		return soap_out_ns2__ImagingCapabilities(soap, tag, id, (const struct ns2__ImagingCapabilities *)ptr, "ns2:ImagingCapabilities");
	case SOAP_TYPE_ns2__EventCapabilities:
		return soap_out_ns2__EventCapabilities(soap, tag, id, (const struct ns2__EventCapabilities *)ptr, "ns2:EventCapabilities");
	case SOAP_TYPE_ns2__DeviceCapabilities:
		return soap_out_ns2__DeviceCapabilities(soap, tag, id, (const struct ns2__DeviceCapabilities *)ptr, "ns2:DeviceCapabilities");
	case SOAP_TYPE_ns2__AnalyticsCapabilities:
		return soap_out_ns2__AnalyticsCapabilities(soap, tag, id, (const struct ns2__AnalyticsCapabilities *)ptr, "ns2:AnalyticsCapabilities");
	case SOAP_TYPE_ns2__Capabilities:
		return soap_out_ns2__Capabilities(soap, tag, id, (const struct ns2__Capabilities *)ptr, "ns2:Capabilities");
	case SOAP_TYPE_ns2__IPAddressFilterExtension:
		return soap_out_ns2__IPAddressFilterExtension(soap, tag, id, (const struct ns2__IPAddressFilterExtension *)ptr, "ns2:IPAddressFilterExtension");
	case SOAP_TYPE_ns2__IPAddressFilter:
		return soap_out_ns2__IPAddressFilter(soap, tag, id, (const struct ns2__IPAddressFilter *)ptr, "ns2:IPAddressFilter");
	case SOAP_TYPE_ns2__NetworkZeroConfigurationExtension:
		return soap_out_ns2__NetworkZeroConfigurationExtension(soap, tag, id, (const struct ns2__NetworkZeroConfigurationExtension *)ptr, "ns2:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_ns2__NetworkZeroConfiguration:
		return soap_out_ns2__NetworkZeroConfiguration(soap, tag, id, (const struct ns2__NetworkZeroConfiguration *)ptr, "ns2:NetworkZeroConfiguration");
	case SOAP_TYPE_ns2__NetworkGateway:
		return soap_out_ns2__NetworkGateway(soap, tag, id, (const struct ns2__NetworkGateway *)ptr, "ns2:NetworkGateway");
	case SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension:
		return soap_out_ns2__NetworkInterfaceSetConfigurationExtension(soap, tag, id, (const struct ns2__NetworkInterfaceSetConfigurationExtension *)ptr, "ns2:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration:
		return soap_out_ns2__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, (const struct ns2__IPv6NetworkInterfaceSetConfiguration *)ptr, "ns2:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration:
		return soap_out_ns2__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, (const struct ns2__IPv4NetworkInterfaceSetConfiguration *)ptr, "ns2:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration:
		return soap_out_ns2__NetworkInterfaceSetConfiguration(soap, tag, id, (const struct ns2__NetworkInterfaceSetConfiguration *)ptr, "ns2:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_ns2__DynamicDNSInformationExtension:
		return soap_out_ns2__DynamicDNSInformationExtension(soap, tag, id, (const struct ns2__DynamicDNSInformationExtension *)ptr, "ns2:DynamicDNSInformationExtension");
	case SOAP_TYPE_ns2__DynamicDNSInformation:
		return soap_out_ns2__DynamicDNSInformation(soap, tag, id, (const struct ns2__DynamicDNSInformation *)ptr, "ns2:DynamicDNSInformation");
	case SOAP_TYPE_ns2__NTPInformationExtension:
		return soap_out_ns2__NTPInformationExtension(soap, tag, id, (const struct ns2__NTPInformationExtension *)ptr, "ns2:NTPInformationExtension");
	case SOAP_TYPE_ns2__NTPInformation:
		return soap_out_ns2__NTPInformation(soap, tag, id, (const struct ns2__NTPInformation *)ptr, "ns2:NTPInformation");
	case SOAP_TYPE_ns2__DNSInformationExtension:
		return soap_out_ns2__DNSInformationExtension(soap, tag, id, (const struct ns2__DNSInformationExtension *)ptr, "ns2:DNSInformationExtension");
	case SOAP_TYPE_ns2__DNSInformation:
		return soap_out_ns2__DNSInformation(soap, tag, id, (const struct ns2__DNSInformation *)ptr, "ns2:DNSInformation");
	case SOAP_TYPE_ns2__HostnameInformationExtension:
		return soap_out_ns2__HostnameInformationExtension(soap, tag, id, (const struct ns2__HostnameInformationExtension *)ptr, "ns2:HostnameInformationExtension");
	case SOAP_TYPE_ns2__HostnameInformation:
		return soap_out_ns2__HostnameInformation(soap, tag, id, (const struct ns2__HostnameInformation *)ptr, "ns2:HostnameInformation");
	case SOAP_TYPE_ns2__NetworkHostExtension:
		return soap_out_ns2__NetworkHostExtension(soap, tag, id, (const struct ns2__NetworkHostExtension *)ptr, "ns2:NetworkHostExtension");
	case SOAP_TYPE_ns2__NetworkHost:
		return soap_out_ns2__NetworkHost(soap, tag, id, (const struct ns2__NetworkHost *)ptr, "ns2:NetworkHost");
	case SOAP_TYPE_ns2__NetworkProtocolExtension:
		return soap_out_ns2__NetworkProtocolExtension(soap, tag, id, (const struct ns2__NetworkProtocolExtension *)ptr, "ns2:NetworkProtocolExtension");
	case SOAP_TYPE_ns2__NetworkProtocol:
		return soap_out_ns2__NetworkProtocol(soap, tag, id, (const struct ns2__NetworkProtocol *)ptr, "ns2:NetworkProtocol");
	case SOAP_TYPE_ns2__IPv6ConfigurationExtension:
		return soap_out_ns2__IPv6ConfigurationExtension(soap, tag, id, (const struct ns2__IPv6ConfigurationExtension *)ptr, "ns2:IPv6ConfigurationExtension");
	case SOAP_TYPE_ns2__PrefixedIPv6Address:
		return soap_out_ns2__PrefixedIPv6Address(soap, tag, id, (const struct ns2__PrefixedIPv6Address *)ptr, "ns2:PrefixedIPv6Address");
	case SOAP_TYPE_ns2__PrefixedIPv4Address:
		return soap_out_ns2__PrefixedIPv4Address(soap, tag, id, (const struct ns2__PrefixedIPv4Address *)ptr, "ns2:PrefixedIPv4Address");
	case SOAP_TYPE_ns2__IPv4Configuration:
		return soap_out_ns2__IPv4Configuration(soap, tag, id, (const struct ns2__IPv4Configuration *)ptr, "ns2:IPv4Configuration");
	case SOAP_TYPE_ns2__IPv4NetworkInterface:
		return soap_out_ns2__IPv4NetworkInterface(soap, tag, id, (const struct ns2__IPv4NetworkInterface *)ptr, "ns2:IPv4NetworkInterface");
	case SOAP_TYPE_ns2__IPv6Configuration:
		return soap_out_ns2__IPv6Configuration(soap, tag, id, (const struct ns2__IPv6Configuration *)ptr, "ns2:IPv6Configuration");
	case SOAP_TYPE_ns2__IPv6NetworkInterface:
		return soap_out_ns2__IPv6NetworkInterface(soap, tag, id, (const struct ns2__IPv6NetworkInterface *)ptr, "ns2:IPv6NetworkInterface");
	case SOAP_TYPE_ns2__NetworkInterfaceInfo:
		return soap_out_ns2__NetworkInterfaceInfo(soap, tag, id, (const struct ns2__NetworkInterfaceInfo *)ptr, "ns2:NetworkInterfaceInfo");
	case SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting:
		return soap_out_ns2__NetworkInterfaceConnectionSetting(soap, tag, id, (const struct ns2__NetworkInterfaceConnectionSetting *)ptr, "ns2:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_ns2__NetworkInterfaceLink:
		return soap_out_ns2__NetworkInterfaceLink(soap, tag, id, (const struct ns2__NetworkInterfaceLink *)ptr, "ns2:NetworkInterfaceLink");
	case SOAP_TYPE_ns2__NetworkInterfaceExtension:
		return soap_out_ns2__NetworkInterfaceExtension(soap, tag, id, (const struct ns2__NetworkInterfaceExtension *)ptr, "ns2:NetworkInterfaceExtension");
	case SOAP_TYPE_ns2__Scope:
		return soap_out_ns2__Scope(soap, tag, id, (const struct ns2__Scope *)ptr, "ns2:Scope");
	case SOAP_TYPE_ns2__Transport:
		return soap_out_ns2__Transport(soap, tag, id, (const struct ns2__Transport *)ptr, "ns2:Transport");
	case SOAP_TYPE_ns2__IPAddress:
		return soap_out_ns2__IPAddress(soap, tag, id, (const struct ns2__IPAddress *)ptr, "ns2:IPAddress");
	case SOAP_TYPE_ns2__MulticastConfiguration:
		return soap_out_ns2__MulticastConfiguration(soap, tag, id, (const struct ns2__MulticastConfiguration *)ptr, "ns2:MulticastConfiguration");
	case SOAP_TYPE_ns2__PTZStatusFilterOptions:
		return soap_out_ns2__PTZStatusFilterOptions(soap, tag, id, (const struct ns2__PTZStatusFilterOptions *)ptr, "ns2:PTZStatusFilterOptions");
	case SOAP_TYPE_ns2__MetadataConfigurationOptions:
		return soap_out_ns2__MetadataConfigurationOptions(soap, tag, id, (const struct ns2__MetadataConfigurationOptions *)ptr, "ns2:MetadataConfigurationOptions");
	case SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy:
		return soap_out__ns2__EventSubscription_SubscriptionPolicy(soap, "ns2:EventSubscription-SubscriptionPolicy", id, (const struct _ns2__EventSubscription_SubscriptionPolicy *)ptr, NULL);
	case SOAP_TYPE_ns2__FilterType:
		return soap_out_ns2__FilterType(soap, tag, id, (const struct ns2__FilterType *)ptr, "ns2:FilterType");
	case SOAP_TYPE_ns2__EventSubscription:
		return soap_out_ns2__EventSubscription(soap, tag, id, (const struct ns2__EventSubscription *)ptr, "ns2:EventSubscription");
	case SOAP_TYPE_ns2__PTZFilter:
		return soap_out_ns2__PTZFilter(soap, tag, id, (const struct ns2__PTZFilter *)ptr, "ns2:PTZFilter");
	case SOAP_TYPE_ns2__AudioEncoderConfigurationOption:
		return soap_out_ns2__AudioEncoderConfigurationOption(soap, tag, id, (const struct ns2__AudioEncoderConfigurationOption *)ptr, "ns2:AudioEncoderConfigurationOption");
	case SOAP_TYPE_ns2__AudioEncoderConfigurationOptions:
		return soap_out_ns2__AudioEncoderConfigurationOptions(soap, tag, id, (const struct ns2__AudioEncoderConfigurationOptions *)ptr, "ns2:AudioEncoderConfigurationOptions");
	case SOAP_TYPE_ns2__AudioSourceOptionsExtension:
		return soap_out_ns2__AudioSourceOptionsExtension(soap, tag, id, (const struct ns2__AudioSourceOptionsExtension *)ptr, "ns2:AudioSourceOptionsExtension");
	case SOAP_TYPE_ns2__AudioSourceConfigurationOptions:
		return soap_out_ns2__AudioSourceConfigurationOptions(soap, tag, id, (const struct ns2__AudioSourceConfigurationOptions *)ptr, "ns2:AudioSourceConfigurationOptions");
	case SOAP_TYPE_ns2__VideoEncoderOptionsExtension:
		return soap_out_ns2__VideoEncoderOptionsExtension(soap, tag, id, (const struct ns2__VideoEncoderOptionsExtension *)ptr, "ns2:VideoEncoderOptionsExtension");
	case SOAP_TYPE_ns2__H264Options:
		return soap_out_ns2__H264Options(soap, tag, id, (const struct ns2__H264Options *)ptr, "ns2:H264Options");
	case SOAP_TYPE_ns2__Mpeg4Options:
		return soap_out_ns2__Mpeg4Options(soap, tag, id, (const struct ns2__Mpeg4Options *)ptr, "ns2:Mpeg4Options");
	case SOAP_TYPE_ns2__JpegOptions:
		return soap_out_ns2__JpegOptions(soap, tag, id, (const struct ns2__JpegOptions *)ptr, "ns2:JpegOptions");
	case SOAP_TYPE_ns2__H264Configuration:
		return soap_out_ns2__H264Configuration(soap, tag, id, (const struct ns2__H264Configuration *)ptr, "ns2:H264Configuration");
	case SOAP_TYPE_ns2__Mpeg4Configuration:
		return soap_out_ns2__Mpeg4Configuration(soap, tag, id, (const struct ns2__Mpeg4Configuration *)ptr, "ns2:Mpeg4Configuration");
	case SOAP_TYPE_ns2__VideoRateControl:
		return soap_out_ns2__VideoRateControl(soap, tag, id, (const struct ns2__VideoRateControl *)ptr, "ns2:VideoRateControl");
	case SOAP_TYPE_ns2__VideoResolution:
		return soap_out_ns2__VideoResolution(soap, tag, id, (const struct ns2__VideoResolution *)ptr, "ns2:VideoResolution");
	case SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension:
		return soap_out_ns2__VideoSourceConfigurationOptionsExtension(soap, tag, id, (const struct ns2__VideoSourceConfigurationOptionsExtension *)ptr, "ns2:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_ns2__VideoSourceConfigurationOptions:
		return soap_out_ns2__VideoSourceConfigurationOptions(soap, tag, id, (const struct ns2__VideoSourceConfigurationOptions *)ptr, "ns2:VideoSourceConfigurationOptions");
	case SOAP_TYPE_ns2__ConfigurationEntity:
		return soap_out_ns2__ConfigurationEntity(soap, tag, id, (const struct ns2__ConfigurationEntity *)ptr, "ns2:ConfigurationEntity");
	case SOAP_TYPE_ns2__ProfileExtension:
		return soap_out_ns2__ProfileExtension(soap, tag, id, (const struct ns2__ProfileExtension *)ptr, "ns2:ProfileExtension");
	case SOAP_TYPE_ns2__MetadataConfiguration:
		return soap_out_ns2__MetadataConfiguration(soap, tag, id, (const struct ns2__MetadataConfiguration *)ptr, "ns2:MetadataConfiguration");
	case SOAP_TYPE_ns2__PTZConfiguration:
		return soap_out_ns2__PTZConfiguration(soap, tag, id, (const struct ns2__PTZConfiguration *)ptr, "ns2:PTZConfiguration");
	case SOAP_TYPE_ns2__VideoAnalyticsConfiguration:
		return soap_out_ns2__VideoAnalyticsConfiguration(soap, tag, id, (const struct ns2__VideoAnalyticsConfiguration *)ptr, "ns2:VideoAnalyticsConfiguration");
	case SOAP_TYPE_ns2__AudioEncoderConfiguration:
		return soap_out_ns2__AudioEncoderConfiguration(soap, tag, id, (const struct ns2__AudioEncoderConfiguration *)ptr, "ns2:AudioEncoderConfiguration");
	case SOAP_TYPE_ns2__AudioSourceConfiguration:
		return soap_out_ns2__AudioSourceConfiguration(soap, tag, id, (const struct ns2__AudioSourceConfiguration *)ptr, "ns2:AudioSourceConfiguration");
	case SOAP_TYPE_ns2__VideoSourceConfiguration:
		return soap_out_ns2__VideoSourceConfiguration(soap, tag, id, (const struct ns2__VideoSourceConfiguration *)ptr, "ns2:VideoSourceConfiguration");
	case SOAP_TYPE_ns2__VideoSourceExtension:
		return soap_out_ns2__VideoSourceExtension(soap, tag, id, (const struct ns2__VideoSourceExtension *)ptr, "ns2:VideoSourceExtension");
	case SOAP_TYPE_ns2__IntList:
		return soap_out_ns2__IntList(soap, tag, id, (const struct ns2__IntList *)ptr, "ns2:IntList");
	case SOAP_TYPE_ns2__DurationRange:
		return soap_out_ns2__DurationRange(soap, tag, id, (const struct ns2__DurationRange *)ptr, "ns2:DurationRange");
	case SOAP_TYPE_ns2__FloatRange:
		return soap_out_ns2__FloatRange(soap, tag, id, (const struct ns2__FloatRange *)ptr, "ns2:FloatRange");
	case SOAP_TYPE_ns2__IntRange:
		return soap_out_ns2__IntRange(soap, tag, id, (const struct ns2__IntRange *)ptr, "ns2:IntRange");
	case SOAP_TYPE_ns2__IntRectangleRange:
		return soap_out_ns2__IntRectangleRange(soap, tag, id, (const struct ns2__IntRectangleRange *)ptr, "ns2:IntRectangleRange");
	case SOAP_TYPE_ns2__IntRectangle:
		return soap_out_ns2__IntRectangle(soap, tag, id, (const struct ns2__IntRectangle *)ptr, "ns2:IntRectangle");
	case SOAP_TYPE_ns2__DeviceEntity:
		return soap_out_ns2__DeviceEntity(soap, tag, id, (const struct ns2__DeviceEntity *)ptr, "ns2:DeviceEntity");
	case SOAP_TYPE_ns2__UserExtension:
		return soap_out_ns2__UserExtension(soap, tag, id, (const struct ns2__UserExtension *)ptr, "ns2:UserExtension");
	case SOAP_TYPE_ns2__User:
		return soap_out_ns2__User(soap, tag, id, (const struct ns2__User *)ptr, "ns2:User");
	case SOAP_TYPE__ns1__GetSnapshotUriResponse:
		return soap_out__ns1__GetSnapshotUriResponse(soap, "ns1:GetSnapshotUriResponse", id, (const struct _ns1__GetSnapshotUriResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetSnapshotUri:
		return soap_out__ns1__GetSnapshotUri(soap, "ns1:GetSnapshotUri", id, (const struct _ns1__GetSnapshotUri *)ptr, NULL);
	case SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse:
		return soap_out__ns1__SetVideoEncoderConfigurationResponse(soap, "ns1:SetVideoEncoderConfigurationResponse", id, (const struct _ns1__SetVideoEncoderConfigurationResponse *)ptr, NULL);
	case SOAP_TYPE_ns2__VideoEncoderConfiguration:
		return soap_out_ns2__VideoEncoderConfiguration(soap, tag, id, (const struct ns2__VideoEncoderConfiguration *)ptr, "ns2:VideoEncoderConfiguration");
	case SOAP_TYPE__ns1__SetVideoEncoderConfiguration:
		return soap_out__ns1__SetVideoEncoderConfiguration(soap, "ns1:SetVideoEncoderConfiguration", id, (const struct _ns1__SetVideoEncoderConfiguration *)ptr, NULL);
	case SOAP_TYPE_ns2__VideoEncoderConfigurationOptions:
		return soap_out_ns2__VideoEncoderConfigurationOptions(soap, tag, id, (const struct ns2__VideoEncoderConfigurationOptions *)ptr, "ns2:VideoEncoderConfigurationOptions");
	case SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse:
		return soap_out__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, "ns1:GetVideoEncoderConfigurationOptionsResponse", id, (const struct _ns1__GetVideoEncoderConfigurationOptionsResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions:
		return soap_out__ns1__GetVideoEncoderConfigurationOptions(soap, "ns1:GetVideoEncoderConfigurationOptions", id, (const struct _ns1__GetVideoEncoderConfigurationOptions *)ptr, NULL);
	case SOAP_TYPE_ns2__MediaUri:
		return soap_out_ns2__MediaUri(soap, tag, id, (const struct ns2__MediaUri *)ptr, "ns2:MediaUri");
	case SOAP_TYPE__ns1__GetStreamUriResponse:
		return soap_out__ns1__GetStreamUriResponse(soap, "ns1:GetStreamUriResponse", id, (const struct _ns1__GetStreamUriResponse *)ptr, NULL);
	case SOAP_TYPE_ns2__StreamSetup:
		return soap_out_ns2__StreamSetup(soap, tag, id, (const struct ns2__StreamSetup *)ptr, "ns2:StreamSetup");
	case SOAP_TYPE__ns1__GetStreamUri:
		return soap_out__ns1__GetStreamUri(soap, "ns1:GetStreamUri", id, (const struct _ns1__GetStreamUri *)ptr, NULL);
	case SOAP_TYPE_ns2__Profile:
		return soap_out_ns2__Profile(soap, tag, id, (const struct ns2__Profile *)ptr, "ns2:Profile");
	case SOAP_TYPE__ns1__GetProfilesResponse:
		return soap_out__ns1__GetProfilesResponse(soap, "ns1:GetProfilesResponse", id, (const struct _ns1__GetProfilesResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetProfiles:
		return soap_out__ns1__GetProfiles(soap, "ns1:GetProfiles", id, (const struct _ns1__GetProfiles *)ptr, NULL);
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, NULL);
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE__xenc__ReferenceList:
		return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, NULL);
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE__ds__KeyInfo:
		return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, NULL);
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE__ds__Transform:
		return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, NULL);
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE__ds__Signature:
		return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, NULL);
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE_PointerTo_ns1__GetSnapshotUriResponse:
		return soap_out_PointerTo_ns1__GetSnapshotUriResponse(soap, tag, id, (struct _ns1__GetSnapshotUriResponse *const*)ptr, "ns1:GetSnapshotUriResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSnapshotUri:
		return soap_out_PointerTo_ns1__GetSnapshotUri(soap, tag, id, (struct _ns1__GetSnapshotUri *const*)ptr, "ns1:GetSnapshotUri");
	case SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfigurationResponse:
		return soap_out_PointerTo_ns1__SetVideoEncoderConfigurationResponse(soap, tag, id, (struct _ns1__SetVideoEncoderConfigurationResponse *const*)ptr, "ns1:SetVideoEncoderConfigurationResponse");
	case SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfiguration:
		return soap_out_PointerTo_ns1__SetVideoEncoderConfiguration(soap, tag, id, (struct _ns1__SetVideoEncoderConfiguration *const*)ptr, "ns1:SetVideoEncoderConfiguration");
	case SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse:
		return soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag, id, (struct _ns1__GetVideoEncoderConfigurationOptionsResponse *const*)ptr, "ns1:GetVideoEncoderConfigurationOptionsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptions:
		return soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, tag, id, (struct _ns1__GetVideoEncoderConfigurationOptions *const*)ptr, "ns1:GetVideoEncoderConfigurationOptions");
	case SOAP_TYPE_PointerTo_ns1__GetStreamUriResponse:
		return soap_out_PointerTo_ns1__GetStreamUriResponse(soap, tag, id, (struct _ns1__GetStreamUriResponse *const*)ptr, "ns1:GetStreamUriResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStreamUri:
		return soap_out_PointerTo_ns1__GetStreamUri(soap, tag, id, (struct _ns1__GetStreamUri *const*)ptr, "ns1:GetStreamUri");
	case SOAP_TYPE_PointerTo_ns1__GetProfilesResponse:
		return soap_out_PointerTo_ns1__GetProfilesResponse(soap, tag, id, (struct _ns1__GetProfilesResponse *const*)ptr, "ns1:GetProfilesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProfiles:
		return soap_out_PointerTo_ns1__GetProfiles(soap, tag, id, (struct _ns1__GetProfiles *const*)ptr, "ns1:GetProfiles");
	case SOAP_TYPE_PointerTons2__ObjectExtension:
		return soap_out_PointerTons2__ObjectExtension(soap, tag, id, (struct ns2__ObjectExtension *const*)ptr, "ns2:ObjectExtension");
	case SOAP_TYPE_PointerTons2__Behaviour:
		return soap_out_PointerTons2__Behaviour(soap, tag, id, (struct ns2__Behaviour *const*)ptr, "ns2:Behaviour");
	case SOAP_TYPE_PointerTons2__Appearance:
		return soap_out_PointerTons2__Appearance(soap, tag, id, (struct ns2__Appearance *const*)ptr, "ns2:Appearance");
	case SOAP_TYPE_PointerTons2__PTZConfigurationExtension:
		return soap_out_PointerTons2__PTZConfigurationExtension(soap, tag, id, (struct ns2__PTZConfigurationExtension *const*)ptr, "ns2:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTons2__ZoomLimits:
		return soap_out_PointerTons2__ZoomLimits(soap, tag, id, (struct ns2__ZoomLimits *const*)ptr, "ns2:ZoomLimits");
	case SOAP_TYPE_PointerTons2__PanTiltLimits:
		return soap_out_PointerTons2__PanTiltLimits(soap, tag, id, (struct ns2__PanTiltLimits *const*)ptr, "ns2:PanTiltLimits");
	case SOAP_TYPE_PointerTons2__PTZSpeed:
		return soap_out_PointerTons2__PTZSpeed(soap, tag, id, (struct ns2__PTZSpeed *const*)ptr, "ns2:PTZSpeed");
	case SOAP_TYPE_PointerTons2__PTZNodeExtension:
		return soap_out_PointerTons2__PTZNodeExtension(soap, tag, id, (struct ns2__PTZNodeExtension *const*)ptr, "ns2:PTZNodeExtension");
	case SOAP_TYPE_PointerTons2__AuxiliaryData:
		return soap_out_PointerTons2__AuxiliaryData(soap, tag, id, (char **const*)ptr, "ns2:AuxiliaryData");
	case SOAP_TYPE_PointerTons2__RelayOutputSettings:
		return soap_out_PointerTons2__RelayOutputSettings(soap, tag, id, (struct ns2__RelayOutputSettings *const*)ptr, "ns2:RelayOutputSettings");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceExtension:
		return soap_out_PointerTons2__NetworkInterfaceExtension(soap, tag, id, (struct ns2__NetworkInterfaceExtension *const*)ptr, "ns2:NetworkInterfaceExtension");
	case SOAP_TYPE_PointerTons2__IPv6NetworkInterface:
		return soap_out_PointerTons2__IPv6NetworkInterface(soap, tag, id, (struct ns2__IPv6NetworkInterface *const*)ptr, "ns2:IPv6NetworkInterface");
	case SOAP_TYPE_PointerTons2__IPv4NetworkInterface:
		return soap_out_PointerTons2__IPv4NetworkInterface(soap, tag, id, (struct ns2__IPv4NetworkInterface *const*)ptr, "ns2:IPv4NetworkInterface");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceLink:
		return soap_out_PointerTons2__NetworkInterfaceLink(soap, tag, id, (struct ns2__NetworkInterfaceLink *const*)ptr, "ns2:NetworkInterfaceLink");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceInfo:
		return soap_out_PointerTons2__NetworkInterfaceInfo(soap, tag, id, (struct ns2__NetworkInterfaceInfo *const*)ptr, "ns2:NetworkInterfaceInfo");
	case SOAP_TYPE_PointerTons2__EventSubscription:
		return soap_out_PointerTons2__EventSubscription(soap, tag, id, (struct ns2__EventSubscription *const*)ptr, "ns2:EventSubscription");
	case SOAP_TYPE_PointerTons2__PTZFilter:
		return soap_out_PointerTons2__PTZFilter(soap, tag, id, (struct ns2__PTZFilter *const*)ptr, "ns2:PTZFilter");
	case SOAP_TYPE_PointerTons2__RuleEngineConfiguration:
		return soap_out_PointerTons2__RuleEngineConfiguration(soap, tag, id, (struct ns2__RuleEngineConfiguration *const*)ptr, "ns2:RuleEngineConfiguration");
	case SOAP_TYPE_PointerTons2__AnalyticsEngineConfiguration:
		return soap_out_PointerTons2__AnalyticsEngineConfiguration(soap, tag, id, (struct ns2__AnalyticsEngineConfiguration *const*)ptr, "ns2:AnalyticsEngineConfiguration");
	case SOAP_TYPE_PointerTons2__MulticastConfiguration:
		return soap_out_PointerTons2__MulticastConfiguration(soap, tag, id, (struct ns2__MulticastConfiguration *const*)ptr, "ns2:MulticastConfiguration");
	case SOAP_TYPE_PointerTons2__H264Configuration:
		return soap_out_PointerTons2__H264Configuration(soap, tag, id, (struct ns2__H264Configuration *const*)ptr, "ns2:H264Configuration");
	case SOAP_TYPE_PointerTons2__Mpeg4Configuration:
		return soap_out_PointerTons2__Mpeg4Configuration(soap, tag, id, (struct ns2__Mpeg4Configuration *const*)ptr, "ns2:Mpeg4Configuration");
	case SOAP_TYPE_PointerTons2__VideoRateControl:
		return soap_out_PointerTons2__VideoRateControl(soap, tag, id, (struct ns2__VideoRateControl *const*)ptr, "ns2:VideoRateControl");
	case SOAP_TYPE_PointerTons2__IntRectangle:
		return soap_out_PointerTons2__IntRectangle(soap, tag, id, (struct ns2__IntRectangle *const*)ptr, "ns2:IntRectangle");
	case SOAP_TYPE_PointerTons2__VideoSourceExtension:
		return soap_out_PointerTons2__VideoSourceExtension(soap, tag, id, (struct ns2__VideoSourceExtension *const*)ptr, "ns2:VideoSourceExtension");
	case SOAP_TYPE_PointerTons2__ImagingSettings:
		return soap_out_PointerTons2__ImagingSettings(soap, tag, id, (struct ns2__ImagingSettings *const*)ptr, "ns2:ImagingSettings");
	case SOAP_TYPE_PointerTons2__PropertyOperation:
		return soap_out_PointerTons2__PropertyOperation(soap, tag, id, (enum ns2__PropertyOperation *const*)ptr, "ns2:PropertyOperation");
	case SOAP_TYPE_PointerTons2__MessageExtension:
		return soap_out_PointerTons2__MessageExtension(soap, tag, id, (struct ns2__MessageExtension *const*)ptr, "ns2:MessageExtension");
	case SOAP_TYPE_PointerTons2__MetadataType:
		return soap_out_PointerTons2__MetadataType(soap, tag, id, (struct ns2__MetadataType *const*)ptr, "ns2:MetadataType");
	case SOAP_TYPE_PointerTons2__ReferenceParametersType:
		return soap_out_PointerTons2__ReferenceParametersType(soap, tag, id, (struct ns2__ReferenceParametersType *const*)ptr, "ns2:ReferenceParametersType");
	case SOAP_TYPE_PointerTons2__AttributedURIType:
		return soap_out_PointerTons2__AttributedURIType(soap, tag, id, (struct ns2__AttributedURIType *const*)ptr, "ns2:AttributedURIType");
	case SOAP_TYPE_PointerTons2__TopicExpressionType:
		return soap_out_PointerTons2__TopicExpressionType(soap, tag, id, (struct ns2__TopicExpressionType *const*)ptr, "ns2:TopicExpressionType");
	case SOAP_TYPE_PointerTons2__EndpointReferenceType:
		return soap_out_PointerTons2__EndpointReferenceType(soap, tag, id, (struct ns2__EndpointReferenceType *const*)ptr, "ns2:EndpointReferenceType");
	case SOAP_TYPE_PointerTons2__EventStreamExtension:
		return soap_out_PointerTons2__EventStreamExtension(soap, tag, id, (struct ns2__EventStreamExtension *const*)ptr, "ns2:EventStreamExtension");
	case SOAP_TYPE_PointerTons2__NotificationMessageHolderType:
		return soap_out_PointerTons2__NotificationMessageHolderType(soap, tag, id, (struct ns2__NotificationMessageHolderType *const*)ptr, "ns2:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTons2__PTZStreamExtension:
		return soap_out_PointerTons2__PTZStreamExtension(soap, tag, id, (struct ns2__PTZStreamExtension *const*)ptr, "ns2:PTZStreamExtension");
	case SOAP_TYPE_PointerTons2__VideoAnalyticsStreamExtension:
		return soap_out_PointerTons2__VideoAnalyticsStreamExtension(soap, tag, id, (struct ns2__VideoAnalyticsStreamExtension *const*)ptr, "ns2:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_PointerTons2__Frame:
		return soap_out_PointerTons2__Frame(soap, tag, id, (struct ns2__Frame *const*)ptr, "ns2:Frame");
	case SOAP_TYPE_PointerTons2__MetadataStreamExtension:
		return soap_out_PointerTons2__MetadataStreamExtension(soap, tag, id, (struct ns2__MetadataStreamExtension *const*)ptr, "ns2:MetadataStreamExtension");
	case SOAP_TYPE_PointerTons2__EventStream:
		return soap_out_PointerTons2__EventStream(soap, tag, id, (struct ns2__EventStream *const*)ptr, "ns2:EventStream");
	case SOAP_TYPE_PointerTons2__PTZStream:
		return soap_out_PointerTons2__PTZStream(soap, tag, id, (struct ns2__PTZStream *const*)ptr, "ns2:PTZStream");
	case SOAP_TYPE_PointerTons2__VideoAnalyticsStream:
		return soap_out_PointerTons2__VideoAnalyticsStream(soap, tag, id, (struct ns2__VideoAnalyticsStream *const*)ptr, "ns2:VideoAnalyticsStream");
	case SOAP_TYPE_PointerTons2__SupportedAnalyticsModulesExtension:
		return soap_out_PointerTons2__SupportedAnalyticsModulesExtension(soap, tag, id, (struct ns2__SupportedAnalyticsModulesExtension *const*)ptr, "ns2:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_PointerTons2__SupportedRulesExtension:
		return soap_out_PointerTons2__SupportedRulesExtension(soap, tag, id, (struct ns2__SupportedRulesExtension *const*)ptr, "ns2:SupportedRulesExtension");
	case SOAP_TYPE_PointerTons2__ConfigDescription:
		return soap_out_PointerTons2__ConfigDescription(soap, tag, id, (struct ns2__ConfigDescription *const*)ptr, "ns2:ConfigDescription");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTons2__ConfigDescriptionExtension:
		return soap_out_PointerTons2__ConfigDescriptionExtension(soap, tag, id, (struct ns2__ConfigDescriptionExtension *const*)ptr, "ns2:ConfigDescriptionExtension");
	case SOAP_TYPE_PointerTo_ns2__ConfigDescription_Messages:
		return soap_out_PointerTo_ns2__ConfigDescription_Messages(soap, tag, id, (struct _ns2__ConfigDescription_Messages *const*)ptr, "ns2:ConfigDescription-Messages");
	case SOAP_TYPE_PointerTons2__ItemList:
		return soap_out_PointerTons2__ItemList(soap, tag, id, (struct ns2__ItemList *const*)ptr, "ns2:ItemList");
	case SOAP_TYPE_PointerTons2__RuleEngineConfigurationExtension:
		return soap_out_PointerTons2__RuleEngineConfigurationExtension(soap, tag, id, (struct ns2__RuleEngineConfigurationExtension *const*)ptr, "ns2:RuleEngineConfigurationExtension");
	case SOAP_TYPE_PointerTons2__AnalyticsEngineConfigurationExtension:
		return soap_out_PointerTons2__AnalyticsEngineConfigurationExtension(soap, tag, id, (struct ns2__AnalyticsEngineConfigurationExtension *const*)ptr, "ns2:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_PointerTons2__Config:
		return soap_out_PointerTons2__Config(soap, tag, id, (struct ns2__Config *const*)ptr, "ns2:Config");
	case SOAP_TYPE_PointerTons2__ObjectTreeExtension:
		return soap_out_PointerTons2__ObjectTreeExtension(soap, tag, id, (struct ns2__ObjectTreeExtension *const*)ptr, "ns2:ObjectTreeExtension");
	case SOAP_TYPE_PointerTons2__Merge:
		return soap_out_PointerTons2__Merge(soap, tag, id, (struct ns2__Merge *const*)ptr, "ns2:Merge");
	case SOAP_TYPE_PointerTons2__Split:
		return soap_out_PointerTons2__Split(soap, tag, id, (struct ns2__Split *const*)ptr, "ns2:Split");
	case SOAP_TYPE_PointerTons2__Rename:
		return soap_out_PointerTons2__Rename(soap, tag, id, (struct ns2__Rename *const*)ptr, "ns2:Rename");
	case SOAP_TYPE_PointerTons2__BehaviourExtension:
		return soap_out_PointerTons2__BehaviourExtension(soap, tag, id, (struct ns2__BehaviourExtension *const*)ptr, "ns2:BehaviourExtension");
	case SOAP_TYPE_PointerTo_ns2__Behaviour_Idle:
		return soap_out_PointerTo_ns2__Behaviour_Idle(soap, tag, id, (struct _ns2__Behaviour_Idle *const*)ptr, "ns2:Behaviour-Idle");
	case SOAP_TYPE_PointerTo_ns2__Behaviour_Removed:
		return soap_out_PointerTo_ns2__Behaviour_Removed(soap, tag, id, (struct _ns2__Behaviour_Removed *const*)ptr, "ns2:Behaviour-Removed");
	case SOAP_TYPE_PointerTons2__ObjectId:
		return soap_out_PointerTons2__ObjectId(soap, tag, id, (struct ns2__ObjectId *const*)ptr, "ns2:ObjectId");
	case SOAP_TYPE_PointerTons2__FrameExtension:
		return soap_out_PointerTons2__FrameExtension(soap, tag, id, (struct ns2__FrameExtension *const*)ptr, "ns2:FrameExtension");
	case SOAP_TYPE_PointerTons2__ObjectTree:
		return soap_out_PointerTons2__ObjectTree(soap, tag, id, (struct ns2__ObjectTree *const*)ptr, "ns2:ObjectTree");
	case SOAP_TYPE_PointerTons2__Object:
		return soap_out_PointerTons2__Object(soap, tag, id, (struct ns2__Object *const*)ptr, "ns2:Object");
	case SOAP_TYPE_PointerTons2__PTZStatus:
		return soap_out_PointerTons2__PTZStatus(soap, tag, id, (struct ns2__PTZStatus *const*)ptr, "ns2:PTZStatus");
	case SOAP_TYPE_PointerTons2__TransformationExtension:
		return soap_out_PointerTons2__TransformationExtension(soap, tag, id, (struct ns2__TransformationExtension *const*)ptr, "ns2:TransformationExtension");
	case SOAP_TYPE_PointerTons2__ClassDescriptorExtension:
		return soap_out_PointerTons2__ClassDescriptorExtension(soap, tag, id, (struct ns2__ClassDescriptorExtension *const*)ptr, "ns2:ClassDescriptorExtension");
	case SOAP_TYPE_PointerTo_ns2__ClassDescriptor_ClassCandidate:
		return soap_out_PointerTo_ns2__ClassDescriptor_ClassCandidate(soap, tag, id, (struct _ns2__ClassDescriptor_ClassCandidate *const*)ptr, "ns2:ClassDescriptor-ClassCandidate");
	case SOAP_TYPE_PointerTons2__ColorDescriptorExtension:
		return soap_out_PointerTons2__ColorDescriptorExtension(soap, tag, id, (struct ns2__ColorDescriptorExtension *const*)ptr, "ns2:ColorDescriptorExtension");
	case SOAP_TYPE_PointerTo_ns2__ColorDescriptor_ColorCluster:
		return soap_out_PointerTo_ns2__ColorDescriptor_ColorCluster(soap, tag, id, (struct _ns2__ColorDescriptor_ColorCluster *const*)ptr, "ns2:ColorDescriptor-ColorCluster");
	case SOAP_TYPE_PointerTons2__ColorCovariance:
		return soap_out_PointerTons2__ColorCovariance(soap, tag, id, (struct ns2__ColorCovariance *const*)ptr, "ns2:ColorCovariance");
	case SOAP_TYPE_PointerTons2__Color:
		return soap_out_PointerTons2__Color(soap, tag, id, (struct ns2__Color *const*)ptr, "ns2:Color");
	case SOAP_TYPE_PointerTons2__ShapeDescriptorExtension:
		return soap_out_PointerTons2__ShapeDescriptorExtension(soap, tag, id, (struct ns2__ShapeDescriptorExtension *const*)ptr, "ns2:ShapeDescriptorExtension");
	case SOAP_TYPE_PointerTons2__Polygon:
		return soap_out_PointerTons2__Polygon(soap, tag, id, (struct ns2__Polygon *const*)ptr, "ns2:Polygon");
	case SOAP_TYPE_PointerTons2__AppearanceExtension:
		return soap_out_PointerTons2__AppearanceExtension(soap, tag, id, (struct ns2__AppearanceExtension *const*)ptr, "ns2:AppearanceExtension");
	case SOAP_TYPE_PointerTons2__ClassDescriptor:
		return soap_out_PointerTons2__ClassDescriptor(soap, tag, id, (struct ns2__ClassDescriptor *const*)ptr, "ns2:ClassDescriptor");
	case SOAP_TYPE_PointerTons2__ColorDescriptor:
		return soap_out_PointerTons2__ColorDescriptor(soap, tag, id, (struct ns2__ColorDescriptor *const*)ptr, "ns2:ColorDescriptor");
	case SOAP_TYPE_PointerTons2__ShapeDescriptor:
		return soap_out_PointerTons2__ShapeDescriptor(soap, tag, id, (struct ns2__ShapeDescriptor *const*)ptr, "ns2:ShapeDescriptor");
	case SOAP_TYPE_PointerTons2__Transformation:
		return soap_out_PointerTons2__Transformation(soap, tag, id, (struct ns2__Transformation *const*)ptr, "ns2:Transformation");
	case SOAP_TYPE_PointerTons2__Vector:
		return soap_out_PointerTons2__Vector(soap, tag, id, (struct ns2__Vector *const*)ptr, "ns2:Vector");
	case SOAP_TYPE_PointerTons2__ItemListDescriptionExtension:
		return soap_out_PointerTons2__ItemListDescriptionExtension(soap, tag, id, (struct ns2__ItemListDescriptionExtension *const*)ptr, "ns2:ItemListDescriptionExtension");
	case SOAP_TYPE_PointerTo_ns2__ItemListDescription_ElementItemDescription:
		return soap_out_PointerTo_ns2__ItemListDescription_ElementItemDescription(soap, tag, id, (struct _ns2__ItemListDescription_ElementItemDescription *const*)ptr, "ns2:ItemListDescription-ElementItemDescription");
	case SOAP_TYPE_PointerTo_ns2__ItemListDescription_SimpleItemDescription:
		return soap_out_PointerTo_ns2__ItemListDescription_SimpleItemDescription(soap, tag, id, (struct _ns2__ItemListDescription_SimpleItemDescription *const*)ptr, "ns2:ItemListDescription-SimpleItemDescription");
	case SOAP_TYPE_PointerTons2__MessageDescriptionExtension:
		return soap_out_PointerTons2__MessageDescriptionExtension(soap, tag, id, (struct ns2__MessageDescriptionExtension *const*)ptr, "ns2:MessageDescriptionExtension");
	case SOAP_TYPE_PointerTons2__ItemListDescription:
		return soap_out_PointerTons2__ItemListDescription(soap, tag, id, (struct ns2__ItemListDescription *const*)ptr, "ns2:ItemListDescription");
	case SOAP_TYPE_PointerTons2__ItemListExtension:
		return soap_out_PointerTons2__ItemListExtension(soap, tag, id, (struct ns2__ItemListExtension *const*)ptr, "ns2:ItemListExtension");
	case SOAP_TYPE_PointerTo_ns2__ItemList_ElementItem:
		return soap_out_PointerTo_ns2__ItemList_ElementItem(soap, tag, id, (struct _ns2__ItemList_ElementItem *const*)ptr, "ns2:ItemList-ElementItem");
	case SOAP_TYPE_PointerTo_ns2__ItemList_SimpleItem:
		return soap_out_PointerTo_ns2__ItemList_SimpleItem(soap, tag, id, (struct _ns2__ItemList_SimpleItem *const*)ptr, "ns2:ItemList-SimpleItem");
	case SOAP_TYPE_PointerTons2__FocusOptions20Extension:
		return soap_out_PointerTons2__FocusOptions20Extension(soap, tag, id, (struct ns2__FocusOptions20Extension *const*)ptr, "ns2:FocusOptions20Extension");
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions20Extension:
		return soap_out_PointerTons2__WhiteBalanceOptions20Extension(soap, tag, id, (struct ns2__WhiteBalanceOptions20Extension *const*)ptr, "ns2:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_PointerTons2__FocusConfiguration20Extension:
		return soap_out_PointerTons2__FocusConfiguration20Extension(soap, tag, id, (struct ns2__FocusConfiguration20Extension *const*)ptr, "ns2:FocusConfiguration20Extension");
	case SOAP_TYPE_PointerTons2__WhiteBalance20Extension:
		return soap_out_PointerTons2__WhiteBalance20Extension(soap, tag, id, (struct ns2__WhiteBalance20Extension *const*)ptr, "ns2:WhiteBalance20Extension");
	case SOAP_TYPE_PointerTons2__RelativeFocusOptions20:
		return soap_out_PointerTons2__RelativeFocusOptions20(soap, tag, id, (struct ns2__RelativeFocusOptions20 *const*)ptr, "ns2:RelativeFocusOptions20");
	case SOAP_TYPE_PointerTons2__BacklightCompensationMode:
		return soap_out_PointerTons2__BacklightCompensationMode(soap, tag, id, (enum ns2__BacklightCompensationMode *const*)ptr, "ns2:BacklightCompensationMode");
	case SOAP_TYPE_PointerTons2__ImagingOptions20Extension:
		return soap_out_PointerTons2__ImagingOptions20Extension(soap, tag, id, (struct ns2__ImagingOptions20Extension *const*)ptr, "ns2:ImagingOptions20Extension");
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions20:
		return soap_out_PointerTons2__WhiteBalanceOptions20(soap, tag, id, (struct ns2__WhiteBalanceOptions20 *const*)ptr, "ns2:WhiteBalanceOptions20");
	case SOAP_TYPE_PointerTons2__WideDynamicRangeOptions20:
		return soap_out_PointerTons2__WideDynamicRangeOptions20(soap, tag, id, (struct ns2__WideDynamicRangeOptions20 *const*)ptr, "ns2:WideDynamicRangeOptions20");
	case SOAP_TYPE_PointerTons2__FocusOptions20:
		return soap_out_PointerTons2__FocusOptions20(soap, tag, id, (struct ns2__FocusOptions20 *const*)ptr, "ns2:FocusOptions20");
	case SOAP_TYPE_PointerTons2__ExposureOptions20:
		return soap_out_PointerTons2__ExposureOptions20(soap, tag, id, (struct ns2__ExposureOptions20 *const*)ptr, "ns2:ExposureOptions20");
	case SOAP_TYPE_PointerTons2__BacklightCompensationOptions20:
		return soap_out_PointerTons2__BacklightCompensationOptions20(soap, tag, id, (struct ns2__BacklightCompensationOptions20 *const*)ptr, "ns2:BacklightCompensationOptions20");
	case SOAP_TYPE_PointerTons2__ImagingSettingsExtension20:
		return soap_out_PointerTons2__ImagingSettingsExtension20(soap, tag, id, (struct ns2__ImagingSettingsExtension20 *const*)ptr, "ns2:ImagingSettingsExtension20");
	case SOAP_TYPE_PointerTons2__WhiteBalance20:
		return soap_out_PointerTons2__WhiteBalance20(soap, tag, id, (struct ns2__WhiteBalance20 *const*)ptr, "ns2:WhiteBalance20");
	case SOAP_TYPE_PointerTons2__WideDynamicRange20:
		return soap_out_PointerTons2__WideDynamicRange20(soap, tag, id, (struct ns2__WideDynamicRange20 *const*)ptr, "ns2:WideDynamicRange20");
	case SOAP_TYPE_PointerTons2__FocusConfiguration20:
		return soap_out_PointerTons2__FocusConfiguration20(soap, tag, id, (struct ns2__FocusConfiguration20 *const*)ptr, "ns2:FocusConfiguration20");
	case SOAP_TYPE_PointerTons2__Exposure20:
		return soap_out_PointerTons2__Exposure20(soap, tag, id, (struct ns2__Exposure20 *const*)ptr, "ns2:Exposure20");
	case SOAP_TYPE_PointerTons2__BacklightCompensation20:
		return soap_out_PointerTons2__BacklightCompensation20(soap, tag, id, (struct ns2__BacklightCompensation20 *const*)ptr, "ns2:BacklightCompensation20");
	case SOAP_TYPE_PointerTons2__FocusStatus20Extension:
		return soap_out_PointerTons2__FocusStatus20Extension(soap, tag, id, (struct ns2__FocusStatus20Extension *const*)ptr, "ns2:FocusStatus20Extension");
	case SOAP_TYPE_PointerTons2__ImagingStatus20Extension:
		return soap_out_PointerTons2__ImagingStatus20Extension(soap, tag, id, (struct ns2__ImagingStatus20Extension *const*)ptr, "ns2:ImagingStatus20Extension");
	case SOAP_TYPE_PointerTons2__FocusStatus20:
		return soap_out_PointerTons2__FocusStatus20(soap, tag, id, (struct ns2__FocusStatus20 *const*)ptr, "ns2:FocusStatus20");
	case SOAP_TYPE_PointerTons2__ContinuousFocusOptions:
		return soap_out_PointerTons2__ContinuousFocusOptions(soap, tag, id, (struct ns2__ContinuousFocusOptions *const*)ptr, "ns2:ContinuousFocusOptions");
	case SOAP_TYPE_PointerTons2__RelativeFocusOptions:
		return soap_out_PointerTons2__RelativeFocusOptions(soap, tag, id, (struct ns2__RelativeFocusOptions *const*)ptr, "ns2:RelativeFocusOptions");
	case SOAP_TYPE_PointerTons2__AbsoluteFocusOptions:
		return soap_out_PointerTons2__AbsoluteFocusOptions(soap, tag, id, (struct ns2__AbsoluteFocusOptions *const*)ptr, "ns2:AbsoluteFocusOptions");
	case SOAP_TYPE_PointerTons2__ContinuousFocus:
		return soap_out_PointerTons2__ContinuousFocus(soap, tag, id, (struct ns2__ContinuousFocus *const*)ptr, "ns2:ContinuousFocus");
	case SOAP_TYPE_PointerTons2__RelativeFocus:
		return soap_out_PointerTons2__RelativeFocus(soap, tag, id, (struct ns2__RelativeFocus *const*)ptr, "ns2:RelativeFocus");
	case SOAP_TYPE_PointerTons2__AbsoluteFocus:
		return soap_out_PointerTons2__AbsoluteFocus(soap, tag, id, (struct ns2__AbsoluteFocus *const*)ptr, "ns2:AbsoluteFocus");
	case SOAP_TYPE_PointerTons2__WhiteBalanceMode:
		return soap_out_PointerTons2__WhiteBalanceMode(soap, tag, id, (enum ns2__WhiteBalanceMode *const*)ptr, "ns2:WhiteBalanceMode");
	case SOAP_TYPE_PointerTons2__ExposurePriority:
		return soap_out_PointerTons2__ExposurePriority(soap, tag, id, (enum ns2__ExposurePriority *const*)ptr, "ns2:ExposurePriority");
	case SOAP_TYPE_PointerTons2__ExposureMode:
		return soap_out_PointerTons2__ExposureMode(soap, tag, id, (enum ns2__ExposureMode *const*)ptr, "ns2:ExposureMode");
	case SOAP_TYPE_PointerTons2__AutoFocusMode:
		return soap_out_PointerTons2__AutoFocusMode(soap, tag, id, (enum ns2__AutoFocusMode *const*)ptr, "ns2:AutoFocusMode");
	case SOAP_TYPE_PointerTons2__WideDynamicMode:
		return soap_out_PointerTons2__WideDynamicMode(soap, tag, id, (enum ns2__WideDynamicMode *const*)ptr, "ns2:WideDynamicMode");
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions:
		return soap_out_PointerTons2__WhiteBalanceOptions(soap, tag, id, (struct ns2__WhiteBalanceOptions *const*)ptr, "ns2:WhiteBalanceOptions");
	case SOAP_TYPE_PointerTons2__WideDynamicRangeOptions:
		return soap_out_PointerTons2__WideDynamicRangeOptions(soap, tag, id, (struct ns2__WideDynamicRangeOptions *const*)ptr, "ns2:WideDynamicRangeOptions");
	case SOAP_TYPE_PointerTons2__FocusOptions:
		return soap_out_PointerTons2__FocusOptions(soap, tag, id, (struct ns2__FocusOptions *const*)ptr, "ns2:FocusOptions");
	case SOAP_TYPE_PointerTons2__ExposureOptions:
		return soap_out_PointerTons2__ExposureOptions(soap, tag, id, (struct ns2__ExposureOptions *const*)ptr, "ns2:ExposureOptions");
	case SOAP_TYPE_PointerTons2__BacklightCompensationOptions:
		return soap_out_PointerTons2__BacklightCompensationOptions(soap, tag, id, (struct ns2__BacklightCompensationOptions *const*)ptr, "ns2:BacklightCompensationOptions");
	case SOAP_TYPE_PointerTons2__Rectangle:
		return soap_out_PointerTons2__Rectangle(soap, tag, id, (struct ns2__Rectangle *const*)ptr, "ns2:Rectangle");
	case SOAP_TYPE_PointerTons2__ImagingSettingsExtension:
		return soap_out_PointerTons2__ImagingSettingsExtension(soap, tag, id, (struct ns2__ImagingSettingsExtension *const*)ptr, "ns2:ImagingSettingsExtension");
	case SOAP_TYPE_PointerTons2__WhiteBalance:
		return soap_out_PointerTons2__WhiteBalance(soap, tag, id, (struct ns2__WhiteBalance *const*)ptr, "ns2:WhiteBalance");
	case SOAP_TYPE_PointerTons2__WideDynamicRange:
		return soap_out_PointerTons2__WideDynamicRange(soap, tag, id, (struct ns2__WideDynamicRange *const*)ptr, "ns2:WideDynamicRange");
	case SOAP_TYPE_PointerTons2__IrCutFilterMode:
		return soap_out_PointerTons2__IrCutFilterMode(soap, tag, id, (enum ns2__IrCutFilterMode *const*)ptr, "ns2:IrCutFilterMode");
	case SOAP_TYPE_PointerTons2__FocusConfiguration:
		return soap_out_PointerTons2__FocusConfiguration(soap, tag, id, (struct ns2__FocusConfiguration *const*)ptr, "ns2:FocusConfiguration");
	case SOAP_TYPE_PointerTons2__Exposure:
		return soap_out_PointerTons2__Exposure(soap, tag, id, (struct ns2__Exposure *const*)ptr, "ns2:Exposure");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTons2__BacklightCompensation:
		return soap_out_PointerTons2__BacklightCompensation(soap, tag, id, (struct ns2__BacklightCompensation *const*)ptr, "ns2:BacklightCompensation");
	case SOAP_TYPE_PointerTons2__FocusStatus:
		return soap_out_PointerTons2__FocusStatus(soap, tag, id, (struct ns2__FocusStatus *const*)ptr, "ns2:FocusStatus");
	case SOAP_TYPE_PointerTons2__MoveStatus:
		return soap_out_PointerTons2__MoveStatus(soap, tag, id, (enum ns2__MoveStatus *const*)ptr, "ns2:MoveStatus");
	case SOAP_TYPE_PointerTons2__PTZMoveStatus:
		return soap_out_PointerTons2__PTZMoveStatus(soap, tag, id, (struct ns2__PTZMoveStatus *const*)ptr, "ns2:PTZMoveStatus");
	case SOAP_TYPE_PointerTons2__PTZVector:
		return soap_out_PointerTons2__PTZVector(soap, tag, id, (struct ns2__PTZVector *const*)ptr, "ns2:PTZVector");
	case SOAP_TYPE_PointerTons2__Vector1D:
		return soap_out_PointerTons2__Vector1D(soap, tag, id, (struct ns2__Vector1D *const*)ptr, "ns2:Vector1D");
	case SOAP_TYPE_PointerTons2__Vector2D:
		return soap_out_PointerTons2__Vector2D(soap, tag, id, (struct ns2__Vector2D *const*)ptr, "ns2:Vector2D");
	case SOAP_TYPE_PointerTons2__FloatRange:
		return soap_out_PointerTons2__FloatRange(soap, tag, id, (struct ns2__FloatRange *const*)ptr, "ns2:FloatRange");
	case SOAP_TYPE_PointerTons2__PTZSpacesExtension:
		return soap_out_PointerTons2__PTZSpacesExtension(soap, tag, id, (struct ns2__PTZSpacesExtension *const*)ptr, "ns2:PTZSpacesExtension");
	case SOAP_TYPE_PointerTons2__Space1DDescription:
		return soap_out_PointerTons2__Space1DDescription(soap, tag, id, (struct ns2__Space1DDescription *const*)ptr, "ns2:Space1DDescription");
	case SOAP_TYPE_PointerTons2__Space2DDescription:
		return soap_out_PointerTons2__Space2DDescription(soap, tag, id, (struct ns2__Space2DDescription *const*)ptr, "ns2:Space2DDescription");
	case SOAP_TYPE_PointerTons2__DurationRange:
		return soap_out_PointerTons2__DurationRange(soap, tag, id, (struct ns2__DurationRange *const*)ptr, "ns2:DurationRange");
	case SOAP_TYPE_PointerTons2__PTZSpaces:
		return soap_out_PointerTons2__PTZSpaces(soap, tag, id, (struct ns2__PTZSpaces *const*)ptr, "ns2:PTZSpaces");
	case SOAP_TYPE_PointerTons2__BinaryData:
		return soap_out_PointerTons2__BinaryData(soap, tag, id, (struct ns2__BinaryData *const*)ptr, "ns2:BinaryData");
	case SOAP_TYPE_PointerTons2__CertificateGenerationParametersExtension:
		return soap_out_PointerTons2__CertificateGenerationParametersExtension(soap, tag, id, (struct ns2__CertificateGenerationParametersExtension *const*)ptr, "ns2:CertificateGenerationParametersExtension");
	case SOAP_TYPE_PointerTons2__Date:
		return soap_out_PointerTons2__Date(soap, tag, id, (struct ns2__Date *const*)ptr, "ns2:Date");
	case SOAP_TYPE_PointerTons2__Time:
		return soap_out_PointerTons2__Time(soap, tag, id, (struct ns2__Time *const*)ptr, "ns2:Time");
	case SOAP_TYPE_PointerTons2__SystemDateTimeExtension:
		return soap_out_PointerTons2__SystemDateTimeExtension(soap, tag, id, (struct ns2__SystemDateTimeExtension *const*)ptr, "ns2:SystemDateTimeExtension");
	case SOAP_TYPE_PointerTons2__DateTime:
		return soap_out_PointerTons2__DateTime(soap, tag, id, (struct ns2__DateTime *const*)ptr, "ns2:DateTime");
	case SOAP_TYPE_PointerTons2__TimeZone:
		return soap_out_PointerTons2__TimeZone(soap, tag, id, (struct ns2__TimeZone *const*)ptr, "ns2:TimeZone");
	case SOAP_TYPE_PointerTons2__AttachmentData:
		return soap_out_PointerTons2__AttachmentData(soap, tag, id, (struct ns2__AttachmentData *const*)ptr, "ns2:AttachmentData");
	case SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension:
		return soap_out_PointerTons2__SystemCapabilitiesExtension(soap, tag, id, (struct ns2__SystemCapabilitiesExtension *const*)ptr, "ns2:SystemCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__OnvifVersion:
		return soap_out_PointerTons2__OnvifVersion(soap, tag, id, (struct ns2__OnvifVersion *const*)ptr, "ns2:OnvifVersion");
	case SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension:
		return soap_out_PointerTons2__SecurityCapabilitiesExtension(soap, tag, id, (struct ns2__SecurityCapabilitiesExtension *const*)ptr, "ns2:SecurityCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension:
		return soap_out_PointerTons2__NetworkCapabilitiesExtension(soap, tag, id, (struct ns2__NetworkCapabilitiesExtension *const*)ptr, "ns2:NetworkCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilitiesExtension:
		return soap_out_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, tag, id, (struct ns2__RealTimeStreamingCapabilitiesExtension *const*)ptr, "ns2:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__ProfileCapabilities:
		return soap_out_PointerTons2__ProfileCapabilities(soap, tag, id, (struct ns2__ProfileCapabilities *const*)ptr, "ns2:ProfileCapabilities");
	case SOAP_TYPE_PointerTons2__MediaCapabilitiesExtension:
		return soap_out_PointerTons2__MediaCapabilitiesExtension(soap, tag, id, (struct ns2__MediaCapabilitiesExtension *const*)ptr, "ns2:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilities:
		return soap_out_PointerTons2__RealTimeStreamingCapabilities(soap, tag, id, (struct ns2__RealTimeStreamingCapabilities *const*)ptr, "ns2:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTons2__IOCapabilitiesExtension:
		return soap_out_PointerTons2__IOCapabilitiesExtension(soap, tag, id, (struct ns2__IOCapabilitiesExtension *const*)ptr, "ns2:IOCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__DeviceCapabilitiesExtension:
		return soap_out_PointerTons2__DeviceCapabilitiesExtension(soap, tag, id, (struct ns2__DeviceCapabilitiesExtension *const*)ptr, "ns2:DeviceCapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__SecurityCapabilities:
		return soap_out_PointerTons2__SecurityCapabilities(soap, tag, id, (struct ns2__SecurityCapabilities *const*)ptr, "ns2:SecurityCapabilities");
	case SOAP_TYPE_PointerTons2__IOCapabilities:
		return soap_out_PointerTons2__IOCapabilities(soap, tag, id, (struct ns2__IOCapabilities *const*)ptr, "ns2:IOCapabilities");
	case SOAP_TYPE_PointerTons2__SystemCapabilities:
		return soap_out_PointerTons2__SystemCapabilities(soap, tag, id, (struct ns2__SystemCapabilities *const*)ptr, "ns2:SystemCapabilities");
	case SOAP_TYPE_PointerTons2__NetworkCapabilities:
		return soap_out_PointerTons2__NetworkCapabilities(soap, tag, id, (struct ns2__NetworkCapabilities *const*)ptr, "ns2:NetworkCapabilities");
	case SOAP_TYPE_PointerTons2__CapabilitiesExtension:
		return soap_out_PointerTons2__CapabilitiesExtension(soap, tag, id, (struct ns2__CapabilitiesExtension *const*)ptr, "ns2:CapabilitiesExtension");
	case SOAP_TYPE_PointerTons2__PTZCapabilities:
		return soap_out_PointerTons2__PTZCapabilities(soap, tag, id, (struct ns2__PTZCapabilities *const*)ptr, "ns2:PTZCapabilities");
	case SOAP_TYPE_PointerTons2__MediaCapabilities:
		return soap_out_PointerTons2__MediaCapabilities(soap, tag, id, (struct ns2__MediaCapabilities *const*)ptr, "ns2:MediaCapabilities");
	case SOAP_TYPE_PointerTons2__ImagingCapabilities:
		return soap_out_PointerTons2__ImagingCapabilities(soap, tag, id, (struct ns2__ImagingCapabilities *const*)ptr, "ns2:ImagingCapabilities");
	case SOAP_TYPE_PointerTons2__EventCapabilities:
		return soap_out_PointerTons2__EventCapabilities(soap, tag, id, (struct ns2__EventCapabilities *const*)ptr, "ns2:EventCapabilities");
	case SOAP_TYPE_PointerTons2__DeviceCapabilities:
		return soap_out_PointerTons2__DeviceCapabilities(soap, tag, id, (struct ns2__DeviceCapabilities *const*)ptr, "ns2:DeviceCapabilities");
	case SOAP_TYPE_PointerTons2__AnalyticsCapabilities:
		return soap_out_PointerTons2__AnalyticsCapabilities(soap, tag, id, (struct ns2__AnalyticsCapabilities *const*)ptr, "ns2:AnalyticsCapabilities");
	case SOAP_TYPE_PointerTons2__IPAddressFilterExtension:
		return soap_out_PointerTons2__IPAddressFilterExtension(soap, tag, id, (struct ns2__IPAddressFilterExtension *const*)ptr, "ns2:IPAddressFilterExtension");
	case SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension:
		return soap_out_PointerTons2__NetworkZeroConfigurationExtension(soap, tag, id, (struct ns2__NetworkZeroConfigurationExtension *const*)ptr, "ns2:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_PointerTons2__IPv6DHCPConfiguration:
		return soap_out_PointerTons2__IPv6DHCPConfiguration(soap, tag, id, (enum ns2__IPv6DHCPConfiguration *const*)ptr, "ns2:IPv6DHCPConfiguration");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension:
		return soap_out_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, tag, id, (struct ns2__NetworkInterfaceSetConfigurationExtension *const*)ptr, "ns2:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_PointerTons2__IPv6NetworkInterfaceSetConfiguration:
		return soap_out_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, (struct ns2__IPv6NetworkInterfaceSetConfiguration *const*)ptr, "ns2:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTons2__IPv4NetworkInterfaceSetConfiguration:
		return soap_out_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, (struct ns2__IPv4NetworkInterfaceSetConfiguration *const*)ptr, "ns2:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTons2__DynamicDNSInformationExtension:
		return soap_out_PointerTons2__DynamicDNSInformationExtension(soap, tag, id, (struct ns2__DynamicDNSInformationExtension *const*)ptr, "ns2:DynamicDNSInformationExtension");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTons2__NTPInformationExtension:
		return soap_out_PointerTons2__NTPInformationExtension(soap, tag, id, (struct ns2__NTPInformationExtension *const*)ptr, "ns2:NTPInformationExtension");
	case SOAP_TYPE_PointerTons2__NetworkHost:
		return soap_out_PointerTons2__NetworkHost(soap, tag, id, (struct ns2__NetworkHost *const*)ptr, "ns2:NetworkHost");
	case SOAP_TYPE_PointerTons2__DNSInformationExtension:
		return soap_out_PointerTons2__DNSInformationExtension(soap, tag, id, (struct ns2__DNSInformationExtension *const*)ptr, "ns2:DNSInformationExtension");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_out_PointerToxsd__token(soap, tag, id, (char **const*)ptr, "xsd:token");
	case SOAP_TYPE_PointerTons2__HostnameInformationExtension:
		return soap_out_PointerTons2__HostnameInformationExtension(soap, tag, id, (struct ns2__HostnameInformationExtension *const*)ptr, "ns2:HostnameInformationExtension");
	case SOAP_TYPE_PointerTons2__NetworkHostExtension:
		return soap_out_PointerTons2__NetworkHostExtension(soap, tag, id, (struct ns2__NetworkHostExtension *const*)ptr, "ns2:NetworkHostExtension");
	case SOAP_TYPE_PointerTons2__DNSName:
		return soap_out_PointerTons2__DNSName(soap, tag, id, (char **const*)ptr, "ns2:DNSName");
	case SOAP_TYPE_PointerTons2__IPv6Address:
		return soap_out_PointerTons2__IPv6Address(soap, tag, id, (char **const*)ptr, "ns2:IPv6Address");
	case SOAP_TYPE_PointerTons2__IPv4Address:
		return soap_out_PointerTons2__IPv4Address(soap, tag, id, (char **const*)ptr, "ns2:IPv4Address");
	case SOAP_TYPE_PointerTons2__NetworkProtocolExtension:
		return soap_out_PointerTons2__NetworkProtocolExtension(soap, tag, id, (struct ns2__NetworkProtocolExtension *const*)ptr, "ns2:NetworkProtocolExtension");
	case SOAP_TYPE_PointerTons2__IPv6ConfigurationExtension:
		return soap_out_PointerTons2__IPv6ConfigurationExtension(soap, tag, id, (struct ns2__IPv6ConfigurationExtension *const*)ptr, "ns2:IPv6ConfigurationExtension");
	case SOAP_TYPE_PointerTons2__PrefixedIPv6Address:
		return soap_out_PointerTons2__PrefixedIPv6Address(soap, tag, id, (struct ns2__PrefixedIPv6Address *const*)ptr, "ns2:PrefixedIPv6Address");
	case SOAP_TYPE_PointerTons2__PrefixedIPv4Address:
		return soap_out_PointerTons2__PrefixedIPv4Address(soap, tag, id, (struct ns2__PrefixedIPv4Address *const*)ptr, "ns2:PrefixedIPv4Address");
	case SOAP_TYPE_PointerTons2__IPv4Configuration:
		return soap_out_PointerTons2__IPv4Configuration(soap, tag, id, (struct ns2__IPv4Configuration *const*)ptr, "ns2:IPv4Configuration");
	case SOAP_TYPE_PointerTons2__IPv6Configuration:
		return soap_out_PointerTons2__IPv6Configuration(soap, tag, id, (struct ns2__IPv6Configuration *const*)ptr, "ns2:IPv6Configuration");
	case SOAP_TYPE_PointerTons2__NetworkInterfaceConnectionSetting:
		return soap_out_PointerTons2__NetworkInterfaceConnectionSetting(soap, tag, id, (struct ns2__NetworkInterfaceConnectionSetting *const*)ptr, "ns2:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_PointerTons2__Transport:
		return soap_out_PointerTons2__Transport(soap, tag, id, (struct ns2__Transport *const*)ptr, "ns2:Transport");
	case SOAP_TYPE_PointerTons2__IPAddress:
		return soap_out_PointerTons2__IPAddress(soap, tag, id, (struct ns2__IPAddress *const*)ptr, "ns2:IPAddress");
	case SOAP_TYPE_PointerTons2__PTZStatusFilterOptions:
		return soap_out_PointerTons2__PTZStatusFilterOptions(soap, tag, id, (struct ns2__PTZStatusFilterOptions *const*)ptr, "ns2:PTZStatusFilterOptions");
	case SOAP_TYPE_PointerTo_ns2__EventSubscription_SubscriptionPolicy:
		return soap_out_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, tag, id, (struct _ns2__EventSubscription_SubscriptionPolicy *const*)ptr, "ns2:EventSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTons2__FilterType:
		return soap_out_PointerTons2__FilterType(soap, tag, id, (struct ns2__FilterType *const*)ptr, "ns2:FilterType");
	case SOAP_TYPE_PointerTons2__IntList:
		return soap_out_PointerTons2__IntList(soap, tag, id, (struct ns2__IntList *const*)ptr, "ns2:IntList");
	case SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOption:
		return soap_out_PointerTons2__AudioEncoderConfigurationOption(soap, tag, id, (struct ns2__AudioEncoderConfigurationOption *const*)ptr, "ns2:AudioEncoderConfigurationOption");
	case SOAP_TYPE_PointerTons2__AudioSourceOptionsExtension:
		return soap_out_PointerTons2__AudioSourceOptionsExtension(soap, tag, id, (struct ns2__AudioSourceOptionsExtension *const*)ptr, "ns2:AudioSourceOptionsExtension");
	case SOAP_TYPE_PointerTons2__H264Profile:
		return soap_out_PointerTons2__H264Profile(soap, tag, id, (enum ns2__H264Profile *const*)ptr, "ns2:H264Profile");
	case SOAP_TYPE_PointerTons2__Mpeg4Profile:
		return soap_out_PointerTons2__Mpeg4Profile(soap, tag, id, (enum ns2__Mpeg4Profile *const*)ptr, "ns2:Mpeg4Profile");
	case SOAP_TYPE_PointerTons2__VideoResolution:
		return soap_out_PointerTons2__VideoResolution(soap, tag, id, (struct ns2__VideoResolution *const*)ptr, "ns2:VideoResolution");
	case SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension:
		return soap_out_PointerTons2__VideoEncoderOptionsExtension(soap, tag, id, (struct ns2__VideoEncoderOptionsExtension *const*)ptr, "ns2:VideoEncoderOptionsExtension");
	case SOAP_TYPE_PointerTons2__H264Options:
		return soap_out_PointerTons2__H264Options(soap, tag, id, (struct ns2__H264Options *const*)ptr, "ns2:H264Options");
	case SOAP_TYPE_PointerTons2__Mpeg4Options:
		return soap_out_PointerTons2__Mpeg4Options(soap, tag, id, (struct ns2__Mpeg4Options *const*)ptr, "ns2:Mpeg4Options");
	case SOAP_TYPE_PointerTons2__JpegOptions:
		return soap_out_PointerTons2__JpegOptions(soap, tag, id, (struct ns2__JpegOptions *const*)ptr, "ns2:JpegOptions");
	case SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension:
		return soap_out_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, tag, id, (struct ns2__VideoSourceConfigurationOptionsExtension *const*)ptr, "ns2:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_PointerTons2__ReferenceToken:
		return soap_out_PointerTons2__ReferenceToken(soap, tag, id, (char **const*)ptr, "ns2:ReferenceToken");
	case SOAP_TYPE_PointerTons2__IntRectangleRange:
		return soap_out_PointerTons2__IntRectangleRange(soap, tag, id, (struct ns2__IntRectangleRange *const*)ptr, "ns2:IntRectangleRange");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons2__ProfileExtension:
		return soap_out_PointerTons2__ProfileExtension(soap, tag, id, (struct ns2__ProfileExtension *const*)ptr, "ns2:ProfileExtension");
	case SOAP_TYPE_PointerTons2__MetadataConfiguration:
		return soap_out_PointerTons2__MetadataConfiguration(soap, tag, id, (struct ns2__MetadataConfiguration *const*)ptr, "ns2:MetadataConfiguration");
	case SOAP_TYPE_PointerTons2__PTZConfiguration:
		return soap_out_PointerTons2__PTZConfiguration(soap, tag, id, (struct ns2__PTZConfiguration *const*)ptr, "ns2:PTZConfiguration");
	case SOAP_TYPE_PointerTons2__VideoAnalyticsConfiguration:
		return soap_out_PointerTons2__VideoAnalyticsConfiguration(soap, tag, id, (struct ns2__VideoAnalyticsConfiguration *const*)ptr, "ns2:VideoAnalyticsConfiguration");
	case SOAP_TYPE_PointerTons2__AudioEncoderConfiguration:
		return soap_out_PointerTons2__AudioEncoderConfiguration(soap, tag, id, (struct ns2__AudioEncoderConfiguration *const*)ptr, "ns2:AudioEncoderConfiguration");
	case SOAP_TYPE_PointerTons2__AudioSourceConfiguration:
		return soap_out_PointerTons2__AudioSourceConfiguration(soap, tag, id, (struct ns2__AudioSourceConfiguration *const*)ptr, "ns2:AudioSourceConfiguration");
	case SOAP_TYPE_PointerTons2__VideoSourceConfiguration:
		return soap_out_PointerTons2__VideoSourceConfiguration(soap, tag, id, (struct ns2__VideoSourceConfiguration *const*)ptr, "ns2:VideoSourceConfiguration");
	case SOAP_TYPE_PointerTons2__IntRange:
		return soap_out_PointerTons2__IntRange(soap, tag, id, (struct ns2__IntRange *const*)ptr, "ns2:IntRange");
	case SOAP_TYPE_PointerTons2__UserExtension:
		return soap_out_PointerTons2__UserExtension(soap, tag, id, (struct ns2__UserExtension *const*)ptr, "ns2:UserExtension");
	case SOAP_TYPE_PointerTons2__VideoEncoderConfiguration:
		return soap_out_PointerTons2__VideoEncoderConfiguration(soap, tag, id, (struct ns2__VideoEncoderConfiguration *const*)ptr, "ns2:VideoEncoderConfiguration");
	case SOAP_TYPE_PointerTons2__VideoEncoderConfigurationOptions:
		return soap_out_PointerTons2__VideoEncoderConfigurationOptions(soap, tag, id, (struct ns2__VideoEncoderConfigurationOptions *const*)ptr, "ns2:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_PointerTons2__MediaUri:
		return soap_out_PointerTons2__MediaUri(soap, tag, id, (struct ns2__MediaUri *const*)ptr, "ns2:MediaUri");
	case SOAP_TYPE_PointerTons2__StreamSetup:
		return soap_out_PointerTons2__StreamSetup(soap, tag, id, (struct ns2__StreamSetup *const*)ptr, "ns2:StreamSetup");
	case SOAP_TYPE_PointerTons2__Profile:
		return soap_out_PointerTons2__Profile(soap, tag, id, (struct ns2__Profile *const*)ptr, "ns2:Profile");
	case SOAP_TYPE_ns2__TopicNamespaceLocation:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:TopicNamespaceLocation");
	case SOAP_TYPE_ns2__AuxiliaryData:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:AuxiliaryData");
	case SOAP_TYPE_ns2__Domain:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:Domain");
	case SOAP_TYPE_ns2__DNSName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:DNSName");
	case SOAP_TYPE_ns2__HwAddress:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:HwAddress");
	case SOAP_TYPE_ns2__IPv6Address:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:IPv6Address");
	case SOAP_TYPE_ns2__IPv4Address:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:IPv4Address");
	case SOAP_TYPE_ns2__Name:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:Name");
	case SOAP_TYPE_ns2__ReferenceToken:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns2:ReferenceToken");
	case SOAP_TYPE_xsd__token:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__integer:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:integer");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anySimpleType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__GetSnapshotUri:
		soap_serialize___ns1__GetSnapshotUri(soap, (const struct __ns1__GetSnapshotUri *)ptr);
		break;
	case SOAP_TYPE___ns1__SetVideoEncoderConfiguration:
		soap_serialize___ns1__SetVideoEncoderConfiguration(soap, (const struct __ns1__SetVideoEncoderConfiguration *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions:
		soap_serialize___ns1__GetVideoEncoderConfigurationOptions(soap, (const struct __ns1__GetVideoEncoderConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStreamUri:
		soap_serialize___ns1__GetStreamUri(soap, (const struct __ns1__GetStreamUri *)ptr);
		break;
	case SOAP_TYPE___ns1__GetProfiles:
		soap_serialize___ns1__GetProfiles(soap, (const struct __ns1__GetProfiles *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZNode:
		soap_serialize_ns2__PTZNode(soap, (const struct ns2__PTZNode *)ptr);
		break;
	case SOAP_TYPE_ns2__RelayOutput:
		soap_serialize_ns2__RelayOutput(soap, (const struct ns2__RelayOutput *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterface:
		soap_serialize_ns2__NetworkInterface(soap, (const struct ns2__NetworkInterface *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioSource:
		soap_serialize_ns2__AudioSource(soap, (const struct ns2__AudioSource *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoSource:
		soap_serialize_ns2__VideoSource(soap, (const struct ns2__VideoSource *)ptr);
		break;
	case SOAP_TYPE__ns2__Message:
		soap_serialize__ns2__Message(soap, (const struct _ns2__Message *)ptr);
		break;
	case SOAP_TYPE_ns2__MetadataType:
		soap_serialize_ns2__MetadataType(soap, (const struct ns2__MetadataType *)ptr);
		break;
	case SOAP_TYPE_ns2__ReferenceParametersType:
		soap_serialize_ns2__ReferenceParametersType(soap, (const struct ns2__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_ns2__AttributedURIType:
		soap_serialize_ns2__AttributedURIType(soap, (const struct ns2__AttributedURIType *)ptr);
		break;
	case SOAP_TYPE__ns2__NotificationMessageHolderType_Message:
		soap_serialize__ns2__NotificationMessageHolderType_Message(soap, (const struct _ns2__NotificationMessageHolderType_Message *)ptr);
		break;
	case SOAP_TYPE_ns2__TopicExpressionType:
		soap_serialize_ns2__TopicExpressionType(soap, (const struct ns2__TopicExpressionType *)ptr);
		break;
	case SOAP_TYPE_ns2__EndpointReferenceType:
		soap_serialize_ns2__EndpointReferenceType(soap, (const struct ns2__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_ns2__EventStreamExtension:
		soap_serialize_ns2__EventStreamExtension(soap, (const struct ns2__EventStreamExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__NotificationMessageHolderType:
		soap_serialize_ns2__NotificationMessageHolderType(soap, (const struct ns2__NotificationMessageHolderType *)ptr);
		break;
	case SOAP_TYPE___ns2__union_EventStream:
		soap_serialize___ns2__union_EventStream(soap, (const struct __ns2__union_EventStream *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZStreamExtension:
		soap_serialize_ns2__PTZStreamExtension(soap, (const struct ns2__PTZStreamExtension *)ptr);
		break;
	case SOAP_TYPE___ns2__union_PTZStream:
		soap_serialize___ns2__union_PTZStream(soap, (const struct __ns2__union_PTZStream *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoAnalyticsStreamExtension:
		soap_serialize_ns2__VideoAnalyticsStreamExtension(soap, (const struct ns2__VideoAnalyticsStreamExtension *)ptr);
		break;
	case SOAP_TYPE___ns2__union_VideoAnalyticsStream:
		soap_serialize___ns2__union_VideoAnalyticsStream(soap, (const struct __ns2__union_VideoAnalyticsStream *)ptr);
		break;
	case SOAP_TYPE_ns2__MetadataStreamExtension:
		soap_serialize_ns2__MetadataStreamExtension(soap, (const struct ns2__MetadataStreamExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__EventStream:
		soap_serialize_ns2__EventStream(soap, (const struct ns2__EventStream *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZStream:
		soap_serialize_ns2__PTZStream(soap, (const struct ns2__PTZStream *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoAnalyticsStream:
		soap_serialize_ns2__VideoAnalyticsStream(soap, (const struct ns2__VideoAnalyticsStream *)ptr);
		break;
	case SOAP_TYPE___ns2__union_MetadataStream:
		soap_serialize___ns2__union_MetadataStream(soap, (const struct __ns2__union_MetadataStream *)ptr);
		break;
	case SOAP_TYPE_ns2__MetadataStream:
		soap_serialize_ns2__MetadataStream(soap, (const struct ns2__MetadataStream *)ptr);
		break;
	case SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension:
		soap_serialize_ns2__SupportedAnalyticsModulesExtension(soap, (const struct ns2__SupportedAnalyticsModulesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__SupportedAnalyticsModules:
		soap_serialize_ns2__SupportedAnalyticsModules(soap, (const struct ns2__SupportedAnalyticsModules *)ptr);
		break;
	case SOAP_TYPE_ns2__SupportedRulesExtension:
		soap_serialize_ns2__SupportedRulesExtension(soap, (const struct ns2__SupportedRulesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__SupportedRules:
		soap_serialize_ns2__SupportedRules(soap, (const struct ns2__SupportedRules *)ptr);
		break;
	case SOAP_TYPE_ns2__ConfigDescriptionExtension:
		soap_serialize_ns2__ConfigDescriptionExtension(soap, (const struct ns2__ConfigDescriptionExtension *)ptr);
		break;
	case SOAP_TYPE__ns2__ConfigDescription_Messages:
		soap_serialize__ns2__ConfigDescription_Messages(soap, (const struct _ns2__ConfigDescription_Messages *)ptr);
		break;
	case SOAP_TYPE_ns2__ConfigDescription:
		soap_serialize_ns2__ConfigDescription(soap, (const struct ns2__ConfigDescription *)ptr);
		break;
	case SOAP_TYPE_ns2__RuleEngineConfigurationExtension:
		soap_serialize_ns2__RuleEngineConfigurationExtension(soap, (const struct ns2__RuleEngineConfigurationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__RuleEngineConfiguration:
		soap_serialize_ns2__RuleEngineConfiguration(soap, (const struct ns2__RuleEngineConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension:
		soap_serialize_ns2__AnalyticsEngineConfigurationExtension(soap, (const struct ns2__AnalyticsEngineConfigurationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__Config:
		soap_serialize_ns2__Config(soap, (const struct ns2__Config *)ptr);
		break;
	case SOAP_TYPE_ns2__AnalyticsEngineConfiguration:
		soap_serialize_ns2__AnalyticsEngineConfiguration(soap, (const struct ns2__AnalyticsEngineConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__ObjectTreeExtension:
		soap_serialize_ns2__ObjectTreeExtension(soap, (const struct ns2__ObjectTreeExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__BehaviourExtension:
		soap_serialize_ns2__BehaviourExtension(soap, (const struct ns2__BehaviourExtension *)ptr);
		break;
	case SOAP_TYPE__ns2__Behaviour_Idle:
		soap_serialize__ns2__Behaviour_Idle(soap, (const struct _ns2__Behaviour_Idle *)ptr);
		break;
	case SOAP_TYPE__ns2__Behaviour_Removed:
		soap_serialize__ns2__Behaviour_Removed(soap, (const struct _ns2__Behaviour_Removed *)ptr);
		break;
	case SOAP_TYPE_ns2__Behaviour:
		soap_serialize_ns2__Behaviour(soap, (const struct ns2__Behaviour *)ptr);
		break;
	case SOAP_TYPE_ns2__Rename:
		soap_serialize_ns2__Rename(soap, (const struct ns2__Rename *)ptr);
		break;
	case SOAP_TYPE_ns2__Split:
		soap_serialize_ns2__Split(soap, (const struct ns2__Split *)ptr);
		break;
	case SOAP_TYPE_ns2__ObjectId:
		soap_serialize_ns2__ObjectId(soap, (const struct ns2__ObjectId *)ptr);
		break;
	case SOAP_TYPE_ns2__Merge:
		soap_serialize_ns2__Merge(soap, (const struct ns2__Merge *)ptr);
		break;
	case SOAP_TYPE_ns2__FrameExtension:
		soap_serialize_ns2__FrameExtension(soap, (const struct ns2__FrameExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__ObjectTree:
		soap_serialize_ns2__ObjectTree(soap, (const struct ns2__ObjectTree *)ptr);
		break;
	case SOAP_TYPE_ns2__Object:
		soap_serialize_ns2__Object(soap, (const struct ns2__Object *)ptr);
		break;
	case SOAP_TYPE_ns2__Frame:
		soap_serialize_ns2__Frame(soap, (const struct ns2__Frame *)ptr);
		break;
	case SOAP_TYPE_ns2__TransformationExtension:
		soap_serialize_ns2__TransformationExtension(soap, (const struct ns2__TransformationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__ObjectExtension:
		soap_serialize_ns2__ObjectExtension(soap, (const struct ns2__ObjectExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__ClassDescriptorExtension:
		soap_serialize_ns2__ClassDescriptorExtension(soap, (const struct ns2__ClassDescriptorExtension *)ptr);
		break;
	case SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate:
		soap_serialize__ns2__ClassDescriptor_ClassCandidate(soap, (const struct _ns2__ClassDescriptor_ClassCandidate *)ptr);
		break;
	case SOAP_TYPE_ns2__ColorDescriptorExtension:
		soap_serialize_ns2__ColorDescriptorExtension(soap, (const struct ns2__ColorDescriptorExtension *)ptr);
		break;
	case SOAP_TYPE__ns2__ColorDescriptor_ColorCluster:
		soap_serialize__ns2__ColorDescriptor_ColorCluster(soap, (const struct _ns2__ColorDescriptor_ColorCluster *)ptr);
		break;
	case SOAP_TYPE_ns2__ShapeDescriptorExtension:
		soap_serialize_ns2__ShapeDescriptorExtension(soap, (const struct ns2__ShapeDescriptorExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__AppearanceExtension:
		soap_serialize_ns2__AppearanceExtension(soap, (const struct ns2__AppearanceExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__ClassDescriptor:
		soap_serialize_ns2__ClassDescriptor(soap, (const struct ns2__ClassDescriptor *)ptr);
		break;
	case SOAP_TYPE_ns2__ColorDescriptor:
		soap_serialize_ns2__ColorDescriptor(soap, (const struct ns2__ColorDescriptor *)ptr);
		break;
	case SOAP_TYPE_ns2__ShapeDescriptor:
		soap_serialize_ns2__ShapeDescriptor(soap, (const struct ns2__ShapeDescriptor *)ptr);
		break;
	case SOAP_TYPE_ns2__Transformation:
		soap_serialize_ns2__Transformation(soap, (const struct ns2__Transformation *)ptr);
		break;
	case SOAP_TYPE_ns2__Appearance:
		soap_serialize_ns2__Appearance(soap, (const struct ns2__Appearance *)ptr);
		break;
	case SOAP_TYPE_ns2__ColorCovariance:
		soap_serialize_ns2__ColorCovariance(soap, (const struct ns2__ColorCovariance *)ptr);
		break;
	case SOAP_TYPE_ns2__Color:
		soap_serialize_ns2__Color(soap, (const struct ns2__Color *)ptr);
		break;
	case SOAP_TYPE_ns2__Polyline:
		soap_serialize_ns2__Polyline(soap, (const struct ns2__Polyline *)ptr);
		break;
	case SOAP_TYPE_ns2__Polygon:
		soap_serialize_ns2__Polygon(soap, (const struct ns2__Polygon *)ptr);
		break;
	case SOAP_TYPE_ns2__Vector:
		soap_serialize_ns2__Vector(soap, (const struct ns2__Vector *)ptr);
		break;
	case SOAP_TYPE_ns2__ItemListDescriptionExtension:
		soap_serialize_ns2__ItemListDescriptionExtension(soap, (const struct ns2__ItemListDescriptionExtension *)ptr);
		break;
	case SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription:
		soap_serialize__ns2__ItemListDescription_ElementItemDescription(soap, (const struct _ns2__ItemListDescription_ElementItemDescription *)ptr);
		break;
	case SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription:
		soap_serialize__ns2__ItemListDescription_SimpleItemDescription(soap, (const struct _ns2__ItemListDescription_SimpleItemDescription *)ptr);
		break;
	case SOAP_TYPE_ns2__MessageDescriptionExtension:
		soap_serialize_ns2__MessageDescriptionExtension(soap, (const struct ns2__MessageDescriptionExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__ItemListDescription:
		soap_serialize_ns2__ItemListDescription(soap, (const struct ns2__ItemListDescription *)ptr);
		break;
	case SOAP_TYPE_ns2__MessageDescription:
		soap_serialize_ns2__MessageDescription(soap, (const struct ns2__MessageDescription *)ptr);
		break;
	case SOAP_TYPE_ns2__ItemListExtension:
		soap_serialize_ns2__ItemListExtension(soap, (const struct ns2__ItemListExtension *)ptr);
		break;
	case SOAP_TYPE__ns2__ItemList_ElementItem:
		soap_serialize__ns2__ItemList_ElementItem(soap, (const struct _ns2__ItemList_ElementItem *)ptr);
		break;
	case SOAP_TYPE__ns2__ItemList_SimpleItem:
		soap_serialize__ns2__ItemList_SimpleItem(soap, (const struct _ns2__ItemList_SimpleItem *)ptr);
		break;
	case SOAP_TYPE_ns2__ItemList:
		soap_serialize_ns2__ItemList(soap, (const struct ns2__ItemList *)ptr);
		break;
	case SOAP_TYPE_ns2__MessageExtension:
		soap_serialize_ns2__MessageExtension(soap, (const struct ns2__MessageExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusOptions20Extension:
		soap_serialize_ns2__FocusOptions20Extension(soap, (const struct ns2__FocusOptions20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__WhiteBalanceOptions20Extension:
		soap_serialize_ns2__WhiteBalanceOptions20Extension(soap, (const struct ns2__WhiteBalanceOptions20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusConfiguration20Extension:
		soap_serialize_ns2__FocusConfiguration20Extension(soap, (const struct ns2__FocusConfiguration20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__WhiteBalance20Extension:
		soap_serialize_ns2__WhiteBalance20Extension(soap, (const struct ns2__WhiteBalance20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__RelativeFocusOptions20:
		soap_serialize_ns2__RelativeFocusOptions20(soap, (const struct ns2__RelativeFocusOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__MoveOptions20:
		soap_serialize_ns2__MoveOptions20(soap, (const struct ns2__MoveOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingOptions20Extension:
		soap_serialize_ns2__ImagingOptions20Extension(soap, (const struct ns2__ImagingOptions20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__WhiteBalanceOptions20:
		soap_serialize_ns2__WhiteBalanceOptions20(soap, (const struct ns2__WhiteBalanceOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__WideDynamicRangeOptions20:
		soap_serialize_ns2__WideDynamicRangeOptions20(soap, (const struct ns2__WideDynamicRangeOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusOptions20:
		soap_serialize_ns2__FocusOptions20(soap, (const struct ns2__FocusOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ExposureOptions20:
		soap_serialize_ns2__ExposureOptions20(soap, (const struct ns2__ExposureOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__BacklightCompensationOptions20:
		soap_serialize_ns2__BacklightCompensationOptions20(soap, (const struct ns2__BacklightCompensationOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingOptions20:
		soap_serialize_ns2__ImagingOptions20(soap, (const struct ns2__ImagingOptions20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingSettingsExtension20:
		soap_serialize_ns2__ImagingSettingsExtension20(soap, (const struct ns2__ImagingSettingsExtension20 *)ptr);
		break;
	case SOAP_TYPE_ns2__WhiteBalance20:
		soap_serialize_ns2__WhiteBalance20(soap, (const struct ns2__WhiteBalance20 *)ptr);
		break;
	case SOAP_TYPE_ns2__WideDynamicRange20:
		soap_serialize_ns2__WideDynamicRange20(soap, (const struct ns2__WideDynamicRange20 *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusConfiguration20:
		soap_serialize_ns2__FocusConfiguration20(soap, (const struct ns2__FocusConfiguration20 *)ptr);
		break;
	case SOAP_TYPE_ns2__Exposure20:
		soap_serialize_ns2__Exposure20(soap, (const struct ns2__Exposure20 *)ptr);
		break;
	case SOAP_TYPE_ns2__BacklightCompensation20:
		soap_serialize_ns2__BacklightCompensation20(soap, (const struct ns2__BacklightCompensation20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingSettings20:
		soap_serialize_ns2__ImagingSettings20(soap, (const struct ns2__ImagingSettings20 *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusStatus20Extension:
		soap_serialize_ns2__FocusStatus20Extension(soap, (const struct ns2__FocusStatus20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingStatus20Extension:
		soap_serialize_ns2__ImagingStatus20Extension(soap, (const struct ns2__ImagingStatus20Extension *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusStatus20:
		soap_serialize_ns2__FocusStatus20(soap, (const struct ns2__FocusStatus20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingStatus20:
		soap_serialize_ns2__ImagingStatus20(soap, (const struct ns2__ImagingStatus20 *)ptr);
		break;
	case SOAP_TYPE_ns2__ContinuousFocusOptions:
		soap_serialize_ns2__ContinuousFocusOptions(soap, (const struct ns2__ContinuousFocusOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__RelativeFocusOptions:
		soap_serialize_ns2__RelativeFocusOptions(soap, (const struct ns2__RelativeFocusOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__AbsoluteFocusOptions:
		soap_serialize_ns2__AbsoluteFocusOptions(soap, (const struct ns2__AbsoluteFocusOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__MoveOptions:
		soap_serialize_ns2__MoveOptions(soap, (const struct ns2__MoveOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__ContinuousFocus:
		soap_serialize_ns2__ContinuousFocus(soap, (const struct ns2__ContinuousFocus *)ptr);
		break;
	case SOAP_TYPE_ns2__RelativeFocus:
		soap_serialize_ns2__RelativeFocus(soap, (const struct ns2__RelativeFocus *)ptr);
		break;
	case SOAP_TYPE_ns2__AbsoluteFocus:
		soap_serialize_ns2__AbsoluteFocus(soap, (const struct ns2__AbsoluteFocus *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusMove:
		soap_serialize_ns2__FocusMove(soap, (const struct ns2__FocusMove *)ptr);
		break;
	case SOAP_TYPE_ns2__WhiteBalanceOptions:
		soap_serialize_ns2__WhiteBalanceOptions(soap, (const struct ns2__WhiteBalanceOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__WideDynamicRangeOptions:
		soap_serialize_ns2__WideDynamicRangeOptions(soap, (const struct ns2__WideDynamicRangeOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusOptions:
		soap_serialize_ns2__FocusOptions(soap, (const struct ns2__FocusOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__ExposureOptions:
		soap_serialize_ns2__ExposureOptions(soap, (const struct ns2__ExposureOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__BacklightCompensationOptions:
		soap_serialize_ns2__BacklightCompensationOptions(soap, (const struct ns2__BacklightCompensationOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingOptions:
		soap_serialize_ns2__ImagingOptions(soap, (const struct ns2__ImagingOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__Rectangle:
		soap_serialize_ns2__Rectangle(soap, (const struct ns2__Rectangle *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingSettingsExtension:
		soap_serialize_ns2__ImagingSettingsExtension(soap, (const struct ns2__ImagingSettingsExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__WhiteBalance:
		soap_serialize_ns2__WhiteBalance(soap, (const struct ns2__WhiteBalance *)ptr);
		break;
	case SOAP_TYPE_ns2__WideDynamicRange:
		soap_serialize_ns2__WideDynamicRange(soap, (const struct ns2__WideDynamicRange *)ptr);
		break;
	case SOAP_TYPE_ns2__Exposure:
		soap_serialize_ns2__Exposure(soap, (const struct ns2__Exposure *)ptr);
		break;
	case SOAP_TYPE_ns2__BacklightCompensation:
		soap_serialize_ns2__BacklightCompensation(soap, (const struct ns2__BacklightCompensation *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingSettings:
		soap_serialize_ns2__ImagingSettings(soap, (const struct ns2__ImagingSettings *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusConfiguration:
		soap_serialize_ns2__FocusConfiguration(soap, (const struct ns2__FocusConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__FocusStatus:
		soap_serialize_ns2__FocusStatus(soap, (const struct ns2__FocusStatus *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingStatus:
		soap_serialize_ns2__ImagingStatus(soap, (const struct ns2__ImagingStatus *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZPreset:
		soap_serialize_ns2__PTZPreset(soap, (const struct ns2__PTZPreset *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZMoveStatus:
		soap_serialize_ns2__PTZMoveStatus(soap, (const struct ns2__PTZMoveStatus *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZStatus:
		soap_serialize_ns2__PTZStatus(soap, (const struct ns2__PTZStatus *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZSpeed:
		soap_serialize_ns2__PTZSpeed(soap, (const struct ns2__PTZSpeed *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZVector:
		soap_serialize_ns2__PTZVector(soap, (const struct ns2__PTZVector *)ptr);
		break;
	case SOAP_TYPE_ns2__Vector1D:
		soap_serialize_ns2__Vector1D(soap, (const struct ns2__Vector1D *)ptr);
		break;
	case SOAP_TYPE_ns2__Vector2D:
		soap_serialize_ns2__Vector2D(soap, (const struct ns2__Vector2D *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZSpacesExtension:
		soap_serialize_ns2__PTZSpacesExtension(soap, (const struct ns2__PTZSpacesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__Space1DDescription:
		soap_serialize_ns2__Space1DDescription(soap, (const struct ns2__Space1DDescription *)ptr);
		break;
	case SOAP_TYPE_ns2__ZoomLimits:
		soap_serialize_ns2__ZoomLimits(soap, (const struct ns2__ZoomLimits *)ptr);
		break;
	case SOAP_TYPE_ns2__Space2DDescription:
		soap_serialize_ns2__Space2DDescription(soap, (const struct ns2__Space2DDescription *)ptr);
		break;
	case SOAP_TYPE_ns2__PanTiltLimits:
		soap_serialize_ns2__PanTiltLimits(soap, (const struct ns2__PanTiltLimits *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZSpaces:
		soap_serialize_ns2__PTZSpaces(soap, (const struct ns2__PTZSpaces *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZConfigurationOptions:
		soap_serialize_ns2__PTZConfigurationOptions(soap, (const struct ns2__PTZConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZConfigurationExtension:
		soap_serialize_ns2__PTZConfigurationExtension(soap, (const struct ns2__PTZConfigurationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZNodeExtension:
		soap_serialize_ns2__PTZNodeExtension(soap, (const struct ns2__PTZNodeExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__RelayOutputSettings:
		soap_serialize_ns2__RelayOutputSettings(soap, (const struct ns2__RelayOutputSettings *)ptr);
		break;
	case SOAP_TYPE_ns2__CertificateStatus:
		soap_serialize_ns2__CertificateStatus(soap, (const struct ns2__CertificateStatus *)ptr);
		break;
	case SOAP_TYPE_ns2__Certificate:
		soap_serialize_ns2__Certificate(soap, (const struct ns2__Certificate *)ptr);
		break;
	case SOAP_TYPE_ns2__CertificateGenerationParametersExtension:
		soap_serialize_ns2__CertificateGenerationParametersExtension(soap, (const struct ns2__CertificateGenerationParametersExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__CertificateGenerationParameters:
		soap_serialize_ns2__CertificateGenerationParameters(soap, (const struct ns2__CertificateGenerationParameters *)ptr);
		break;
	case SOAP_TYPE_ns2__Date:
		soap_serialize_ns2__Date(soap, (const struct ns2__Date *)ptr);
		break;
	case SOAP_TYPE_ns2__Time:
		soap_serialize_ns2__Time(soap, (const struct ns2__Time *)ptr);
		break;
	case SOAP_TYPE_ns2__SystemDateTimeExtension:
		soap_serialize_ns2__SystemDateTimeExtension(soap, (const struct ns2__SystemDateTimeExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__DateTime:
		soap_serialize_ns2__DateTime(soap, (const struct ns2__DateTime *)ptr);
		break;
	case SOAP_TYPE_ns2__TimeZone:
		soap_serialize_ns2__TimeZone(soap, (const struct ns2__TimeZone *)ptr);
		break;
	case SOAP_TYPE_ns2__SystemDateTime:
		soap_serialize_ns2__SystemDateTime(soap, (const struct ns2__SystemDateTime *)ptr);
		break;
	case SOAP_TYPE_ns2__BackupFile:
		soap_serialize_ns2__BackupFile(soap, (const struct ns2__BackupFile *)ptr);
		break;
	case SOAP_TYPE_ns2__BinaryData:
		soap_serialize_ns2__BinaryData(soap, (const struct ns2__BinaryData *)ptr);
		break;
	case SOAP_TYPE_ns2__SupportInformation:
		soap_serialize_ns2__SupportInformation(soap, (const struct ns2__SupportInformation *)ptr);
		break;
	case SOAP_TYPE_ns2__AttachmentData:
		soap_serialize_ns2__AttachmentData(soap, (const struct ns2__AttachmentData *)ptr);
		break;
	case SOAP_TYPE_ns2__SystemLog:
		soap_serialize_ns2__SystemLog(soap, (const struct ns2__SystemLog *)ptr);
		break;
	case SOAP_TYPE_ns2__SystemCapabilitiesExtension:
		soap_serialize_ns2__SystemCapabilitiesExtension(soap, (const struct ns2__SystemCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__OnvifVersion:
		soap_serialize_ns2__OnvifVersion(soap, (const struct ns2__OnvifVersion *)ptr);
		break;
	case SOAP_TYPE_ns2__StorageCapabilities:
		soap_serialize_ns2__StorageCapabilities(soap, (const struct ns2__StorageCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__SecurityCapabilitiesExtension:
		soap_serialize_ns2__SecurityCapabilitiesExtension(soap, (const struct ns2__SecurityCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkCapabilitiesExtension:
		soap_serialize_ns2__NetworkCapabilitiesExtension(soap, (const struct ns2__NetworkCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension:
		soap_serialize_ns2__RealTimeStreamingCapabilitiesExtension(soap, (const struct ns2__RealTimeStreamingCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__ProfileCapabilities:
		soap_serialize_ns2__ProfileCapabilities(soap, (const struct ns2__ProfileCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__MediaCapabilitiesExtension:
		soap_serialize_ns2__MediaCapabilitiesExtension(soap, (const struct ns2__MediaCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__RealTimeStreamingCapabilities:
		soap_serialize_ns2__RealTimeStreamingCapabilities(soap, (const struct ns2__RealTimeStreamingCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__IOCapabilitiesExtension:
		soap_serialize_ns2__IOCapabilitiesExtension(soap, (const struct ns2__IOCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__DeviceCapabilitiesExtension:
		soap_serialize_ns2__DeviceCapabilitiesExtension(soap, (const struct ns2__DeviceCapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__SecurityCapabilities:
		soap_serialize_ns2__SecurityCapabilities(soap, (const struct ns2__SecurityCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__IOCapabilities:
		soap_serialize_ns2__IOCapabilities(soap, (const struct ns2__IOCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__SystemCapabilities:
		soap_serialize_ns2__SystemCapabilities(soap, (const struct ns2__SystemCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkCapabilities:
		soap_serialize_ns2__NetworkCapabilities(soap, (const struct ns2__NetworkCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__CapabilitiesExtension:
		soap_serialize_ns2__CapabilitiesExtension(soap, (const struct ns2__CapabilitiesExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZCapabilities:
		soap_serialize_ns2__PTZCapabilities(soap, (const struct ns2__PTZCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__MediaCapabilities:
		soap_serialize_ns2__MediaCapabilities(soap, (const struct ns2__MediaCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__ImagingCapabilities:
		soap_serialize_ns2__ImagingCapabilities(soap, (const struct ns2__ImagingCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__EventCapabilities:
		soap_serialize_ns2__EventCapabilities(soap, (const struct ns2__EventCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__DeviceCapabilities:
		soap_serialize_ns2__DeviceCapabilities(soap, (const struct ns2__DeviceCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__AnalyticsCapabilities:
		soap_serialize_ns2__AnalyticsCapabilities(soap, (const struct ns2__AnalyticsCapabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__Capabilities:
		soap_serialize_ns2__Capabilities(soap, (const struct ns2__Capabilities *)ptr);
		break;
	case SOAP_TYPE_ns2__IPAddressFilterExtension:
		soap_serialize_ns2__IPAddressFilterExtension(soap, (const struct ns2__IPAddressFilterExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__IPAddressFilter:
		soap_serialize_ns2__IPAddressFilter(soap, (const struct ns2__IPAddressFilter *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkZeroConfigurationExtension:
		soap_serialize_ns2__NetworkZeroConfigurationExtension(soap, (const struct ns2__NetworkZeroConfigurationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkZeroConfiguration:
		soap_serialize_ns2__NetworkZeroConfiguration(soap, (const struct ns2__NetworkZeroConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkGateway:
		soap_serialize_ns2__NetworkGateway(soap, (const struct ns2__NetworkGateway *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension:
		soap_serialize_ns2__NetworkInterfaceSetConfigurationExtension(soap, (const struct ns2__NetworkInterfaceSetConfigurationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration:
		soap_serialize_ns2__IPv6NetworkInterfaceSetConfiguration(soap, (const struct ns2__IPv6NetworkInterfaceSetConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration:
		soap_serialize_ns2__IPv4NetworkInterfaceSetConfiguration(soap, (const struct ns2__IPv4NetworkInterfaceSetConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration:
		soap_serialize_ns2__NetworkInterfaceSetConfiguration(soap, (const struct ns2__NetworkInterfaceSetConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__DynamicDNSInformationExtension:
		soap_serialize_ns2__DynamicDNSInformationExtension(soap, (const struct ns2__DynamicDNSInformationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__DynamicDNSInformation:
		soap_serialize_ns2__DynamicDNSInformation(soap, (const struct ns2__DynamicDNSInformation *)ptr);
		break;
	case SOAP_TYPE_ns2__NTPInformationExtension:
		soap_serialize_ns2__NTPInformationExtension(soap, (const struct ns2__NTPInformationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__NTPInformation:
		soap_serialize_ns2__NTPInformation(soap, (const struct ns2__NTPInformation *)ptr);
		break;
	case SOAP_TYPE_ns2__DNSInformationExtension:
		soap_serialize_ns2__DNSInformationExtension(soap, (const struct ns2__DNSInformationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__DNSInformation:
		soap_serialize_ns2__DNSInformation(soap, (const struct ns2__DNSInformation *)ptr);
		break;
	case SOAP_TYPE_ns2__HostnameInformationExtension:
		soap_serialize_ns2__HostnameInformationExtension(soap, (const struct ns2__HostnameInformationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__HostnameInformation:
		soap_serialize_ns2__HostnameInformation(soap, (const struct ns2__HostnameInformation *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkHostExtension:
		soap_serialize_ns2__NetworkHostExtension(soap, (const struct ns2__NetworkHostExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkHost:
		soap_serialize_ns2__NetworkHost(soap, (const struct ns2__NetworkHost *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkProtocolExtension:
		soap_serialize_ns2__NetworkProtocolExtension(soap, (const struct ns2__NetworkProtocolExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkProtocol:
		soap_serialize_ns2__NetworkProtocol(soap, (const struct ns2__NetworkProtocol *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv6ConfigurationExtension:
		soap_serialize_ns2__IPv6ConfigurationExtension(soap, (const struct ns2__IPv6ConfigurationExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__PrefixedIPv6Address:
		soap_serialize_ns2__PrefixedIPv6Address(soap, (const struct ns2__PrefixedIPv6Address *)ptr);
		break;
	case SOAP_TYPE_ns2__PrefixedIPv4Address:
		soap_serialize_ns2__PrefixedIPv4Address(soap, (const struct ns2__PrefixedIPv4Address *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv4Configuration:
		soap_serialize_ns2__IPv4Configuration(soap, (const struct ns2__IPv4Configuration *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv4NetworkInterface:
		soap_serialize_ns2__IPv4NetworkInterface(soap, (const struct ns2__IPv4NetworkInterface *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv6Configuration:
		soap_serialize_ns2__IPv6Configuration(soap, (const struct ns2__IPv6Configuration *)ptr);
		break;
	case SOAP_TYPE_ns2__IPv6NetworkInterface:
		soap_serialize_ns2__IPv6NetworkInterface(soap, (const struct ns2__IPv6NetworkInterface *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterfaceInfo:
		soap_serialize_ns2__NetworkInterfaceInfo(soap, (const struct ns2__NetworkInterfaceInfo *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting:
		soap_serialize_ns2__NetworkInterfaceConnectionSetting(soap, (const struct ns2__NetworkInterfaceConnectionSetting *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterfaceLink:
		soap_serialize_ns2__NetworkInterfaceLink(soap, (const struct ns2__NetworkInterfaceLink *)ptr);
		break;
	case SOAP_TYPE_ns2__NetworkInterfaceExtension:
		soap_serialize_ns2__NetworkInterfaceExtension(soap, (const struct ns2__NetworkInterfaceExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__Scope:
		soap_serialize_ns2__Scope(soap, (const struct ns2__Scope *)ptr);
		break;
	case SOAP_TYPE_ns2__Transport:
		soap_serialize_ns2__Transport(soap, (const struct ns2__Transport *)ptr);
		break;
	case SOAP_TYPE_ns2__IPAddress:
		soap_serialize_ns2__IPAddress(soap, (const struct ns2__IPAddress *)ptr);
		break;
	case SOAP_TYPE_ns2__MulticastConfiguration:
		soap_serialize_ns2__MulticastConfiguration(soap, (const struct ns2__MulticastConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZStatusFilterOptions:
		soap_serialize_ns2__PTZStatusFilterOptions(soap, (const struct ns2__PTZStatusFilterOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__MetadataConfigurationOptions:
		soap_serialize_ns2__MetadataConfigurationOptions(soap, (const struct ns2__MetadataConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy:
		soap_serialize__ns2__EventSubscription_SubscriptionPolicy(soap, (const struct _ns2__EventSubscription_SubscriptionPolicy *)ptr);
		break;
	case SOAP_TYPE_ns2__FilterType:
		soap_serialize_ns2__FilterType(soap, (const struct ns2__FilterType *)ptr);
		break;
	case SOAP_TYPE_ns2__EventSubscription:
		soap_serialize_ns2__EventSubscription(soap, (const struct ns2__EventSubscription *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZFilter:
		soap_serialize_ns2__PTZFilter(soap, (const struct ns2__PTZFilter *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioEncoderConfigurationOption:
		soap_serialize_ns2__AudioEncoderConfigurationOption(soap, (const struct ns2__AudioEncoderConfigurationOption *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioEncoderConfigurationOptions:
		soap_serialize_ns2__AudioEncoderConfigurationOptions(soap, (const struct ns2__AudioEncoderConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioSourceOptionsExtension:
		soap_serialize_ns2__AudioSourceOptionsExtension(soap, (const struct ns2__AudioSourceOptionsExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioSourceConfigurationOptions:
		soap_serialize_ns2__AudioSourceConfigurationOptions(soap, (const struct ns2__AudioSourceConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoEncoderOptionsExtension:
		soap_serialize_ns2__VideoEncoderOptionsExtension(soap, (const struct ns2__VideoEncoderOptionsExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__H264Options:
		soap_serialize_ns2__H264Options(soap, (const struct ns2__H264Options *)ptr);
		break;
	case SOAP_TYPE_ns2__Mpeg4Options:
		soap_serialize_ns2__Mpeg4Options(soap, (const struct ns2__Mpeg4Options *)ptr);
		break;
	case SOAP_TYPE_ns2__JpegOptions:
		soap_serialize_ns2__JpegOptions(soap, (const struct ns2__JpegOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__H264Configuration:
		soap_serialize_ns2__H264Configuration(soap, (const struct ns2__H264Configuration *)ptr);
		break;
	case SOAP_TYPE_ns2__Mpeg4Configuration:
		soap_serialize_ns2__Mpeg4Configuration(soap, (const struct ns2__Mpeg4Configuration *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoRateControl:
		soap_serialize_ns2__VideoRateControl(soap, (const struct ns2__VideoRateControl *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoResolution:
		soap_serialize_ns2__VideoResolution(soap, (const struct ns2__VideoResolution *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension:
		soap_serialize_ns2__VideoSourceConfigurationOptionsExtension(soap, (const struct ns2__VideoSourceConfigurationOptionsExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoSourceConfigurationOptions:
		soap_serialize_ns2__VideoSourceConfigurationOptions(soap, (const struct ns2__VideoSourceConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__ConfigurationEntity:
		soap_serialize_ns2__ConfigurationEntity(soap, (const struct ns2__ConfigurationEntity *)ptr);
		break;
	case SOAP_TYPE_ns2__ProfileExtension:
		soap_serialize_ns2__ProfileExtension(soap, (const struct ns2__ProfileExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__MetadataConfiguration:
		soap_serialize_ns2__MetadataConfiguration(soap, (const struct ns2__MetadataConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__PTZConfiguration:
		soap_serialize_ns2__PTZConfiguration(soap, (const struct ns2__PTZConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoAnalyticsConfiguration:
		soap_serialize_ns2__VideoAnalyticsConfiguration(soap, (const struct ns2__VideoAnalyticsConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioEncoderConfiguration:
		soap_serialize_ns2__AudioEncoderConfiguration(soap, (const struct ns2__AudioEncoderConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__AudioSourceConfiguration:
		soap_serialize_ns2__AudioSourceConfiguration(soap, (const struct ns2__AudioSourceConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoSourceConfiguration:
		soap_serialize_ns2__VideoSourceConfiguration(soap, (const struct ns2__VideoSourceConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoSourceExtension:
		soap_serialize_ns2__VideoSourceExtension(soap, (const struct ns2__VideoSourceExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__IntList:
		soap_serialize_ns2__IntList(soap, (const struct ns2__IntList *)ptr);
		break;
	case SOAP_TYPE_ns2__DurationRange:
		soap_serialize_ns2__DurationRange(soap, (const struct ns2__DurationRange *)ptr);
		break;
	case SOAP_TYPE_ns2__FloatRange:
		soap_serialize_ns2__FloatRange(soap, (const struct ns2__FloatRange *)ptr);
		break;
	case SOAP_TYPE_ns2__IntRange:
		soap_serialize_ns2__IntRange(soap, (const struct ns2__IntRange *)ptr);
		break;
	case SOAP_TYPE_ns2__IntRectangleRange:
		soap_serialize_ns2__IntRectangleRange(soap, (const struct ns2__IntRectangleRange *)ptr);
		break;
	case SOAP_TYPE_ns2__IntRectangle:
		soap_serialize_ns2__IntRectangle(soap, (const struct ns2__IntRectangle *)ptr);
		break;
	case SOAP_TYPE_ns2__DeviceEntity:
		soap_serialize_ns2__DeviceEntity(soap, (const struct ns2__DeviceEntity *)ptr);
		break;
	case SOAP_TYPE_ns2__UserExtension:
		soap_serialize_ns2__UserExtension(soap, (const struct ns2__UserExtension *)ptr);
		break;
	case SOAP_TYPE_ns2__User:
		soap_serialize_ns2__User(soap, (const struct ns2__User *)ptr);
		break;
	case SOAP_TYPE__ns1__GetSnapshotUriResponse:
		soap_serialize__ns1__GetSnapshotUriResponse(soap, (const struct _ns1__GetSnapshotUriResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetSnapshotUri:
		soap_serialize__ns1__GetSnapshotUri(soap, (const struct _ns1__GetSnapshotUri *)ptr);
		break;
	case SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse:
		soap_serialize__ns1__SetVideoEncoderConfigurationResponse(soap, (const struct _ns1__SetVideoEncoderConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoEncoderConfiguration:
		soap_serialize_ns2__VideoEncoderConfiguration(soap, (const struct ns2__VideoEncoderConfiguration *)ptr);
		break;
	case SOAP_TYPE__ns1__SetVideoEncoderConfiguration:
		soap_serialize__ns1__SetVideoEncoderConfiguration(soap, (const struct _ns1__SetVideoEncoderConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns2__VideoEncoderConfigurationOptions:
		soap_serialize_ns2__VideoEncoderConfigurationOptions(soap, (const struct ns2__VideoEncoderConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse:
		soap_serialize__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, (const struct _ns1__GetVideoEncoderConfigurationOptionsResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions:
		soap_serialize__ns1__GetVideoEncoderConfigurationOptions(soap, (const struct _ns1__GetVideoEncoderConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE_ns2__MediaUri:
		soap_serialize_ns2__MediaUri(soap, (const struct ns2__MediaUri *)ptr);
		break;
	case SOAP_TYPE__ns1__GetStreamUriResponse:
		soap_serialize__ns1__GetStreamUriResponse(soap, (const struct _ns1__GetStreamUriResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__StreamSetup:
		soap_serialize_ns2__StreamSetup(soap, (const struct ns2__StreamSetup *)ptr);
		break;
	case SOAP_TYPE__ns1__GetStreamUri:
		soap_serialize__ns1__GetStreamUri(soap, (const struct _ns1__GetStreamUri *)ptr);
		break;
	case SOAP_TYPE_ns2__Profile:
		soap_serialize_ns2__Profile(soap, (const struct ns2__Profile *)ptr);
		break;
	case SOAP_TYPE__ns1__GetProfilesResponse:
		soap_serialize__ns1__GetProfilesResponse(soap, (const struct _ns1__GetProfilesResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetProfiles:
		soap_serialize__ns1__GetProfiles(soap, (const struct _ns1__GetProfiles *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Transform:
		soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Signature:
		soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSnapshotUriResponse:
		soap_serialize_PointerTo_ns1__GetSnapshotUriResponse(soap, (struct _ns1__GetSnapshotUriResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSnapshotUri:
		soap_serialize_PointerTo_ns1__GetSnapshotUri(soap, (struct _ns1__GetSnapshotUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfigurationResponse:
		soap_serialize_PointerTo_ns1__SetVideoEncoderConfigurationResponse(soap, (struct _ns1__SetVideoEncoderConfigurationResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfiguration:
		soap_serialize_PointerTo_ns1__SetVideoEncoderConfiguration(soap, (struct _ns1__SetVideoEncoderConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse:
		soap_serialize_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(soap, (struct _ns1__GetVideoEncoderConfigurationOptionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptions:
		soap_serialize_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, (struct _ns1__GetVideoEncoderConfigurationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStreamUriResponse:
		soap_serialize_PointerTo_ns1__GetStreamUriResponse(soap, (struct _ns1__GetStreamUriResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStreamUri:
		soap_serialize_PointerTo_ns1__GetStreamUri(soap, (struct _ns1__GetStreamUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProfilesResponse:
		soap_serialize_PointerTo_ns1__GetProfilesResponse(soap, (struct _ns1__GetProfilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProfiles:
		soap_serialize_PointerTo_ns1__GetProfiles(soap, (struct _ns1__GetProfiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ObjectExtension:
		soap_serialize_PointerTons2__ObjectExtension(soap, (struct ns2__ObjectExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Behaviour:
		soap_serialize_PointerTons2__Behaviour(soap, (struct ns2__Behaviour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Appearance:
		soap_serialize_PointerTons2__Appearance(soap, (struct ns2__Appearance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZConfigurationExtension:
		soap_serialize_PointerTons2__PTZConfigurationExtension(soap, (struct ns2__PTZConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ZoomLimits:
		soap_serialize_PointerTons2__ZoomLimits(soap, (struct ns2__ZoomLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PanTiltLimits:
		soap_serialize_PointerTons2__PanTiltLimits(soap, (struct ns2__PanTiltLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZSpeed:
		soap_serialize_PointerTons2__PTZSpeed(soap, (struct ns2__PTZSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZNodeExtension:
		soap_serialize_PointerTons2__PTZNodeExtension(soap, (struct ns2__PTZNodeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AuxiliaryData:
		soap_serialize_PointerTons2__AuxiliaryData(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RelayOutputSettings:
		soap_serialize_PointerTons2__RelayOutputSettings(soap, (struct ns2__RelayOutputSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkInterfaceExtension:
		soap_serialize_PointerTons2__NetworkInterfaceExtension(soap, (struct ns2__NetworkInterfaceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv6NetworkInterface:
		soap_serialize_PointerTons2__IPv6NetworkInterface(soap, (struct ns2__IPv6NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv4NetworkInterface:
		soap_serialize_PointerTons2__IPv4NetworkInterface(soap, (struct ns2__IPv4NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkInterfaceLink:
		soap_serialize_PointerTons2__NetworkInterfaceLink(soap, (struct ns2__NetworkInterfaceLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkInterfaceInfo:
		soap_serialize_PointerTons2__NetworkInterfaceInfo(soap, (struct ns2__NetworkInterfaceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventSubscription:
		soap_serialize_PointerTons2__EventSubscription(soap, (struct ns2__EventSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZFilter:
		soap_serialize_PointerTons2__PTZFilter(soap, (struct ns2__PTZFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RuleEngineConfiguration:
		soap_serialize_PointerTons2__RuleEngineConfiguration(soap, (struct ns2__RuleEngineConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AnalyticsEngineConfiguration:
		soap_serialize_PointerTons2__AnalyticsEngineConfiguration(soap, (struct ns2__AnalyticsEngineConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MulticastConfiguration:
		soap_serialize_PointerTons2__MulticastConfiguration(soap, (struct ns2__MulticastConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__H264Configuration:
		soap_serialize_PointerTons2__H264Configuration(soap, (struct ns2__H264Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Mpeg4Configuration:
		soap_serialize_PointerTons2__Mpeg4Configuration(soap, (struct ns2__Mpeg4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoRateControl:
		soap_serialize_PointerTons2__VideoRateControl(soap, (struct ns2__VideoRateControl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IntRectangle:
		soap_serialize_PointerTons2__IntRectangle(soap, (struct ns2__IntRectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoSourceExtension:
		soap_serialize_PointerTons2__VideoSourceExtension(soap, (struct ns2__VideoSourceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImagingSettings:
		soap_serialize_PointerTons2__ImagingSettings(soap, (struct ns2__ImagingSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PropertyOperation:
		soap_serialize_PointerTons2__PropertyOperation(soap, (enum ns2__PropertyOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MessageExtension:
		soap_serialize_PointerTons2__MessageExtension(soap, (struct ns2__MessageExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MetadataType:
		soap_serialize_PointerTons2__MetadataType(soap, (struct ns2__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReferenceParametersType:
		soap_serialize_PointerTons2__ReferenceParametersType(soap, (struct ns2__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AttributedURIType:
		soap_serialize_PointerTons2__AttributedURIType(soap, (struct ns2__AttributedURIType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TopicExpressionType:
		soap_serialize_PointerTons2__TopicExpressionType(soap, (struct ns2__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EndpointReferenceType:
		soap_serialize_PointerTons2__EndpointReferenceType(soap, (struct ns2__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_EventStream:
		soap_serialize_PointerTo__ns2__union_EventStream(soap, (struct __ns2__union_EventStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventStreamExtension:
		soap_serialize_PointerTons2__EventStreamExtension(soap, (struct ns2__EventStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NotificationMessageHolderType:
		soap_serialize_PointerTons2__NotificationMessageHolderType(soap, (struct ns2__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_PTZStream:
		soap_serialize_PointerTo__ns2__union_PTZStream(soap, (struct __ns2__union_PTZStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZStreamExtension:
		soap_serialize_PointerTons2__PTZStreamExtension(soap, (struct ns2__PTZStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_VideoAnalyticsStream:
		soap_serialize_PointerTo__ns2__union_VideoAnalyticsStream(soap, (struct __ns2__union_VideoAnalyticsStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoAnalyticsStreamExtension:
		soap_serialize_PointerTons2__VideoAnalyticsStreamExtension(soap, (struct ns2__VideoAnalyticsStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Frame:
		soap_serialize_PointerTons2__Frame(soap, (struct ns2__Frame *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_MetadataStream:
		soap_serialize_PointerTo__ns2__union_MetadataStream(soap, (struct __ns2__union_MetadataStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MetadataStreamExtension:
		soap_serialize_PointerTons2__MetadataStreamExtension(soap, (struct ns2__MetadataStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventStream:
		soap_serialize_PointerTons2__EventStream(soap, (struct ns2__EventStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZStream:
		soap_serialize_PointerTons2__PTZStream(soap, (struct ns2__PTZStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoAnalyticsStream:
		soap_serialize_PointerTons2__VideoAnalyticsStream(soap, (struct ns2__VideoAnalyticsStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SupportedAnalyticsModulesExtension:
		soap_serialize_PointerTons2__SupportedAnalyticsModulesExtension(soap, (struct ns2__SupportedAnalyticsModulesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SupportedRulesExtension:
		soap_serialize_PointerTons2__SupportedRulesExtension(soap, (struct ns2__SupportedRulesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConfigDescription:
		soap_serialize_PointerTons2__ConfigDescription(soap, (struct ns2__ConfigDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConfigDescriptionExtension:
		soap_serialize_PointerTons2__ConfigDescriptionExtension(soap, (struct ns2__ConfigDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ConfigDescription_Messages:
		soap_serialize_PointerTo_ns2__ConfigDescription_Messages(soap, (struct _ns2__ConfigDescription_Messages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ItemList:
		soap_serialize_PointerTons2__ItemList(soap, (struct ns2__ItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RuleEngineConfigurationExtension:
		soap_serialize_PointerTons2__RuleEngineConfigurationExtension(soap, (struct ns2__RuleEngineConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AnalyticsEngineConfigurationExtension:
		soap_serialize_PointerTons2__AnalyticsEngineConfigurationExtension(soap, (struct ns2__AnalyticsEngineConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Config:
		soap_serialize_PointerTons2__Config(soap, (struct ns2__Config *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ObjectTreeExtension:
		soap_serialize_PointerTons2__ObjectTreeExtension(soap, (struct ns2__ObjectTreeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Merge:
		soap_serialize_PointerTons2__Merge(soap, (struct ns2__Merge *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Split:
		soap_serialize_PointerTons2__Split(soap, (struct ns2__Split *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Rename:
		soap_serialize_PointerTons2__Rename(soap, (struct ns2__Rename *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BehaviourExtension:
		soap_serialize_PointerTons2__BehaviourExtension(soap, (struct ns2__BehaviourExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__Behaviour_Idle:
		soap_serialize_PointerTo_ns2__Behaviour_Idle(soap, (struct _ns2__Behaviour_Idle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__Behaviour_Removed:
		soap_serialize_PointerTo_ns2__Behaviour_Removed(soap, (struct _ns2__Behaviour_Removed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ObjectId:
		soap_serialize_PointerTons2__ObjectId(soap, (struct ns2__ObjectId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FrameExtension:
		soap_serialize_PointerTons2__FrameExtension(soap, (struct ns2__FrameExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ObjectTree:
		soap_serialize_PointerTons2__ObjectTree(soap, (struct ns2__ObjectTree *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Object:
		soap_serialize_PointerTons2__Object(soap, (struct ns2__Object *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZStatus:
		soap_serialize_PointerTons2__PTZStatus(soap, (struct ns2__PTZStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TransformationExtension:
		soap_serialize_PointerTons2__TransformationExtension(soap, (struct ns2__TransformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ClassDescriptorExtension:
		soap_serialize_PointerTons2__ClassDescriptorExtension(soap, (struct ns2__ClassDescriptorExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ClassDescriptor_ClassCandidate:
		soap_serialize_PointerTo_ns2__ClassDescriptor_ClassCandidate(soap, (struct _ns2__ClassDescriptor_ClassCandidate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ColorDescriptorExtension:
		soap_serialize_PointerTons2__ColorDescriptorExtension(soap, (struct ns2__ColorDescriptorExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ColorDescriptor_ColorCluster:
		soap_serialize_PointerTo_ns2__ColorDescriptor_ColorCluster(soap, (struct _ns2__ColorDescriptor_ColorCluster *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ColorCovariance:
		soap_serialize_PointerTons2__ColorCovariance(soap, (struct ns2__ColorCovariance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Color:
		soap_serialize_PointerTons2__Color(soap, (struct ns2__Color *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShapeDescriptorExtension:
		soap_serialize_PointerTons2__ShapeDescriptorExtension(soap, (struct ns2__ShapeDescriptorExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Polygon:
		soap_serialize_PointerTons2__Polygon(soap, (struct ns2__Polygon *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AppearanceExtension:
		soap_serialize_PointerTons2__AppearanceExtension(soap, (struct ns2__AppearanceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ClassDescriptor:
		soap_serialize_PointerTons2__ClassDescriptor(soap, (struct ns2__ClassDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ColorDescriptor:
		soap_serialize_PointerTons2__ColorDescriptor(soap, (struct ns2__ColorDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShapeDescriptor:
		soap_serialize_PointerTons2__ShapeDescriptor(soap, (struct ns2__ShapeDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Transformation:
		soap_serialize_PointerTons2__Transformation(soap, (struct ns2__Transformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Vector:
		soap_serialize_PointerTons2__Vector(soap, (struct ns2__Vector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ItemListDescriptionExtension:
		soap_serialize_PointerTons2__ItemListDescriptionExtension(soap, (struct ns2__ItemListDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ItemListDescription_ElementItemDescription:
		soap_serialize_PointerTo_ns2__ItemListDescription_ElementItemDescription(soap, (struct _ns2__ItemListDescription_ElementItemDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ItemListDescription_SimpleItemDescription:
		soap_serialize_PointerTo_ns2__ItemListDescription_SimpleItemDescription(soap, (struct _ns2__ItemListDescription_SimpleItemDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MessageDescriptionExtension:
		soap_serialize_PointerTons2__MessageDescriptionExtension(soap, (struct ns2__MessageDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ItemListDescription:
		soap_serialize_PointerTons2__ItemListDescription(soap, (struct ns2__ItemListDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ItemListExtension:
		soap_serialize_PointerTons2__ItemListExtension(soap, (struct ns2__ItemListExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ItemList_ElementItem:
		soap_serialize_PointerTo_ns2__ItemList_ElementItem(soap, (struct _ns2__ItemList_ElementItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ItemList_SimpleItem:
		soap_serialize_PointerTo_ns2__ItemList_SimpleItem(soap, (struct _ns2__ItemList_SimpleItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusOptions20Extension:
		soap_serialize_PointerTons2__FocusOptions20Extension(soap, (struct ns2__FocusOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions20Extension:
		soap_serialize_PointerTons2__WhiteBalanceOptions20Extension(soap, (struct ns2__WhiteBalanceOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusConfiguration20Extension:
		soap_serialize_PointerTons2__FocusConfiguration20Extension(soap, (struct ns2__FocusConfiguration20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalance20Extension:
		soap_serialize_PointerTons2__WhiteBalance20Extension(soap, (struct ns2__WhiteBalance20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RelativeFocusOptions20:
		soap_serialize_PointerTons2__RelativeFocusOptions20(soap, (struct ns2__RelativeFocusOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BacklightCompensationMode:
		soap_serialize_PointerTons2__BacklightCompensationMode(soap, (enum ns2__BacklightCompensationMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImagingOptions20Extension:
		soap_serialize_PointerTons2__ImagingOptions20Extension(soap, (struct ns2__ImagingOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions20:
		soap_serialize_PointerTons2__WhiteBalanceOptions20(soap, (struct ns2__WhiteBalanceOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WideDynamicRangeOptions20:
		soap_serialize_PointerTons2__WideDynamicRangeOptions20(soap, (struct ns2__WideDynamicRangeOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusOptions20:
		soap_serialize_PointerTons2__FocusOptions20(soap, (struct ns2__FocusOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExposureOptions20:
		soap_serialize_PointerTons2__ExposureOptions20(soap, (struct ns2__ExposureOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BacklightCompensationOptions20:
		soap_serialize_PointerTons2__BacklightCompensationOptions20(soap, (struct ns2__BacklightCompensationOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImagingSettingsExtension20:
		soap_serialize_PointerTons2__ImagingSettingsExtension20(soap, (struct ns2__ImagingSettingsExtension20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalance20:
		soap_serialize_PointerTons2__WhiteBalance20(soap, (struct ns2__WhiteBalance20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WideDynamicRange20:
		soap_serialize_PointerTons2__WideDynamicRange20(soap, (struct ns2__WideDynamicRange20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusConfiguration20:
		soap_serialize_PointerTons2__FocusConfiguration20(soap, (struct ns2__FocusConfiguration20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Exposure20:
		soap_serialize_PointerTons2__Exposure20(soap, (struct ns2__Exposure20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BacklightCompensation20:
		soap_serialize_PointerTons2__BacklightCompensation20(soap, (struct ns2__BacklightCompensation20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusStatus20Extension:
		soap_serialize_PointerTons2__FocusStatus20Extension(soap, (struct ns2__FocusStatus20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImagingStatus20Extension:
		soap_serialize_PointerTons2__ImagingStatus20Extension(soap, (struct ns2__ImagingStatus20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusStatus20:
		soap_serialize_PointerTons2__FocusStatus20(soap, (struct ns2__FocusStatus20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContinuousFocusOptions:
		soap_serialize_PointerTons2__ContinuousFocusOptions(soap, (struct ns2__ContinuousFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RelativeFocusOptions:
		soap_serialize_PointerTons2__RelativeFocusOptions(soap, (struct ns2__RelativeFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AbsoluteFocusOptions:
		soap_serialize_PointerTons2__AbsoluteFocusOptions(soap, (struct ns2__AbsoluteFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContinuousFocus:
		soap_serialize_PointerTons2__ContinuousFocus(soap, (struct ns2__ContinuousFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RelativeFocus:
		soap_serialize_PointerTons2__RelativeFocus(soap, (struct ns2__RelativeFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AbsoluteFocus:
		soap_serialize_PointerTons2__AbsoluteFocus(soap, (struct ns2__AbsoluteFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalanceMode:
		soap_serialize_PointerTons2__WhiteBalanceMode(soap, (enum ns2__WhiteBalanceMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExposurePriority:
		soap_serialize_PointerTons2__ExposurePriority(soap, (enum ns2__ExposurePriority *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExposureMode:
		soap_serialize_PointerTons2__ExposureMode(soap, (enum ns2__ExposureMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AutoFocusMode:
		soap_serialize_PointerTons2__AutoFocusMode(soap, (enum ns2__AutoFocusMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WideDynamicMode:
		soap_serialize_PointerTons2__WideDynamicMode(soap, (enum ns2__WideDynamicMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalanceOptions:
		soap_serialize_PointerTons2__WhiteBalanceOptions(soap, (struct ns2__WhiteBalanceOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WideDynamicRangeOptions:
		soap_serialize_PointerTons2__WideDynamicRangeOptions(soap, (struct ns2__WideDynamicRangeOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusOptions:
		soap_serialize_PointerTons2__FocusOptions(soap, (struct ns2__FocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExposureOptions:
		soap_serialize_PointerTons2__ExposureOptions(soap, (struct ns2__ExposureOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BacklightCompensationOptions:
		soap_serialize_PointerTons2__BacklightCompensationOptions(soap, (struct ns2__BacklightCompensationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Rectangle:
		soap_serialize_PointerTons2__Rectangle(soap, (struct ns2__Rectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImagingSettingsExtension:
		soap_serialize_PointerTons2__ImagingSettingsExtension(soap, (struct ns2__ImagingSettingsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WhiteBalance:
		soap_serialize_PointerTons2__WhiteBalance(soap, (struct ns2__WhiteBalance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__WideDynamicRange:
		soap_serialize_PointerTons2__WideDynamicRange(soap, (struct ns2__WideDynamicRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IrCutFilterMode:
		soap_serialize_PointerTons2__IrCutFilterMode(soap, (enum ns2__IrCutFilterMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusConfiguration:
		soap_serialize_PointerTons2__FocusConfiguration(soap, (struct ns2__FocusConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Exposure:
		soap_serialize_PointerTons2__Exposure(soap, (struct ns2__Exposure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BacklightCompensation:
		soap_serialize_PointerTons2__BacklightCompensation(soap, (struct ns2__BacklightCompensation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FocusStatus:
		soap_serialize_PointerTons2__FocusStatus(soap, (struct ns2__FocusStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MoveStatus:
		soap_serialize_PointerTons2__MoveStatus(soap, (enum ns2__MoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZMoveStatus:
		soap_serialize_PointerTons2__PTZMoveStatus(soap, (struct ns2__PTZMoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZVector:
		soap_serialize_PointerTons2__PTZVector(soap, (struct ns2__PTZVector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Vector1D:
		soap_serialize_PointerTons2__Vector1D(soap, (struct ns2__Vector1D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Vector2D:
		soap_serialize_PointerTons2__Vector2D(soap, (struct ns2__Vector2D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FloatRange:
		soap_serialize_PointerTons2__FloatRange(soap, (struct ns2__FloatRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZSpacesExtension:
		soap_serialize_PointerTons2__PTZSpacesExtension(soap, (struct ns2__PTZSpacesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Space1DDescription:
		soap_serialize_PointerTons2__Space1DDescription(soap, (struct ns2__Space1DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Space2DDescription:
		soap_serialize_PointerTons2__Space2DDescription(soap, (struct ns2__Space2DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DurationRange:
		soap_serialize_PointerTons2__DurationRange(soap, (struct ns2__DurationRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZSpaces:
		soap_serialize_PointerTons2__PTZSpaces(soap, (struct ns2__PTZSpaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BinaryData:
		soap_serialize_PointerTons2__BinaryData(soap, (struct ns2__BinaryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CertificateGenerationParametersExtension:
		soap_serialize_PointerTons2__CertificateGenerationParametersExtension(soap, (struct ns2__CertificateGenerationParametersExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Date:
		soap_serialize_PointerTons2__Date(soap, (struct ns2__Date *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Time:
		soap_serialize_PointerTons2__Time(soap, (struct ns2__Time *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SystemDateTimeExtension:
		soap_serialize_PointerTons2__SystemDateTimeExtension(soap, (struct ns2__SystemDateTimeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DateTime:
		soap_serialize_PointerTons2__DateTime(soap, (struct ns2__DateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TimeZone:
		soap_serialize_PointerTons2__TimeZone(soap, (struct ns2__TimeZone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AttachmentData:
		soap_serialize_PointerTons2__AttachmentData(soap, (struct ns2__AttachmentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension:
		soap_serialize_PointerTons2__SystemCapabilitiesExtension(soap, (struct ns2__SystemCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OnvifVersion:
		soap_serialize_PointerTons2__OnvifVersion(soap, (struct ns2__OnvifVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension:
		soap_serialize_PointerTons2__SecurityCapabilitiesExtension(soap, (struct ns2__SecurityCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension:
		soap_serialize_PointerTons2__NetworkCapabilitiesExtension(soap, (struct ns2__NetworkCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilitiesExtension:
		soap_serialize_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, (struct ns2__RealTimeStreamingCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ProfileCapabilities:
		soap_serialize_PointerTons2__ProfileCapabilities(soap, (struct ns2__ProfileCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MediaCapabilitiesExtension:
		soap_serialize_PointerTons2__MediaCapabilitiesExtension(soap, (struct ns2__MediaCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilities:
		soap_serialize_PointerTons2__RealTimeStreamingCapabilities(soap, (struct ns2__RealTimeStreamingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IOCapabilitiesExtension:
		soap_serialize_PointerTons2__IOCapabilitiesExtension(soap, (struct ns2__IOCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DeviceCapabilitiesExtension:
		soap_serialize_PointerTons2__DeviceCapabilitiesExtension(soap, (struct ns2__DeviceCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SecurityCapabilities:
		soap_serialize_PointerTons2__SecurityCapabilities(soap, (struct ns2__SecurityCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IOCapabilities:
		soap_serialize_PointerTons2__IOCapabilities(soap, (struct ns2__IOCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SystemCapabilities:
		soap_serialize_PointerTons2__SystemCapabilities(soap, (struct ns2__SystemCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkCapabilities:
		soap_serialize_PointerTons2__NetworkCapabilities(soap, (struct ns2__NetworkCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CapabilitiesExtension:
		soap_serialize_PointerTons2__CapabilitiesExtension(soap, (struct ns2__CapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZCapabilities:
		soap_serialize_PointerTons2__PTZCapabilities(soap, (struct ns2__PTZCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MediaCapabilities:
		soap_serialize_PointerTons2__MediaCapabilities(soap, (struct ns2__MediaCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImagingCapabilities:
		soap_serialize_PointerTons2__ImagingCapabilities(soap, (struct ns2__ImagingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventCapabilities:
		soap_serialize_PointerTons2__EventCapabilities(soap, (struct ns2__EventCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DeviceCapabilities:
		soap_serialize_PointerTons2__DeviceCapabilities(soap, (struct ns2__DeviceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AnalyticsCapabilities:
		soap_serialize_PointerTons2__AnalyticsCapabilities(soap, (struct ns2__AnalyticsCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPAddressFilterExtension:
		soap_serialize_PointerTons2__IPAddressFilterExtension(soap, (struct ns2__IPAddressFilterExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension:
		soap_serialize_PointerTons2__NetworkZeroConfigurationExtension(soap, (struct ns2__NetworkZeroConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv6DHCPConfiguration:
		soap_serialize_PointerTons2__IPv6DHCPConfiguration(soap, (enum ns2__IPv6DHCPConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension:
		soap_serialize_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, (struct ns2__NetworkInterfaceSetConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv6NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, (struct ns2__IPv6NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv4NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, (struct ns2__IPv4NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DynamicDNSInformationExtension:
		soap_serialize_PointerTons2__DynamicDNSInformationExtension(soap, (struct ns2__DynamicDNSInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NTPInformationExtension:
		soap_serialize_PointerTons2__NTPInformationExtension(soap, (struct ns2__NTPInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkHost:
		soap_serialize_PointerTons2__NetworkHost(soap, (struct ns2__NetworkHost *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DNSInformationExtension:
		soap_serialize_PointerTons2__DNSInformationExtension(soap, (struct ns2__DNSInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__token:
		soap_serialize_PointerToxsd__token(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HostnameInformationExtension:
		soap_serialize_PointerTons2__HostnameInformationExtension(soap, (struct ns2__HostnameInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkHostExtension:
		soap_serialize_PointerTons2__NetworkHostExtension(soap, (struct ns2__NetworkHostExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DNSName:
		soap_serialize_PointerTons2__DNSName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv6Address:
		soap_serialize_PointerTons2__IPv6Address(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv4Address:
		soap_serialize_PointerTons2__IPv4Address(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkProtocolExtension:
		soap_serialize_PointerTons2__NetworkProtocolExtension(soap, (struct ns2__NetworkProtocolExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv6ConfigurationExtension:
		soap_serialize_PointerTons2__IPv6ConfigurationExtension(soap, (struct ns2__IPv6ConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PrefixedIPv6Address:
		soap_serialize_PointerTons2__PrefixedIPv6Address(soap, (struct ns2__PrefixedIPv6Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PrefixedIPv4Address:
		soap_serialize_PointerTons2__PrefixedIPv4Address(soap, (struct ns2__PrefixedIPv4Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv4Configuration:
		soap_serialize_PointerTons2__IPv4Configuration(soap, (struct ns2__IPv4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPv6Configuration:
		soap_serialize_PointerTons2__IPv6Configuration(soap, (struct ns2__IPv6Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NetworkInterfaceConnectionSetting:
		soap_serialize_PointerTons2__NetworkInterfaceConnectionSetting(soap, (struct ns2__NetworkInterfaceConnectionSetting *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Transport:
		soap_serialize_PointerTons2__Transport(soap, (struct ns2__Transport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IPAddress:
		soap_serialize_PointerTons2__IPAddress(soap, (struct ns2__IPAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZStatusFilterOptions:
		soap_serialize_PointerTons2__PTZStatusFilterOptions(soap, (struct ns2__PTZStatusFilterOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__EventSubscription_SubscriptionPolicy:
		soap_serialize_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, (struct _ns2__EventSubscription_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FilterType:
		soap_serialize_PointerTons2__FilterType(soap, (struct ns2__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IntList:
		soap_serialize_PointerTons2__IntList(soap, (struct ns2__IntList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOption:
		soap_serialize_PointerTons2__AudioEncoderConfigurationOption(soap, (struct ns2__AudioEncoderConfigurationOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AudioSourceOptionsExtension:
		soap_serialize_PointerTons2__AudioSourceOptionsExtension(soap, (struct ns2__AudioSourceOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__H264Profile:
		soap_serialize_PointerTons2__H264Profile(soap, (enum ns2__H264Profile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Mpeg4Profile:
		soap_serialize_PointerTons2__Mpeg4Profile(soap, (enum ns2__Mpeg4Profile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoResolution:
		soap_serialize_PointerTons2__VideoResolution(soap, (struct ns2__VideoResolution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension:
		soap_serialize_PointerTons2__VideoEncoderOptionsExtension(soap, (struct ns2__VideoEncoderOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__H264Options:
		soap_serialize_PointerTons2__H264Options(soap, (struct ns2__H264Options *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Mpeg4Options:
		soap_serialize_PointerTons2__Mpeg4Options(soap, (struct ns2__Mpeg4Options *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__JpegOptions:
		soap_serialize_PointerTons2__JpegOptions(soap, (struct ns2__JpegOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension:
		soap_serialize_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, (struct ns2__VideoSourceConfigurationOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReferenceToken:
		soap_serialize_PointerTons2__ReferenceToken(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IntRectangleRange:
		soap_serialize_PointerTons2__IntRectangleRange(soap, (struct ns2__IntRectangleRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ProfileExtension:
		soap_serialize_PointerTons2__ProfileExtension(soap, (struct ns2__ProfileExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MetadataConfiguration:
		soap_serialize_PointerTons2__MetadataConfiguration(soap, (struct ns2__MetadataConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PTZConfiguration:
		soap_serialize_PointerTons2__PTZConfiguration(soap, (struct ns2__PTZConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoAnalyticsConfiguration:
		soap_serialize_PointerTons2__VideoAnalyticsConfiguration(soap, (struct ns2__VideoAnalyticsConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AudioEncoderConfiguration:
		soap_serialize_PointerTons2__AudioEncoderConfiguration(soap, (struct ns2__AudioEncoderConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AudioSourceConfiguration:
		soap_serialize_PointerTons2__AudioSourceConfiguration(soap, (struct ns2__AudioSourceConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoSourceConfiguration:
		soap_serialize_PointerTons2__VideoSourceConfiguration(soap, (struct ns2__VideoSourceConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IntRange:
		soap_serialize_PointerTons2__IntRange(soap, (struct ns2__IntRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UserExtension:
		soap_serialize_PointerTons2__UserExtension(soap, (struct ns2__UserExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoEncoderConfiguration:
		soap_serialize_PointerTons2__VideoEncoderConfiguration(soap, (struct ns2__VideoEncoderConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VideoEncoderConfigurationOptions:
		soap_serialize_PointerTons2__VideoEncoderConfigurationOptions(soap, (struct ns2__VideoEncoderConfigurationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MediaUri:
		soap_serialize_PointerTons2__MediaUri(soap, (struct ns2__MediaUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StreamSetup:
		soap_serialize_PointerTons2__StreamSetup(soap, (struct ns2__StreamSetup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Profile:
		soap_serialize_PointerTons2__Profile(soap, (struct ns2__Profile *const*)ptr);
		break;
	case SOAP_TYPE_ns2__TopicNamespaceLocation:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__AuxiliaryData:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__Domain:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__DNSName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__HwAddress:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__IPv6Address:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__IPv4Address:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__Name:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns2__ReferenceToken:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
		soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__TransformsType:
		soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IANA_IfTypes(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IANA_IfTypes
	*a = SOAP_DEFAULT_ns2__IANA_IfTypes;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IANA_IfTypes(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns2__IANA_IfTypes);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns2__IANA_IfTypes(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns2__IANA_IfTypes);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IANA_IfTypes(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IANA_IfTypes);
	if (soap_out_ns2__IANA_IfTypes(soap, tag?tag:"ns2:IANA-IfTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns2__IANA_IfTypes(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IANA_IfTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ClassType(struct soap *soap, enum ns2__ClassType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ClassType
	*a = SOAP_DEFAULT_ns2__ClassType;
#else
	*a = (enum ns2__ClassType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ClassType[] =
{	{ (long)ns2__ClassType__Animal, "Animal" },
	{ (long)ns2__ClassType__Face, "Face" },
	{ (long)ns2__ClassType__Human, "Human" },
	{ (long)ns2__ClassType__Vehical, "Vehical" },
	{ (long)ns2__ClassType__Other, "Other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ClassType2s(struct soap *soap, enum ns2__ClassType n)
{	const char *s = soap_code_str(soap_codes_ns2__ClassType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClassType(struct soap *soap, const char *tag, int id, const enum ns2__ClassType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClassType), type) || soap_send(soap, soap_ns2__ClassType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ClassType(struct soap *soap, const char *s, enum ns2__ClassType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ClassType, s);
	if (map)
		*a = (enum ns2__ClassType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ClassType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ClassType * SOAP_FMAC4 soap_in_ns2__ClassType(struct soap *soap, const char *tag, enum ns2__ClassType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ClassType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClassType, sizeof(enum ns2__ClassType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ClassType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ClassType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClassType, 0, sizeof(enum ns2__ClassType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ClassType(struct soap *soap, const enum ns2__ClassType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ClassType);
	if (soap_out_ns2__ClassType(soap, tag?tag:"ns2:ClassType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ClassType * SOAP_FMAC4 soap_get_ns2__ClassType(struct soap *soap, enum ns2__ClassType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Direction(struct soap *soap, enum ns2__Direction *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Direction
	*a = SOAP_DEFAULT_ns2__Direction;
#else
	*a = (enum ns2__Direction)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__Direction[] =
{	{ (long)ns2__Direction__Left, "Left" },
	{ (long)ns2__Direction__Right, "Right" },
	{ (long)ns2__Direction__Any, "Any" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__Direction2s(struct soap *soap, enum ns2__Direction n)
{	const char *s = soap_code_str(soap_codes_ns2__Direction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Direction(struct soap *soap, const char *tag, int id, const enum ns2__Direction *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Direction), type) || soap_send(soap, soap_ns2__Direction2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__Direction(struct soap *soap, const char *s, enum ns2__Direction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__Direction, s);
	if (map)
		*a = (enum ns2__Direction)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__Direction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__Direction * SOAP_FMAC4 soap_in_ns2__Direction(struct soap *soap, const char *tag, enum ns2__Direction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__Direction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Direction, sizeof(enum ns2__Direction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__Direction(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__Direction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Direction, 0, sizeof(enum ns2__Direction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Direction(struct soap *soap, const enum ns2__Direction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Direction);
	if (soap_out_ns2__Direction(soap, tag?tag:"ns2:Direction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Direction * SOAP_FMAC4 soap_get_ns2__Direction(struct soap *soap, enum ns2__Direction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Direction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PropertyOperation(struct soap *soap, enum ns2__PropertyOperation *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PropertyOperation
	*a = SOAP_DEFAULT_ns2__PropertyOperation;
#else
	*a = (enum ns2__PropertyOperation)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PropertyOperation[] =
{	{ (long)ns2__PropertyOperation__Initialized, "Initialized" },
	{ (long)ns2__PropertyOperation__Deleted, "Deleted" },
	{ (long)ns2__PropertyOperation__Changed, "Changed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PropertyOperation2s(struct soap *soap, enum ns2__PropertyOperation n)
{	const char *s = soap_code_str(soap_codes_ns2__PropertyOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PropertyOperation(struct soap *soap, const char *tag, int id, const enum ns2__PropertyOperation *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PropertyOperation), type) || soap_send(soap, soap_ns2__PropertyOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PropertyOperation(struct soap *soap, const char *s, enum ns2__PropertyOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PropertyOperation, s);
	if (map)
		*a = (enum ns2__PropertyOperation)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PropertyOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PropertyOperation * SOAP_FMAC4 soap_in_ns2__PropertyOperation(struct soap *soap, const char *tag, enum ns2__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PropertyOperation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PropertyOperation, sizeof(enum ns2__PropertyOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PropertyOperation(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PropertyOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PropertyOperation, 0, sizeof(enum ns2__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PropertyOperation(struct soap *soap, const enum ns2__PropertyOperation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PropertyOperation);
	if (soap_out_ns2__PropertyOperation(soap, tag?tag:"ns2:PropertyOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PropertyOperation * SOAP_FMAC4 soap_get_ns2__PropertyOperation(struct soap *soap, enum ns2__PropertyOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IrCutFilterMode(struct soap *soap, enum ns2__IrCutFilterMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IrCutFilterMode
	*a = SOAP_DEFAULT_ns2__IrCutFilterMode;
#else
	*a = (enum ns2__IrCutFilterMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IrCutFilterMode[] =
{	{ (long)ns2__IrCutFilterMode__ON, "ON" },
	{ (long)ns2__IrCutFilterMode__OFF, "OFF" },
	{ (long)ns2__IrCutFilterMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IrCutFilterMode2s(struct soap *soap, enum ns2__IrCutFilterMode n)
{	const char *s = soap_code_str(soap_codes_ns2__IrCutFilterMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IrCutFilterMode(struct soap *soap, const char *tag, int id, const enum ns2__IrCutFilterMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IrCutFilterMode), type) || soap_send(soap, soap_ns2__IrCutFilterMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IrCutFilterMode(struct soap *soap, const char *s, enum ns2__IrCutFilterMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IrCutFilterMode, s);
	if (map)
		*a = (enum ns2__IrCutFilterMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IrCutFilterMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IrCutFilterMode * SOAP_FMAC4 soap_in_ns2__IrCutFilterMode(struct soap *soap, const char *tag, enum ns2__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IrCutFilterMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IrCutFilterMode, sizeof(enum ns2__IrCutFilterMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IrCutFilterMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IrCutFilterMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IrCutFilterMode, 0, sizeof(enum ns2__IrCutFilterMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IrCutFilterMode(struct soap *soap, const enum ns2__IrCutFilterMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IrCutFilterMode);
	if (soap_out_ns2__IrCutFilterMode(soap, tag?tag:"ns2:IrCutFilterMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IrCutFilterMode * SOAP_FMAC4 soap_get_ns2__IrCutFilterMode(struct soap *soap, enum ns2__IrCutFilterMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalanceMode(struct soap *soap, enum ns2__WhiteBalanceMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__WhiteBalanceMode
	*a = SOAP_DEFAULT_ns2__WhiteBalanceMode;
#else
	*a = (enum ns2__WhiteBalanceMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__WhiteBalanceMode[] =
{	{ (long)ns2__WhiteBalanceMode__AUTO, "AUTO" },
	{ (long)ns2__WhiteBalanceMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__WhiteBalanceMode2s(struct soap *soap, enum ns2__WhiteBalanceMode n)
{	const char *s = soap_code_str(soap_codes_ns2__WhiteBalanceMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const enum ns2__WhiteBalanceMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalanceMode), type) || soap_send(soap, soap_ns2__WhiteBalanceMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__WhiteBalanceMode(struct soap *soap, const char *s, enum ns2__WhiteBalanceMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__WhiteBalanceMode, s);
	if (map)
		*a = (enum ns2__WhiteBalanceMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__WhiteBalanceMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__WhiteBalanceMode * SOAP_FMAC4 soap_in_ns2__WhiteBalanceMode(struct soap *soap, const char *tag, enum ns2__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__WhiteBalanceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalanceMode, sizeof(enum ns2__WhiteBalanceMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__WhiteBalanceMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__WhiteBalanceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalanceMode, 0, sizeof(enum ns2__WhiteBalanceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalanceMode(struct soap *soap, const enum ns2__WhiteBalanceMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalanceMode);
	if (soap_out_ns2__WhiteBalanceMode(soap, tag?tag:"ns2:WhiteBalanceMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__WhiteBalanceMode * SOAP_FMAC4 soap_get_ns2__WhiteBalanceMode(struct soap *soap, enum ns2__WhiteBalanceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Enabled(struct soap *soap, enum ns2__Enabled *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Enabled
	*a = SOAP_DEFAULT_ns2__Enabled;
#else
	*a = (enum ns2__Enabled)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__Enabled[] =
{	{ (long)ns2__Enabled__ENABLED, "ENABLED" },
	{ (long)ns2__Enabled__DISABLED, "DISABLED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__Enabled2s(struct soap *soap, enum ns2__Enabled n)
{	const char *s = soap_code_str(soap_codes_ns2__Enabled, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Enabled(struct soap *soap, const char *tag, int id, const enum ns2__Enabled *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Enabled), type) || soap_send(soap, soap_ns2__Enabled2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__Enabled(struct soap *soap, const char *s, enum ns2__Enabled *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__Enabled, s);
	if (map)
		*a = (enum ns2__Enabled)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__Enabled)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__Enabled * SOAP_FMAC4 soap_in_ns2__Enabled(struct soap *soap, const char *tag, enum ns2__Enabled *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__Enabled *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Enabled, sizeof(enum ns2__Enabled), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__Enabled(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__Enabled *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Enabled, 0, sizeof(enum ns2__Enabled), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Enabled(struct soap *soap, const enum ns2__Enabled *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Enabled);
	if (soap_out_ns2__Enabled(soap, tag?tag:"ns2:Enabled", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Enabled * SOAP_FMAC4 soap_get_ns2__Enabled(struct soap *soap, enum ns2__Enabled *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Enabled(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ExposureMode(struct soap *soap, enum ns2__ExposureMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ExposureMode
	*a = SOAP_DEFAULT_ns2__ExposureMode;
#else
	*a = (enum ns2__ExposureMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ExposureMode[] =
{	{ (long)ns2__ExposureMode__AUTO, "AUTO" },
	{ (long)ns2__ExposureMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ExposureMode2s(struct soap *soap, enum ns2__ExposureMode n)
{	const char *s = soap_code_str(soap_codes_ns2__ExposureMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExposureMode(struct soap *soap, const char *tag, int id, const enum ns2__ExposureMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExposureMode), type) || soap_send(soap, soap_ns2__ExposureMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ExposureMode(struct soap *soap, const char *s, enum ns2__ExposureMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ExposureMode, s);
	if (map)
		*a = (enum ns2__ExposureMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ExposureMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ExposureMode * SOAP_FMAC4 soap_in_ns2__ExposureMode(struct soap *soap, const char *tag, enum ns2__ExposureMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ExposureMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExposureMode, sizeof(enum ns2__ExposureMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ExposureMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ExposureMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExposureMode, 0, sizeof(enum ns2__ExposureMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ExposureMode(struct soap *soap, const enum ns2__ExposureMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ExposureMode);
	if (soap_out_ns2__ExposureMode(soap, tag?tag:"ns2:ExposureMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ExposureMode * SOAP_FMAC4 soap_get_ns2__ExposureMode(struct soap *soap, enum ns2__ExposureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ExposurePriority(struct soap *soap, enum ns2__ExposurePriority *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ExposurePriority
	*a = SOAP_DEFAULT_ns2__ExposurePriority;
#else
	*a = (enum ns2__ExposurePriority)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ExposurePriority[] =
{	{ (long)ns2__ExposurePriority__LowNoise, "LowNoise" },
	{ (long)ns2__ExposurePriority__FrameRate, "FrameRate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ExposurePriority2s(struct soap *soap, enum ns2__ExposurePriority n)
{	const char *s = soap_code_str(soap_codes_ns2__ExposurePriority, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExposurePriority(struct soap *soap, const char *tag, int id, const enum ns2__ExposurePriority *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExposurePriority), type) || soap_send(soap, soap_ns2__ExposurePriority2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ExposurePriority(struct soap *soap, const char *s, enum ns2__ExposurePriority *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ExposurePriority, s);
	if (map)
		*a = (enum ns2__ExposurePriority)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ExposurePriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ExposurePriority * SOAP_FMAC4 soap_in_ns2__ExposurePriority(struct soap *soap, const char *tag, enum ns2__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ExposurePriority *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExposurePriority, sizeof(enum ns2__ExposurePriority), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ExposurePriority(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ExposurePriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExposurePriority, 0, sizeof(enum ns2__ExposurePriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ExposurePriority(struct soap *soap, const enum ns2__ExposurePriority *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ExposurePriority);
	if (soap_out_ns2__ExposurePriority(soap, tag?tag:"ns2:ExposurePriority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ExposurePriority * SOAP_FMAC4 soap_get_ns2__ExposurePriority(struct soap *soap, enum ns2__ExposurePriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BacklightCompensationMode(struct soap *soap, enum ns2__BacklightCompensationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__BacklightCompensationMode
	*a = SOAP_DEFAULT_ns2__BacklightCompensationMode;
#else
	*a = (enum ns2__BacklightCompensationMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__BacklightCompensationMode[] =
{	{ (long)ns2__BacklightCompensationMode__OFF, "OFF" },
	{ (long)ns2__BacklightCompensationMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__BacklightCompensationMode2s(struct soap *soap, enum ns2__BacklightCompensationMode n)
{	const char *s = soap_code_str(soap_codes_ns2__BacklightCompensationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const enum ns2__BacklightCompensationMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BacklightCompensationMode), type) || soap_send(soap, soap_ns2__BacklightCompensationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__BacklightCompensationMode(struct soap *soap, const char *s, enum ns2__BacklightCompensationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__BacklightCompensationMode, s);
	if (map)
		*a = (enum ns2__BacklightCompensationMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__BacklightCompensationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__BacklightCompensationMode * SOAP_FMAC4 soap_in_ns2__BacklightCompensationMode(struct soap *soap, const char *tag, enum ns2__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__BacklightCompensationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BacklightCompensationMode, sizeof(enum ns2__BacklightCompensationMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__BacklightCompensationMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__BacklightCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BacklightCompensationMode, 0, sizeof(enum ns2__BacklightCompensationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BacklightCompensationMode(struct soap *soap, const enum ns2__BacklightCompensationMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BacklightCompensationMode);
	if (soap_out_ns2__BacklightCompensationMode(soap, tag?tag:"ns2:BacklightCompensationMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__BacklightCompensationMode * SOAP_FMAC4 soap_get_ns2__BacklightCompensationMode(struct soap *soap, enum ns2__BacklightCompensationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WideDynamicMode(struct soap *soap, enum ns2__WideDynamicMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__WideDynamicMode
	*a = SOAP_DEFAULT_ns2__WideDynamicMode;
#else
	*a = (enum ns2__WideDynamicMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__WideDynamicMode[] =
{	{ (long)ns2__WideDynamicMode__OFF, "OFF" },
	{ (long)ns2__WideDynamicMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__WideDynamicMode2s(struct soap *soap, enum ns2__WideDynamicMode n)
{	const char *s = soap_code_str(soap_codes_ns2__WideDynamicMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WideDynamicMode(struct soap *soap, const char *tag, int id, const enum ns2__WideDynamicMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WideDynamicMode), type) || soap_send(soap, soap_ns2__WideDynamicMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__WideDynamicMode(struct soap *soap, const char *s, enum ns2__WideDynamicMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__WideDynamicMode, s);
	if (map)
		*a = (enum ns2__WideDynamicMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__WideDynamicMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__WideDynamicMode * SOAP_FMAC4 soap_in_ns2__WideDynamicMode(struct soap *soap, const char *tag, enum ns2__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__WideDynamicMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WideDynamicMode, sizeof(enum ns2__WideDynamicMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__WideDynamicMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__WideDynamicMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WideDynamicMode, 0, sizeof(enum ns2__WideDynamicMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WideDynamicMode(struct soap *soap, const enum ns2__WideDynamicMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WideDynamicMode);
	if (soap_out_ns2__WideDynamicMode(soap, tag?tag:"ns2:WideDynamicMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__WideDynamicMode * SOAP_FMAC4 soap_get_ns2__WideDynamicMode(struct soap *soap, enum ns2__WideDynamicMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AutoFocusMode(struct soap *soap, enum ns2__AutoFocusMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AutoFocusMode
	*a = SOAP_DEFAULT_ns2__AutoFocusMode;
#else
	*a = (enum ns2__AutoFocusMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AutoFocusMode[] =
{	{ (long)ns2__AutoFocusMode__AUTO, "AUTO" },
	{ (long)ns2__AutoFocusMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AutoFocusMode2s(struct soap *soap, enum ns2__AutoFocusMode n)
{	const char *s = soap_code_str(soap_codes_ns2__AutoFocusMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AutoFocusMode(struct soap *soap, const char *tag, int id, const enum ns2__AutoFocusMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AutoFocusMode), type) || soap_send(soap, soap_ns2__AutoFocusMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AutoFocusMode(struct soap *soap, const char *s, enum ns2__AutoFocusMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AutoFocusMode, s);
	if (map)
		*a = (enum ns2__AutoFocusMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AutoFocusMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AutoFocusMode * SOAP_FMAC4 soap_in_ns2__AutoFocusMode(struct soap *soap, const char *tag, enum ns2__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AutoFocusMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AutoFocusMode, sizeof(enum ns2__AutoFocusMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AutoFocusMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AutoFocusMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AutoFocusMode, 0, sizeof(enum ns2__AutoFocusMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AutoFocusMode(struct soap *soap, const enum ns2__AutoFocusMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AutoFocusMode);
	if (soap_out_ns2__AutoFocusMode(soap, tag?tag:"ns2:AutoFocusMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AutoFocusMode * SOAP_FMAC4 soap_get_ns2__AutoFocusMode(struct soap *soap, enum ns2__AutoFocusMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MoveStatus(struct soap *soap, enum ns2__MoveStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MoveStatus
	*a = SOAP_DEFAULT_ns2__MoveStatus;
#else
	*a = (enum ns2__MoveStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MoveStatus[] =
{	{ (long)ns2__MoveStatus__IDLE, "IDLE" },
	{ (long)ns2__MoveStatus__MOVING, "MOVING" },
	{ (long)ns2__MoveStatus__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MoveStatus2s(struct soap *soap, enum ns2__MoveStatus n)
{	const char *s = soap_code_str(soap_codes_ns2__MoveStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MoveStatus(struct soap *soap, const char *tag, int id, const enum ns2__MoveStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MoveStatus), type) || soap_send(soap, soap_ns2__MoveStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MoveStatus(struct soap *soap, const char *s, enum ns2__MoveStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MoveStatus, s);
	if (map)
		*a = (enum ns2__MoveStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MoveStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MoveStatus * SOAP_FMAC4 soap_in_ns2__MoveStatus(struct soap *soap, const char *tag, enum ns2__MoveStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MoveStatus, sizeof(enum ns2__MoveStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MoveStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MoveStatus, 0, sizeof(enum ns2__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MoveStatus(struct soap *soap, const enum ns2__MoveStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MoveStatus);
	if (soap_out_ns2__MoveStatus(soap, tag?tag:"ns2:MoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MoveStatus * SOAP_FMAC4 soap_get_ns2__MoveStatus(struct soap *soap, enum ns2__MoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelayMode(struct soap *soap, enum ns2__RelayMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__RelayMode
	*a = SOAP_DEFAULT_ns2__RelayMode;
#else
	*a = (enum ns2__RelayMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__RelayMode[] =
{	{ (long)ns2__RelayMode__Monostable, "Monostable" },
	{ (long)ns2__RelayMode__Bistable, "Bistable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__RelayMode2s(struct soap *soap, enum ns2__RelayMode n)
{	const char *s = soap_code_str(soap_codes_ns2__RelayMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelayMode(struct soap *soap, const char *tag, int id, const enum ns2__RelayMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelayMode), type) || soap_send(soap, soap_ns2__RelayMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__RelayMode(struct soap *soap, const char *s, enum ns2__RelayMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__RelayMode, s);
	if (map)
		*a = (enum ns2__RelayMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__RelayMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__RelayMode * SOAP_FMAC4 soap_in_ns2__RelayMode(struct soap *soap, const char *tag, enum ns2__RelayMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__RelayMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelayMode, sizeof(enum ns2__RelayMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__RelayMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelayMode, 0, sizeof(enum ns2__RelayMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelayMode(struct soap *soap, const enum ns2__RelayMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelayMode);
	if (soap_out_ns2__RelayMode(soap, tag?tag:"ns2:RelayMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RelayMode * SOAP_FMAC4 soap_get_ns2__RelayMode(struct soap *soap, enum ns2__RelayMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelayIdleState(struct soap *soap, enum ns2__RelayIdleState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__RelayIdleState
	*a = SOAP_DEFAULT_ns2__RelayIdleState;
#else
	*a = (enum ns2__RelayIdleState)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__RelayIdleState[] =
{	{ (long)ns2__RelayIdleState__closed, "closed" },
	{ (long)ns2__RelayIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__RelayIdleState2s(struct soap *soap, enum ns2__RelayIdleState n)
{	const char *s = soap_code_str(soap_codes_ns2__RelayIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelayIdleState(struct soap *soap, const char *tag, int id, const enum ns2__RelayIdleState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelayIdleState), type) || soap_send(soap, soap_ns2__RelayIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__RelayIdleState(struct soap *soap, const char *s, enum ns2__RelayIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__RelayIdleState, s);
	if (map)
		*a = (enum ns2__RelayIdleState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__RelayIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__RelayIdleState * SOAP_FMAC4 soap_in_ns2__RelayIdleState(struct soap *soap, const char *tag, enum ns2__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__RelayIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelayIdleState, sizeof(enum ns2__RelayIdleState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__RelayIdleState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelayIdleState, 0, sizeof(enum ns2__RelayIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelayIdleState(struct soap *soap, const enum ns2__RelayIdleState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelayIdleState);
	if (soap_out_ns2__RelayIdleState(soap, tag?tag:"ns2:RelayIdleState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RelayIdleState * SOAP_FMAC4 soap_get_ns2__RelayIdleState(struct soap *soap, enum ns2__RelayIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelayIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelayLogicalState(struct soap *soap, enum ns2__RelayLogicalState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__RelayLogicalState
	*a = SOAP_DEFAULT_ns2__RelayLogicalState;
#else
	*a = (enum ns2__RelayLogicalState)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__RelayLogicalState[] =
{	{ (long)ns2__RelayLogicalState__active, "active" },
	{ (long)ns2__RelayLogicalState__inactive, "inactive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__RelayLogicalState2s(struct soap *soap, enum ns2__RelayLogicalState n)
{	const char *s = soap_code_str(soap_codes_ns2__RelayLogicalState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelayLogicalState(struct soap *soap, const char *tag, int id, const enum ns2__RelayLogicalState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelayLogicalState), type) || soap_send(soap, soap_ns2__RelayLogicalState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__RelayLogicalState(struct soap *soap, const char *s, enum ns2__RelayLogicalState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__RelayLogicalState, s);
	if (map)
		*a = (enum ns2__RelayLogicalState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__RelayLogicalState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__RelayLogicalState * SOAP_FMAC4 soap_in_ns2__RelayLogicalState(struct soap *soap, const char *tag, enum ns2__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__RelayLogicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelayLogicalState, sizeof(enum ns2__RelayLogicalState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__RelayLogicalState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelayLogicalState, 0, sizeof(enum ns2__RelayLogicalState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelayLogicalState(struct soap *soap, const enum ns2__RelayLogicalState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelayLogicalState);
	if (soap_out_ns2__RelayLogicalState(soap, tag?tag:"ns2:RelayLogicalState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RelayLogicalState * SOAP_FMAC4 soap_get_ns2__RelayLogicalState(struct soap *soap, enum ns2__RelayLogicalState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelayLogicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SetDateTimeType(struct soap *soap, enum ns2__SetDateTimeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__SetDateTimeType
	*a = SOAP_DEFAULT_ns2__SetDateTimeType;
#else
	*a = (enum ns2__SetDateTimeType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__SetDateTimeType[] =
{	{ (long)ns2__SetDateTimeType__Manual, "Manual" },
	{ (long)ns2__SetDateTimeType__NTP, "NTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__SetDateTimeType2s(struct soap *soap, enum ns2__SetDateTimeType n)
{	const char *s = soap_code_str(soap_codes_ns2__SetDateTimeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SetDateTimeType(struct soap *soap, const char *tag, int id, const enum ns2__SetDateTimeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SetDateTimeType), type) || soap_send(soap, soap_ns2__SetDateTimeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__SetDateTimeType(struct soap *soap, const char *s, enum ns2__SetDateTimeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__SetDateTimeType, s);
	if (map)
		*a = (enum ns2__SetDateTimeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__SetDateTimeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__SetDateTimeType * SOAP_FMAC4 soap_in_ns2__SetDateTimeType(struct soap *soap, const char *tag, enum ns2__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__SetDateTimeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SetDateTimeType, sizeof(enum ns2__SetDateTimeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__SetDateTimeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SetDateTimeType, 0, sizeof(enum ns2__SetDateTimeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SetDateTimeType(struct soap *soap, const enum ns2__SetDateTimeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SetDateTimeType);
	if (soap_out_ns2__SetDateTimeType(soap, tag?tag:"ns2:SetDateTimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SetDateTimeType * SOAP_FMAC4 soap_get_ns2__SetDateTimeType(struct soap *soap, enum ns2__SetDateTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SetDateTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FactoryDefaultType(struct soap *soap, enum ns2__FactoryDefaultType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__FactoryDefaultType
	*a = SOAP_DEFAULT_ns2__FactoryDefaultType;
#else
	*a = (enum ns2__FactoryDefaultType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__FactoryDefaultType[] =
{	{ (long)ns2__FactoryDefaultType__Hard, "Hard" },
	{ (long)ns2__FactoryDefaultType__Soft, "Soft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__FactoryDefaultType2s(struct soap *soap, enum ns2__FactoryDefaultType n)
{	const char *s = soap_code_str(soap_codes_ns2__FactoryDefaultType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FactoryDefaultType(struct soap *soap, const char *tag, int id, const enum ns2__FactoryDefaultType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FactoryDefaultType), type) || soap_send(soap, soap_ns2__FactoryDefaultType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__FactoryDefaultType(struct soap *soap, const char *s, enum ns2__FactoryDefaultType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__FactoryDefaultType, s);
	if (map)
		*a = (enum ns2__FactoryDefaultType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__FactoryDefaultType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__FactoryDefaultType * SOAP_FMAC4 soap_in_ns2__FactoryDefaultType(struct soap *soap, const char *tag, enum ns2__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__FactoryDefaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FactoryDefaultType, sizeof(enum ns2__FactoryDefaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__FactoryDefaultType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FactoryDefaultType, 0, sizeof(enum ns2__FactoryDefaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FactoryDefaultType(struct soap *soap, const enum ns2__FactoryDefaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FactoryDefaultType);
	if (soap_out_ns2__FactoryDefaultType(soap, tag?tag:"ns2:FactoryDefaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__FactoryDefaultType * SOAP_FMAC4 soap_get_ns2__FactoryDefaultType(struct soap *soap, enum ns2__FactoryDefaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FactoryDefaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SystemLogType(struct soap *soap, enum ns2__SystemLogType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__SystemLogType
	*a = SOAP_DEFAULT_ns2__SystemLogType;
#else
	*a = (enum ns2__SystemLogType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__SystemLogType[] =
{	{ (long)ns2__SystemLogType__System, "System" },
	{ (long)ns2__SystemLogType__Access, "Access" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__SystemLogType2s(struct soap *soap, enum ns2__SystemLogType n)
{	const char *s = soap_code_str(soap_codes_ns2__SystemLogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SystemLogType(struct soap *soap, const char *tag, int id, const enum ns2__SystemLogType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SystemLogType), type) || soap_send(soap, soap_ns2__SystemLogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__SystemLogType(struct soap *soap, const char *s, enum ns2__SystemLogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__SystemLogType, s);
	if (map)
		*a = (enum ns2__SystemLogType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__SystemLogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__SystemLogType * SOAP_FMAC4 soap_in_ns2__SystemLogType(struct soap *soap, const char *tag, enum ns2__SystemLogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__SystemLogType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SystemLogType, sizeof(enum ns2__SystemLogType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__SystemLogType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__SystemLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SystemLogType, 0, sizeof(enum ns2__SystemLogType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SystemLogType(struct soap *soap, const enum ns2__SystemLogType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SystemLogType);
	if (soap_out_ns2__SystemLogType(soap, tag?tag:"ns2:SystemLogType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SystemLogType * SOAP_FMAC4 soap_get_ns2__SystemLogType(struct soap *soap, enum ns2__SystemLogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SystemLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CapabilityCategory(struct soap *soap, enum ns2__CapabilityCategory *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CapabilityCategory
	*a = SOAP_DEFAULT_ns2__CapabilityCategory;
#else
	*a = (enum ns2__CapabilityCategory)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CapabilityCategory[] =
{	{ (long)ns2__CapabilityCategory__All, "All" },
	{ (long)ns2__CapabilityCategory__Analytics, "Analytics" },
	{ (long)ns2__CapabilityCategory__Device, "Device" },
	{ (long)ns2__CapabilityCategory__Events, "Events" },
	{ (long)ns2__CapabilityCategory__Imaging, "Imaging" },
	{ (long)ns2__CapabilityCategory__Media, "Media" },
	{ (long)ns2__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CapabilityCategory2s(struct soap *soap, enum ns2__CapabilityCategory n)
{	const char *s = soap_code_str(soap_codes_ns2__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum ns2__CapabilityCategory *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CapabilityCategory), type) || soap_send(soap, soap_ns2__CapabilityCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CapabilityCategory(struct soap *soap, const char *s, enum ns2__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CapabilityCategory, s);
	if (map)
		*a = (enum ns2__CapabilityCategory)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CapabilityCategory * SOAP_FMAC4 soap_in_ns2__CapabilityCategory(struct soap *soap, const char *tag, enum ns2__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CapabilityCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CapabilityCategory, sizeof(enum ns2__CapabilityCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CapabilityCategory(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CapabilityCategory, 0, sizeof(enum ns2__CapabilityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CapabilityCategory(struct soap *soap, const enum ns2__CapabilityCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CapabilityCategory);
	if (soap_out_ns2__CapabilityCategory(soap, tag?tag:"ns2:CapabilityCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CapabilityCategory * SOAP_FMAC4 soap_get_ns2__CapabilityCategory(struct soap *soap, enum ns2__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DynamicDNSType(struct soap *soap, enum ns2__DynamicDNSType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DynamicDNSType
	*a = SOAP_DEFAULT_ns2__DynamicDNSType;
#else
	*a = (enum ns2__DynamicDNSType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DynamicDNSType[] =
{	{ (long)ns2__DynamicDNSType__NoUpdate, "NoUpdate" },
	{ (long)ns2__DynamicDNSType__ClientUpdates, "ClientUpdates" },
	{ (long)ns2__DynamicDNSType__ServerUpdates, "ServerUpdates" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DynamicDNSType2s(struct soap *soap, enum ns2__DynamicDNSType n)
{	const char *s = soap_code_str(soap_codes_ns2__DynamicDNSType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DynamicDNSType(struct soap *soap, const char *tag, int id, const enum ns2__DynamicDNSType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DynamicDNSType), type) || soap_send(soap, soap_ns2__DynamicDNSType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DynamicDNSType(struct soap *soap, const char *s, enum ns2__DynamicDNSType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DynamicDNSType, s);
	if (map)
		*a = (enum ns2__DynamicDNSType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DynamicDNSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DynamicDNSType * SOAP_FMAC4 soap_in_ns2__DynamicDNSType(struct soap *soap, const char *tag, enum ns2__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DynamicDNSType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DynamicDNSType, sizeof(enum ns2__DynamicDNSType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DynamicDNSType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DynamicDNSType, 0, sizeof(enum ns2__DynamicDNSType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DynamicDNSType(struct soap *soap, const enum ns2__DynamicDNSType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DynamicDNSType);
	if (soap_out_ns2__DynamicDNSType(soap, tag?tag:"ns2:DynamicDNSType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DynamicDNSType * SOAP_FMAC4 soap_get_ns2__DynamicDNSType(struct soap *soap, enum ns2__DynamicDNSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DynamicDNSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPAddressFilterType(struct soap *soap, enum ns2__IPAddressFilterType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IPAddressFilterType
	*a = SOAP_DEFAULT_ns2__IPAddressFilterType;
#else
	*a = (enum ns2__IPAddressFilterType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IPAddressFilterType[] =
{	{ (long)ns2__IPAddressFilterType__Allow, "Allow" },
	{ (long)ns2__IPAddressFilterType__Deny, "Deny" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IPAddressFilterType2s(struct soap *soap, enum ns2__IPAddressFilterType n)
{	const char *s = soap_code_str(soap_codes_ns2__IPAddressFilterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPAddressFilterType(struct soap *soap, const char *tag, int id, const enum ns2__IPAddressFilterType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPAddressFilterType), type) || soap_send(soap, soap_ns2__IPAddressFilterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IPAddressFilterType(struct soap *soap, const char *s, enum ns2__IPAddressFilterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IPAddressFilterType, s);
	if (map)
		*a = (enum ns2__IPAddressFilterType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IPAddressFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IPAddressFilterType * SOAP_FMAC4 soap_in_ns2__IPAddressFilterType(struct soap *soap, const char *tag, enum ns2__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IPAddressFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPAddressFilterType, sizeof(enum ns2__IPAddressFilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IPAddressFilterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPAddressFilterType, 0, sizeof(enum ns2__IPAddressFilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPAddressFilterType(struct soap *soap, const enum ns2__IPAddressFilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPAddressFilterType);
	if (soap_out_ns2__IPAddressFilterType(soap, tag?tag:"ns2:IPAddressFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IPAddressFilterType * SOAP_FMAC4 soap_get_ns2__IPAddressFilterType(struct soap *soap, enum ns2__IPAddressFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPAddressFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPType(struct soap *soap, enum ns2__IPType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IPType
	*a = SOAP_DEFAULT_ns2__IPType;
#else
	*a = (enum ns2__IPType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IPType[] =
{	{ (long)ns2__IPType__IPv4, "IPv4" },
	{ (long)ns2__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IPType2s(struct soap *soap, enum ns2__IPType n)
{	const char *s = soap_code_str(soap_codes_ns2__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPType(struct soap *soap, const char *tag, int id, const enum ns2__IPType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPType), type) || soap_send(soap, soap_ns2__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IPType(struct soap *soap, const char *s, enum ns2__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IPType, s);
	if (map)
		*a = (enum ns2__IPType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IPType * SOAP_FMAC4 soap_in_ns2__IPType(struct soap *soap, const char *tag, enum ns2__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IPType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPType, sizeof(enum ns2__IPType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IPType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPType, 0, sizeof(enum ns2__IPType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPType(struct soap *soap, const enum ns2__IPType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPType);
	if (soap_out_ns2__IPType(soap, tag?tag:"ns2:IPType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IPType * SOAP_FMAC4 soap_get_ns2__IPType(struct soap *soap, enum ns2__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkHostType(struct soap *soap, enum ns2__NetworkHostType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__NetworkHostType
	*a = SOAP_DEFAULT_ns2__NetworkHostType;
#else
	*a = (enum ns2__NetworkHostType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__NetworkHostType[] =
{	{ (long)ns2__NetworkHostType__IPv4, "IPv4" },
	{ (long)ns2__NetworkHostType__IPv6, "IPv6" },
	{ (long)ns2__NetworkHostType__DNS, "DNS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__NetworkHostType2s(struct soap *soap, enum ns2__NetworkHostType n)
{	const char *s = soap_code_str(soap_codes_ns2__NetworkHostType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkHostType(struct soap *soap, const char *tag, int id, const enum ns2__NetworkHostType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkHostType), type) || soap_send(soap, soap_ns2__NetworkHostType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__NetworkHostType(struct soap *soap, const char *s, enum ns2__NetworkHostType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__NetworkHostType, s);
	if (map)
		*a = (enum ns2__NetworkHostType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__NetworkHostType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__NetworkHostType * SOAP_FMAC4 soap_in_ns2__NetworkHostType(struct soap *soap, const char *tag, enum ns2__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__NetworkHostType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkHostType, sizeof(enum ns2__NetworkHostType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__NetworkHostType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkHostType, 0, sizeof(enum ns2__NetworkHostType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkHostType(struct soap *soap, const enum ns2__NetworkHostType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkHostType);
	if (soap_out_ns2__NetworkHostType(soap, tag?tag:"ns2:NetworkHostType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__NetworkHostType * SOAP_FMAC4 soap_get_ns2__NetworkHostType(struct soap *soap, enum ns2__NetworkHostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkHostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkProtocolType(struct soap *soap, enum ns2__NetworkProtocolType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__NetworkProtocolType
	*a = SOAP_DEFAULT_ns2__NetworkProtocolType;
#else
	*a = (enum ns2__NetworkProtocolType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__NetworkProtocolType[] =
{	{ (long)ns2__NetworkProtocolType__HTTP, "HTTP" },
	{ (long)ns2__NetworkProtocolType__HTTPS, "HTTPS" },
	{ (long)ns2__NetworkProtocolType__RTSP, "RTSP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__NetworkProtocolType2s(struct soap *soap, enum ns2__NetworkProtocolType n)
{	const char *s = soap_code_str(soap_codes_ns2__NetworkProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkProtocolType(struct soap *soap, const char *tag, int id, const enum ns2__NetworkProtocolType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkProtocolType), type) || soap_send(soap, soap_ns2__NetworkProtocolType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__NetworkProtocolType(struct soap *soap, const char *s, enum ns2__NetworkProtocolType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__NetworkProtocolType, s);
	if (map)
		*a = (enum ns2__NetworkProtocolType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__NetworkProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__NetworkProtocolType * SOAP_FMAC4 soap_in_ns2__NetworkProtocolType(struct soap *soap, const char *tag, enum ns2__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__NetworkProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkProtocolType, sizeof(enum ns2__NetworkProtocolType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__NetworkProtocolType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkProtocolType, 0, sizeof(enum ns2__NetworkProtocolType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkProtocolType(struct soap *soap, const enum ns2__NetworkProtocolType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkProtocolType);
	if (soap_out_ns2__NetworkProtocolType(soap, tag?tag:"ns2:NetworkProtocolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__NetworkProtocolType * SOAP_FMAC4 soap_get_ns2__NetworkProtocolType(struct soap *soap, enum ns2__NetworkProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv6DHCPConfiguration(struct soap *soap, enum ns2__IPv6DHCPConfiguration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IPv6DHCPConfiguration
	*a = SOAP_DEFAULT_ns2__IPv6DHCPConfiguration;
#else
	*a = (enum ns2__IPv6DHCPConfiguration)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IPv6DHCPConfiguration[] =
{	{ (long)ns2__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (long)ns2__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (long)ns2__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (long)ns2__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IPv6DHCPConfiguration2s(struct soap *soap, enum ns2__IPv6DHCPConfiguration n)
{	const char *s = soap_code_str(soap_codes_ns2__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum ns2__IPv6DHCPConfiguration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv6DHCPConfiguration), type) || soap_send(soap, soap_ns2__IPv6DHCPConfiguration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum ns2__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum ns2__IPv6DHCPConfiguration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_ns2__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum ns2__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IPv6DHCPConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv6DHCPConfiguration, sizeof(enum ns2__IPv6DHCPConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IPv6DHCPConfiguration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv6DHCPConfiguration, 0, sizeof(enum ns2__IPv6DHCPConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv6DHCPConfiguration(struct soap *soap, const enum ns2__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv6DHCPConfiguration);
	if (soap_out_ns2__IPv6DHCPConfiguration(soap, tag?tag:"ns2:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_ns2__IPv6DHCPConfiguration(struct soap *soap, enum ns2__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Duplex(struct soap *soap, enum ns2__Duplex *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Duplex
	*a = SOAP_DEFAULT_ns2__Duplex;
#else
	*a = (enum ns2__Duplex)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__Duplex[] =
{	{ (long)ns2__Duplex__Full, "Full" },
	{ (long)ns2__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__Duplex2s(struct soap *soap, enum ns2__Duplex n)
{	const char *s = soap_code_str(soap_codes_ns2__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Duplex(struct soap *soap, const char *tag, int id, const enum ns2__Duplex *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Duplex), type) || soap_send(soap, soap_ns2__Duplex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__Duplex(struct soap *soap, const char *s, enum ns2__Duplex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__Duplex, s);
	if (map)
		*a = (enum ns2__Duplex)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__Duplex * SOAP_FMAC4 soap_in_ns2__Duplex(struct soap *soap, const char *tag, enum ns2__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__Duplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Duplex, sizeof(enum ns2__Duplex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__Duplex(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Duplex, 0, sizeof(enum ns2__Duplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Duplex(struct soap *soap, const enum ns2__Duplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Duplex);
	if (soap_out_ns2__Duplex(soap, tag?tag:"ns2:Duplex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Duplex * SOAP_FMAC4 soap_get_ns2__Duplex(struct soap *soap, enum ns2__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DiscoveryMode(struct soap *soap, enum ns2__DiscoveryMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DiscoveryMode
	*a = SOAP_DEFAULT_ns2__DiscoveryMode;
#else
	*a = (enum ns2__DiscoveryMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DiscoveryMode[] =
{	{ (long)ns2__DiscoveryMode__Discoverable, "Discoverable" },
	{ (long)ns2__DiscoveryMode__NonDiscoverable, "NonDiscoverable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DiscoveryMode2s(struct soap *soap, enum ns2__DiscoveryMode n)
{	const char *s = soap_code_str(soap_codes_ns2__DiscoveryMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DiscoveryMode(struct soap *soap, const char *tag, int id, const enum ns2__DiscoveryMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DiscoveryMode), type) || soap_send(soap, soap_ns2__DiscoveryMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DiscoveryMode(struct soap *soap, const char *s, enum ns2__DiscoveryMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DiscoveryMode, s);
	if (map)
		*a = (enum ns2__DiscoveryMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DiscoveryMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DiscoveryMode * SOAP_FMAC4 soap_in_ns2__DiscoveryMode(struct soap *soap, const char *tag, enum ns2__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DiscoveryMode, sizeof(enum ns2__DiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DiscoveryMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DiscoveryMode, 0, sizeof(enum ns2__DiscoveryMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DiscoveryMode(struct soap *soap, const enum ns2__DiscoveryMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DiscoveryMode);
	if (soap_out_ns2__DiscoveryMode(soap, tag?tag:"ns2:DiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DiscoveryMode * SOAP_FMAC4 soap_get_ns2__DiscoveryMode(struct soap *soap, enum ns2__DiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ScopeDefinition(struct soap *soap, enum ns2__ScopeDefinition *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ScopeDefinition
	*a = SOAP_DEFAULT_ns2__ScopeDefinition;
#else
	*a = (enum ns2__ScopeDefinition)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ScopeDefinition[] =
{	{ (long)ns2__ScopeDefinition__Fixed, "Fixed" },
	{ (long)ns2__ScopeDefinition__Configurable, "Configurable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ScopeDefinition2s(struct soap *soap, enum ns2__ScopeDefinition n)
{	const char *s = soap_code_str(soap_codes_ns2__ScopeDefinition, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ScopeDefinition(struct soap *soap, const char *tag, int id, const enum ns2__ScopeDefinition *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ScopeDefinition), type) || soap_send(soap, soap_ns2__ScopeDefinition2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ScopeDefinition(struct soap *soap, const char *s, enum ns2__ScopeDefinition *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ScopeDefinition, s);
	if (map)
		*a = (enum ns2__ScopeDefinition)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ScopeDefinition)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ScopeDefinition * SOAP_FMAC4 soap_in_ns2__ScopeDefinition(struct soap *soap, const char *tag, enum ns2__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ScopeDefinition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ScopeDefinition, sizeof(enum ns2__ScopeDefinition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ScopeDefinition(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ScopeDefinition, 0, sizeof(enum ns2__ScopeDefinition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ScopeDefinition(struct soap *soap, const enum ns2__ScopeDefinition *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ScopeDefinition);
	if (soap_out_ns2__ScopeDefinition(soap, tag?tag:"ns2:ScopeDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ScopeDefinition * SOAP_FMAC4 soap_get_ns2__ScopeDefinition(struct soap *soap, enum ns2__ScopeDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ScopeDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TransportProtocol(struct soap *soap, enum ns2__TransportProtocol *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TransportProtocol
	*a = SOAP_DEFAULT_ns2__TransportProtocol;
#else
	*a = (enum ns2__TransportProtocol)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TransportProtocol[] =
{	{ (long)ns2__TransportProtocol__UDP, "UDP" },
	{ (long)ns2__TransportProtocol__TCP, "TCP" },
	{ (long)ns2__TransportProtocol__RTSP, "RTSP" },
	{ (long)ns2__TransportProtocol__HTTP, "HTTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TransportProtocol2s(struct soap *soap, enum ns2__TransportProtocol n)
{	const char *s = soap_code_str(soap_codes_ns2__TransportProtocol, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TransportProtocol(struct soap *soap, const char *tag, int id, const enum ns2__TransportProtocol *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TransportProtocol), type) || soap_send(soap, soap_ns2__TransportProtocol2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TransportProtocol(struct soap *soap, const char *s, enum ns2__TransportProtocol *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TransportProtocol, s);
	if (map)
		*a = (enum ns2__TransportProtocol)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TransportProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TransportProtocol * SOAP_FMAC4 soap_in_ns2__TransportProtocol(struct soap *soap, const char *tag, enum ns2__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TransportProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TransportProtocol, sizeof(enum ns2__TransportProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__TransportProtocol(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TransportProtocol, 0, sizeof(enum ns2__TransportProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TransportProtocol(struct soap *soap, const enum ns2__TransportProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TransportProtocol);
	if (soap_out_ns2__TransportProtocol(soap, tag?tag:"ns2:TransportProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TransportProtocol * SOAP_FMAC4 soap_get_ns2__TransportProtocol(struct soap *soap, enum ns2__TransportProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TransportProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StreamType(struct soap *soap, enum ns2__StreamType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__StreamType
	*a = SOAP_DEFAULT_ns2__StreamType;
#else
	*a = (enum ns2__StreamType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__StreamType[] =
{	{ (long)ns2__StreamType__RTP_Unicast, "RTP-Unicast" },
	{ (long)ns2__StreamType__RTP_Multicast, "RTP-Multicast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__StreamType2s(struct soap *soap, enum ns2__StreamType n)
{	const char *s = soap_code_str(soap_codes_ns2__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StreamType(struct soap *soap, const char *tag, int id, const enum ns2__StreamType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StreamType), type) || soap_send(soap, soap_ns2__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__StreamType(struct soap *soap, const char *s, enum ns2__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__StreamType, s);
	if (map)
		*a = (enum ns2__StreamType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__StreamType * SOAP_FMAC4 soap_in_ns2__StreamType(struct soap *soap, const char *tag, enum ns2__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StreamType, sizeof(enum ns2__StreamType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__StreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StreamType, 0, sizeof(enum ns2__StreamType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StreamType(struct soap *soap, const enum ns2__StreamType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StreamType);
	if (soap_out_ns2__StreamType(soap, tag?tag:"ns2:StreamType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__StreamType * SOAP_FMAC4 soap_get_ns2__StreamType(struct soap *soap, enum ns2__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioEncoding(struct soap *soap, enum ns2__AudioEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AudioEncoding
	*a = SOAP_DEFAULT_ns2__AudioEncoding;
#else
	*a = (enum ns2__AudioEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AudioEncoding[] =
{	{ (long)ns2__AudioEncoding__G711, "G711" },
	{ (long)ns2__AudioEncoding__G726, "G726" },
	{ (long)ns2__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AudioEncoding2s(struct soap *soap, enum ns2__AudioEncoding n)
{	const char *s = soap_code_str(soap_codes_ns2__AudioEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioEncoding(struct soap *soap, const char *tag, int id, const enum ns2__AudioEncoding *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioEncoding), type) || soap_send(soap, soap_ns2__AudioEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AudioEncoding(struct soap *soap, const char *s, enum ns2__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AudioEncoding, s);
	if (map)
		*a = (enum ns2__AudioEncoding)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AudioEncoding * SOAP_FMAC4 soap_in_ns2__AudioEncoding(struct soap *soap, const char *tag, enum ns2__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AudioEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioEncoding, sizeof(enum ns2__AudioEncoding), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AudioEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioEncoding, 0, sizeof(enum ns2__AudioEncoding), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioEncoding(struct soap *soap, const enum ns2__AudioEncoding *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioEncoding);
	if (soap_out_ns2__AudioEncoding(soap, tag?tag:"ns2:AudioEncoding", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AudioEncoding * SOAP_FMAC4 soap_get_ns2__AudioEncoding(struct soap *soap, enum ns2__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__H264Profile(struct soap *soap, enum ns2__H264Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__H264Profile
	*a = SOAP_DEFAULT_ns2__H264Profile;
#else
	*a = (enum ns2__H264Profile)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__H264Profile[] =
{	{ (long)ns2__H264Profile__Baseline, "Baseline" },
	{ (long)ns2__H264Profile__Main, "Main" },
	{ (long)ns2__H264Profile__Extended, "Extended" },
	{ (long)ns2__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__H264Profile2s(struct soap *soap, enum ns2__H264Profile n)
{	const char *s = soap_code_str(soap_codes_ns2__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__H264Profile(struct soap *soap, const char *tag, int id, const enum ns2__H264Profile *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__H264Profile), type) || soap_send(soap, soap_ns2__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__H264Profile(struct soap *soap, const char *s, enum ns2__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__H264Profile, s);
	if (map)
		*a = (enum ns2__H264Profile)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__H264Profile * SOAP_FMAC4 soap_in_ns2__H264Profile(struct soap *soap, const char *tag, enum ns2__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__H264Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__H264Profile, sizeof(enum ns2__H264Profile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__H264Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__H264Profile, 0, sizeof(enum ns2__H264Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__H264Profile(struct soap *soap, const enum ns2__H264Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__H264Profile);
	if (soap_out_ns2__H264Profile(soap, tag?tag:"ns2:H264Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__H264Profile * SOAP_FMAC4 soap_get_ns2__H264Profile(struct soap *soap, enum ns2__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Mpeg4Profile(struct soap *soap, enum ns2__Mpeg4Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Mpeg4Profile
	*a = SOAP_DEFAULT_ns2__Mpeg4Profile;
#else
	*a = (enum ns2__Mpeg4Profile)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__Mpeg4Profile[] =
{	{ (long)ns2__Mpeg4Profile__SP, "SP" },
	{ (long)ns2__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__Mpeg4Profile2s(struct soap *soap, enum ns2__Mpeg4Profile n)
{	const char *s = soap_code_str(soap_codes_ns2__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum ns2__Mpeg4Profile *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Mpeg4Profile), type) || soap_send(soap, soap_ns2__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__Mpeg4Profile(struct soap *soap, const char *s, enum ns2__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__Mpeg4Profile, s);
	if (map)
		*a = (enum ns2__Mpeg4Profile)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__Mpeg4Profile * SOAP_FMAC4 soap_in_ns2__Mpeg4Profile(struct soap *soap, const char *tag, enum ns2__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__Mpeg4Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Mpeg4Profile, sizeof(enum ns2__Mpeg4Profile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__Mpeg4Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Mpeg4Profile, 0, sizeof(enum ns2__Mpeg4Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Mpeg4Profile(struct soap *soap, const enum ns2__Mpeg4Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Mpeg4Profile);
	if (soap_out_ns2__Mpeg4Profile(soap, tag?tag:"ns2:Mpeg4Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Mpeg4Profile * SOAP_FMAC4 soap_get_ns2__Mpeg4Profile(struct soap *soap, enum ns2__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoEncoding(struct soap *soap, enum ns2__VideoEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__VideoEncoding
	*a = SOAP_DEFAULT_ns2__VideoEncoding;
#else
	*a = (enum ns2__VideoEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__VideoEncoding[] =
{	{ (long)ns2__VideoEncoding__JPEG, "JPEG" },
	{ (long)ns2__VideoEncoding__MPEG4, "MPEG4" },
	{ (long)ns2__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__VideoEncoding2s(struct soap *soap, enum ns2__VideoEncoding n)
{	const char *s = soap_code_str(soap_codes_ns2__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoEncoding(struct soap *soap, const char *tag, int id, const enum ns2__VideoEncoding *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoEncoding), type) || soap_send(soap, soap_ns2__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__VideoEncoding(struct soap *soap, const char *s, enum ns2__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__VideoEncoding, s);
	if (map)
		*a = (enum ns2__VideoEncoding)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__VideoEncoding * SOAP_FMAC4 soap_in_ns2__VideoEncoding(struct soap *soap, const char *tag, enum ns2__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__VideoEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoEncoding, sizeof(enum ns2__VideoEncoding), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__VideoEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoEncoding, 0, sizeof(enum ns2__VideoEncoding), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoEncoding(struct soap *soap, const enum ns2__VideoEncoding *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoEncoding);
	if (soap_out_ns2__VideoEncoding(soap, tag?tag:"ns2:VideoEncoding", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__VideoEncoding * SOAP_FMAC4 soap_get_ns2__VideoEncoding(struct soap *soap, enum ns2__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UserLevel(struct soap *soap, enum ns2__UserLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__UserLevel
	*a = SOAP_DEFAULT_ns2__UserLevel;
#else
	*a = (enum ns2__UserLevel)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__UserLevel[] =
{	{ (long)ns2__UserLevel__Administrator, "Administrator" },
	{ (long)ns2__UserLevel__Operator, "Operator" },
	{ (long)ns2__UserLevel__User, "User" },
	{ (long)ns2__UserLevel__Anonymous, "Anonymous" },
	{ (long)ns2__UserLevel__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__UserLevel2s(struct soap *soap, enum ns2__UserLevel n)
{	const char *s = soap_code_str(soap_codes_ns2__UserLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UserLevel(struct soap *soap, const char *tag, int id, const enum ns2__UserLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UserLevel), type) || soap_send(soap, soap_ns2__UserLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__UserLevel(struct soap *soap, const char *s, enum ns2__UserLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__UserLevel, s);
	if (map)
		*a = (enum ns2__UserLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__UserLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__UserLevel * SOAP_FMAC4 soap_in_ns2__UserLevel(struct soap *soap, const char *tag, enum ns2__UserLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__UserLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UserLevel, sizeof(enum ns2__UserLevel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__UserLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UserLevel, 0, sizeof(enum ns2__UserLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UserLevel(struct soap *soap, const enum ns2__UserLevel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UserLevel);
	if (soap_out_ns2__UserLevel(soap, tag?tag:"ns2:UserLevel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__UserLevel * SOAP_FMAC4 soap_get_ns2__UserLevel(struct soap *soap, enum ns2__UserLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UserLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSnapshotUri(struct soap *soap, struct __ns1__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSnapshotUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSnapshotUri(struct soap *soap, const struct __ns1__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSnapshotUri(soap, &a->ns1__GetSnapshotUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct __ns1__GetSnapshotUri *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSnapshotUri(soap, "ns1:GetSnapshotUri", -1, &a->ns1__GetSnapshotUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSnapshotUri * SOAP_FMAC4 soap_in___ns1__GetSnapshotUri(struct soap *soap, const char *tag, struct __ns1__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ns1__GetSnapshotUri = 1;
	short soap_flag;
	a = (struct __ns1__GetSnapshotUri *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSnapshotUri, sizeof(struct __ns1__GetSnapshotUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSnapshotUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSnapshotUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSnapshotUri(soap, "ns1:GetSnapshotUri", &a->ns1__GetSnapshotUri, ""))
				{	soap_flag_ns1__GetSnapshotUri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSnapshotUri(struct soap *soap, const struct __ns1__GetSnapshotUri *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSnapshotUri(soap, tag?tag:"-ns1:GetSnapshotUri", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSnapshotUri * SOAP_FMAC4 soap_get___ns1__GetSnapshotUri(struct soap *soap, struct __ns1__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetVideoEncoderConfiguration(struct soap *soap, struct __ns1__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetVideoEncoderConfiguration(struct soap *soap, const struct __ns1__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetVideoEncoderConfiguration(soap, &a->ns1__SetVideoEncoderConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __ns1__SetVideoEncoderConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetVideoEncoderConfiguration(soap, "ns1:SetVideoEncoderConfiguration", -1, &a->ns1__SetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___ns1__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __ns1__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ns1__SetVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __ns1__SetVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetVideoEncoderConfiguration, sizeof(struct __ns1__SetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetVideoEncoderConfiguration(soap, "ns1:SetVideoEncoderConfiguration", &a->ns1__SetVideoEncoderConfiguration, ""))
				{	soap_flag_ns1__SetVideoEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetVideoEncoderConfiguration(struct soap *soap, const struct __ns1__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetVideoEncoderConfiguration(soap, tag?tag:"-ns1:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___ns1__SetVideoEncoderConfiguration(struct soap *soap, struct __ns1__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __ns1__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVideoEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __ns1__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, &a->ns1__GetVideoEncoderConfigurationOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __ns1__GetVideoEncoderConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, "ns1:GetVideoEncoderConfigurationOptions", -1, &a->ns1__GetVideoEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in___ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __ns1__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ns1__GetVideoEncoderConfigurationOptions = 1;
	short soap_flag;
	a = (struct __ns1__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions, sizeof(struct __ns1__GetVideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVideoEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVideoEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, "ns1:GetVideoEncoderConfigurationOptions", &a->ns1__GetVideoEncoderConfigurationOptions, ""))
				{	soap_flag_ns1__GetVideoEncoderConfigurationOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __ns1__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetVideoEncoderConfigurationOptions(soap, tag?tag:"-ns1:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get___ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __ns1__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStreamUri(struct soap *soap, struct __ns1__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStreamUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStreamUri(struct soap *soap, const struct __ns1__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStreamUri(soap, &a->ns1__GetStreamUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStreamUri(struct soap *soap, const char *tag, int id, const struct __ns1__GetStreamUri *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetStreamUri(soap, "ns1:GetStreamUri", -1, &a->ns1__GetStreamUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStreamUri * SOAP_FMAC4 soap_in___ns1__GetStreamUri(struct soap *soap, const char *tag, struct __ns1__GetStreamUri *a, const char *type)
{
	size_t soap_flag_ns1__GetStreamUri = 1;
	short soap_flag;
	a = (struct __ns1__GetStreamUri *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStreamUri, sizeof(struct __ns1__GetStreamUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStreamUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStreamUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStreamUri(soap, "ns1:GetStreamUri", &a->ns1__GetStreamUri, ""))
				{	soap_flag_ns1__GetStreamUri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStreamUri(struct soap *soap, const struct __ns1__GetStreamUri *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetStreamUri(soap, tag?tag:"-ns1:GetStreamUri", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStreamUri * SOAP_FMAC4 soap_get___ns1__GetStreamUri(struct soap *soap, struct __ns1__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetProfiles(struct soap *soap, struct __ns1__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetProfiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetProfiles(struct soap *soap, const struct __ns1__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetProfiles(soap, &a->ns1__GetProfiles);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetProfiles(struct soap *soap, const char *tag, int id, const struct __ns1__GetProfiles *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetProfiles(soap, "ns1:GetProfiles", -1, &a->ns1__GetProfiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProfiles * SOAP_FMAC4 soap_in___ns1__GetProfiles(struct soap *soap, const char *tag, struct __ns1__GetProfiles *a, const char *type)
{
	size_t soap_flag_ns1__GetProfiles = 1;
	short soap_flag;
	a = (struct __ns1__GetProfiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetProfiles, sizeof(struct __ns1__GetProfiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetProfiles(soap, "ns1:GetProfiles", &a->ns1__GetProfiles, ""))
				{	soap_flag_ns1__GetProfiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetProfiles(struct soap *soap, const struct __ns1__GetProfiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetProfiles(soap, tag?tag:"-ns1:GetProfiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProfiles * SOAP_FMAC4 soap_get___ns1__GetProfiles(struct soap *soap, struct __ns1__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZNode(struct soap *soap, struct ns2__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	a->SupportedPTZSpaces = NULL;
	soap_default_int(soap, &a->MaximumNumberOfPresets);
	soap_default_xsd__boolean(soap, &a->HomeSupported);
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZNode(struct soap *soap, const struct ns2__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_serialize_PointerTons2__PTZSpaces(soap, &a->SupportedPTZSpaces);
	soap_embedded(soap, &a->MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &a->HomeSupported, SOAP_TYPE_xsd__boolean);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_ns2__AuxiliaryData(soap, a->AuxiliaryCommands + i);
		}
	}
	soap_serialize_PointerTons2__PTZNodeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZNode(struct soap *soap, const char *tag, int id, const struct ns2__PTZNode *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZNode), type))
		return soap->error;
	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
		return soap->error;
	if (a->SupportedPTZSpaces)
	{	if (soap_out_PointerTons2__PTZSpaces(soap, "ns2:SupportedPTZSpaces", -1, &a->SupportedPTZSpaces, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:SupportedPTZSpaces"))
		return soap->error;
	if (soap_out_int(soap, "ns2:MaximumNumberOfPresets", -1, &a->MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:HomeSupported", -1, &a->HomeSupported, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
			if (soap_out_ns2__AuxiliaryData(soap, "ns2:AuxiliaryCommands", -1, a->AuxiliaryCommands + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__PTZNodeExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZNode * SOAP_FMAC4 soap_in_ns2__PTZNode(struct soap *soap, const char *tag, struct ns2__PTZNode *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_SupportedPTZSpaces = 1;
	size_t soap_flag_MaximumNumberOfPresets = 1;
	size_t soap_flag_HomeSupported = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZNode, sizeof(struct ns2__PTZNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZNode(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_SupportedPTZSpaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZSpaces(soap, "ns2:SupportedPTZSpaces", &a->SupportedPTZSpaces, "ns2:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces--;
					continue;
				}
			if (soap_flag_MaximumNumberOfPresets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:MaximumNumberOfPresets", &a->MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets--;
					continue;
				}
			if (soap_flag_HomeSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:HomeSupported", &a->HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_new_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__AuxiliaryData(soap, "ns2:AuxiliaryCommands", a->AuxiliaryCommands, "ns2:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZNodeExtension(soap, "ns2:Extension", &a->Extension, "ns2:PTZNodeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
			a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZNode, 0, sizeof(struct ns2__PTZNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedPTZSpaces > 0 || soap_flag_MaximumNumberOfPresets > 0 || soap_flag_HomeSupported > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZNode(struct soap *soap, const struct ns2__PTZNode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZNode);
	if (soap_out_ns2__PTZNode(soap, tag?tag:"ns2:PTZNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZNode * SOAP_FMAC4 soap_get_ns2__PTZNode(struct soap *soap, struct ns2__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelayOutput(struct soap *soap, struct ns2__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	a->Properties = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RelayOutput(struct soap *soap, const struct ns2__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RelayOutputSettings(soap, &a->Properties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelayOutput(struct soap *soap, const char *tag, int id, const struct ns2__RelayOutput *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelayOutput), type))
		return soap->error;
	if (a->Properties)
	{	if (soap_out_PointerTons2__RelayOutputSettings(soap, "ns2:Properties", -1, &a->Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Properties"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RelayOutput * SOAP_FMAC4 soap_in_ns2__RelayOutput(struct soap *soap, const char *tag, struct ns2__RelayOutput *a, const char *type)
{
	size_t soap_flag_Properties = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RelayOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelayOutput, sizeof(struct ns2__RelayOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RelayOutput(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RelayOutputSettings(soap, "ns2:Properties", &a->Properties, "ns2:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelayOutput, 0, sizeof(struct ns2__RelayOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Properties > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelayOutput(struct soap *soap, const struct ns2__RelayOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelayOutput);
	if (soap_out_ns2__RelayOutput(soap, tag?tag:"ns2:RelayOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelayOutput * SOAP_FMAC4 soap_get_ns2__RelayOutput(struct soap *soap, struct ns2__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterface(struct soap *soap, struct ns2__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Info = NULL;
	a->Link = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterface(struct soap *soap, const struct ns2__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTons2__NetworkInterfaceInfo(soap, &a->Info);
	soap_serialize_PointerTons2__NetworkInterfaceLink(soap, &a->Link);
	soap_serialize_PointerTons2__IPv4NetworkInterface(soap, &a->IPv4);
	soap_serialize_PointerTons2__IPv6NetworkInterface(soap, &a->IPv6);
	soap_serialize_PointerTons2__NetworkInterfaceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterface(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterface *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkInterfaceInfo(soap, "ns2:Info", -1, &a->Info, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkInterfaceLink(soap, "ns2:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv4NetworkInterface(soap, "ns2:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv6NetworkInterface(soap, "ns2:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkInterfaceExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterface * SOAP_FMAC4 soap_in_ns2__NetworkInterface(struct soap *soap, const char *tag, struct ns2__NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Info = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterface, sizeof(struct ns2__NetworkInterface), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterface(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceInfo(soap, "ns2:Info", &a->Info, "ns2:NetworkInterfaceInfo"))
				{	soap_flag_Info--;
					continue;
				}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceLink(soap, "ns2:Link", &a->Link, "ns2:NetworkInterfaceLink"))
				{	soap_flag_Link--;
					continue;
				}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv4NetworkInterface(soap, "ns2:IPv4", &a->IPv4, "ns2:IPv4NetworkInterface"))
				{	soap_flag_IPv4--;
					continue;
				}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6NetworkInterface(soap, "ns2:IPv6", &a->IPv6, "ns2:IPv6NetworkInterface"))
				{	soap_flag_IPv6--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceExtension(soap, "ns2:Extension", &a->Extension, "ns2:NetworkInterfaceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterface, 0, sizeof(struct ns2__NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterface(struct soap *soap, const struct ns2__NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterface);
	if (soap_out_ns2__NetworkInterface(soap, tag?tag:"ns2:NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterface * SOAP_FMAC4 soap_get_ns2__NetworkInterface(struct soap *soap, struct ns2__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioSource(struct soap *soap, struct ns2__AudioSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_int(soap, &a->Channels);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioSource(struct soap *soap, const struct ns2__AudioSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Channels, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioSource(struct soap *soap, const char *tag, int id, const struct ns2__AudioSource *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioSource), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:Channels", -1, &a->Channels, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioSource * SOAP_FMAC4 soap_in_ns2__AudioSource(struct soap *soap, const char *tag, struct ns2__AudioSource *a, const char *type)
{
	size_t soap_flag_Channels = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioSource, sizeof(struct ns2__AudioSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioSource(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Channels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Channels", &a->Channels, "xsd:int"))
				{	soap_flag_Channels--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioSource, 0, sizeof(struct ns2__AudioSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioSource(struct soap *soap, const struct ns2__AudioSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioSource);
	if (soap_out_ns2__AudioSource(soap, tag?tag:"ns2:AudioSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioSource * SOAP_FMAC4 soap_get_ns2__AudioSource(struct soap *soap, struct ns2__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoSource(struct soap *soap, struct ns2__VideoSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_float(soap, &a->Framerate);
	a->Resolution = NULL;
	a->Imaging = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoSource(struct soap *soap, const struct ns2__VideoSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTons2__VideoResolution(soap, &a->Resolution);
	soap_serialize_PointerTons2__ImagingSettings(soap, &a->Imaging);
	soap_serialize_PointerTons2__VideoSourceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoSource(struct soap *soap, const char *tag, int id, const struct ns2__VideoSource *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoSource), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Framerate", -1, &a->Framerate, ""))
		return soap->error;
	if (a->Resolution)
	{	if (soap_out_PointerTons2__VideoResolution(soap, "ns2:Resolution", -1, &a->Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Resolution"))
		return soap->error;
	if (soap_out_PointerTons2__ImagingSettings(soap, "ns2:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTons2__VideoSourceExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoSource * SOAP_FMAC4 soap_in_ns2__VideoSource(struct soap *soap, const char *tag, struct ns2__VideoSource *a, const char *type)
{
	size_t soap_flag_Framerate = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoSource, sizeof(struct ns2__VideoSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoSource(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Framerate", &a->Framerate, "xsd:float"))
				{	soap_flag_Framerate--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoResolution(soap, "ns2:Resolution", &a->Resolution, "ns2:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ImagingSettings(soap, "ns2:Imaging", &a->Imaging, "ns2:ImagingSettings"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoSourceExtension(soap, "ns2:Extension", &a->Extension, "ns2:VideoSourceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoSource, 0, sizeof(struct ns2__VideoSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate > 0 || soap_flag_Resolution > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoSource(struct soap *soap, const struct ns2__VideoSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoSource);
	if (soap_out_ns2__VideoSource(soap, tag?tag:"ns2:VideoSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSource * SOAP_FMAC4 soap_get_ns2__VideoSource(struct soap *soap, struct ns2__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__Message(struct soap *soap, struct _ns2__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	soap_default_time(soap, &a->UtcTime);
	a->PropertyOperation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__Message(struct soap *soap, const struct _ns2__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ItemList(soap, &a->Source);
	soap_serialize_PointerTons2__ItemList(soap, &a->Key);
	soap_serialize_PointerTons2__ItemList(soap, &a->Data);
	soap_serialize_PointerTons2__MessageExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__Message(struct soap *soap, const char *tag, int id, const struct _ns2__Message *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->PropertyOperation)
		soap_set_attr(soap, "PropertyOperation", soap_ns2__PropertyOperation2s(soap, *a->PropertyOperation), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__Message), type))
		return soap->error;
	if (soap_out_PointerTons2__ItemList(soap, "ns2:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTons2__ItemList(soap, "ns2:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTons2__ItemList(soap, "ns2:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTons2__MessageExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__Message * SOAP_FMAC4 soap_in__ns2__Message(struct soap *soap, const char *tag, struct _ns2__Message *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__Message, sizeof(struct _ns2__Message), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__Message(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &a->UtcTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "PropertyOperation", 0);
		if (t)
		{
			if (!(a->PropertyOperation = (enum ns2__PropertyOperation *)soap_malloc(soap, sizeof(enum ns2__PropertyOperation))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__PropertyOperation(soap, t, a->PropertyOperation))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemList(soap, "ns2:Source", &a->Source, "ns2:ItemList"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemList(soap, "ns2:Key", &a->Key, "ns2:ItemList"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemList(soap, "ns2:Data", &a->Data, "ns2:ItemList"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MessageExtension(soap, "ns2:Extension", &a->Extension, "ns2:MessageExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__Message, 0, sizeof(struct _ns2__Message), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__Message(struct soap *soap, const struct _ns2__Message *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__Message);
	if (soap_out__ns2__Message(soap, tag?tag:"ns2:Message", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__Message * SOAP_FMAC4 soap_get__ns2__Message(struct soap *soap, struct _ns2__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MetadataType(struct soap *soap, struct ns2__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MetadataType(struct soap *soap, const struct ns2__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MetadataType(struct soap *soap, const char *tag, int id, const struct ns2__MetadataType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MetadataType * SOAP_FMAC4 soap_in_ns2__MetadataType(struct soap *soap, const char *tag, struct ns2__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MetadataType, sizeof(struct ns2__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MetadataType, 0, sizeof(struct ns2__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MetadataType(struct soap *soap, const struct ns2__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MetadataType);
	if (soap_out_ns2__MetadataType(soap, tag?tag:"ns2:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataType * SOAP_FMAC4 soap_get_ns2__MetadataType(struct soap *soap, struct ns2__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ReferenceParametersType(struct soap *soap, struct ns2__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ReferenceParametersType(struct soap *soap, const struct ns2__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct ns2__ReferenceParametersType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ReferenceParametersType * SOAP_FMAC4 soap_in_ns2__ReferenceParametersType(struct soap *soap, const char *tag, struct ns2__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReferenceParametersType, sizeof(struct ns2__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReferenceParametersType, 0, sizeof(struct ns2__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReferenceParametersType(struct soap *soap, const struct ns2__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ReferenceParametersType);
	if (soap_out_ns2__ReferenceParametersType(soap, tag?tag:"ns2:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ReferenceParametersType * SOAP_FMAC4 soap_get_ns2__ReferenceParametersType(struct soap *soap, struct ns2__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AttributedURIType(struct soap *soap, struct ns2__AttributedURIType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->__item);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AttributedURIType(struct soap *soap, const struct ns2__AttributedURIType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AttributedURIType(struct soap *soap, const char *tag, int id, const struct ns2__AttributedURIType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_xsd__anyURI(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct ns2__AttributedURIType * SOAP_FMAC4 soap_in_ns2__AttributedURIType(struct soap *soap, const char *tag, struct ns2__AttributedURIType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct ns2__AttributedURIType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AttributedURIType, sizeof(struct ns2__AttributedURIType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_ns2__AttributedURIType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &a->__item, "ns2:AttributedURIType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AttributedURIType(struct soap *soap, const struct ns2__AttributedURIType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AttributedURIType);
	if (soap_out_ns2__AttributedURIType(soap, tag?tag:"ns2:AttributedURIType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AttributedURIType * SOAP_FMAC4 soap_get_ns2__AttributedURIType(struct soap *soap, struct ns2__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__NotificationMessageHolderType_Message(struct soap *soap, struct _ns2__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__NotificationMessageHolderType_Message(struct soap *soap, const struct _ns2__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const struct _ns2__NotificationMessageHolderType_Message *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__NotificationMessageHolderType_Message), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__ns2__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, struct _ns2__NotificationMessageHolderType_Message *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__NotificationMessageHolderType_Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__NotificationMessageHolderType_Message, sizeof(struct _ns2__NotificationMessageHolderType_Message), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__NotificationMessageHolderType_Message(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__NotificationMessageHolderType_Message, 0, sizeof(struct _ns2__NotificationMessageHolderType_Message), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__NotificationMessageHolderType_Message(struct soap *soap, const struct _ns2__NotificationMessageHolderType_Message *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__NotificationMessageHolderType_Message);
	if (soap_out__ns2__NotificationMessageHolderType_Message(soap, tag?tag:"ns2:NotificationMessageHolderType-Message", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__ns2__NotificationMessageHolderType_Message(struct soap *soap, struct _ns2__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TopicExpressionType(struct soap *soap, struct ns2__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__anyAttribute = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__TopicExpressionType(struct soap *soap, const struct ns2__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct ns2__TopicExpressionType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", a->Dialect, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TopicExpressionType), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__TopicExpressionType * SOAP_FMAC4 soap_in_ns2__TopicExpressionType(struct soap *soap, const char *tag, struct ns2__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TopicExpressionType, sizeof(struct ns2__TopicExpressionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__TopicExpressionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TopicExpressionType, 0, sizeof(struct ns2__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TopicExpressionType(struct soap *soap, const struct ns2__TopicExpressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TopicExpressionType);
	if (soap_out_ns2__TopicExpressionType(soap, tag?tag:"ns2:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__TopicExpressionType * SOAP_FMAC4 soap_get_ns2__TopicExpressionType(struct soap *soap, struct ns2__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EndpointReferenceType(struct soap *soap, struct ns2__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__EndpointReferenceType(struct soap *soap, const struct ns2__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AttributedURIType(soap, &a->Address);
	soap_serialize_PointerTons2__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTons2__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct ns2__EndpointReferenceType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_PointerTons2__AttributedURIType(soap, "ns2:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Address"))
		return soap->error;
	if (soap_out_PointerTons2__ReferenceParametersType(soap, "ns2:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTons2__MetadataType(soap, "ns2:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__EndpointReferenceType * SOAP_FMAC4 soap_in_ns2__EndpointReferenceType(struct soap *soap, const char *tag, struct ns2__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EndpointReferenceType, sizeof(struct ns2__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AttributedURIType(soap, "ns2:Address", &a->Address, "ns2:AttributedURIType"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReferenceParametersType(soap, "ns2:ReferenceParameters", &a->ReferenceParameters, "ns2:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MetadataType(soap, "ns2:Metadata", &a->Metadata, "ns2:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EndpointReferenceType, 0, sizeof(struct ns2__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EndpointReferenceType(struct soap *soap, const struct ns2__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EndpointReferenceType);
	if (soap_out_ns2__EndpointReferenceType(soap, tag?tag:"ns2:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EndpointReferenceType * SOAP_FMAC4 soap_get_ns2__EndpointReferenceType(struct soap *soap, struct ns2__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EventStreamExtension(struct soap *soap, struct ns2__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__EventStreamExtension(struct soap *soap, const struct ns2__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventStreamExtension(struct soap *soap, const char *tag, int id, const struct ns2__EventStreamExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__EventStreamExtension * SOAP_FMAC4 soap_in_ns2__EventStreamExtension(struct soap *soap, const char *tag, struct ns2__EventStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__EventStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventStreamExtension, sizeof(struct ns2__EventStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__EventStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__EventStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventStreamExtension, 0, sizeof(struct ns2__EventStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EventStreamExtension(struct soap *soap, const struct ns2__EventStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EventStreamExtension);
	if (soap_out_ns2__EventStreamExtension(soap, tag?tag:"ns2:EventStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventStreamExtension * SOAP_FMAC4 soap_get_ns2__EventStreamExtension(struct soap *soap, struct ns2__EventStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NotificationMessageHolderType(struct soap *soap, struct ns2__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	soap_default__ns2__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NotificationMessageHolderType(struct soap *soap, const struct ns2__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTons2__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTons2__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize__ns2__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct ns2__NotificationMessageHolderType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTons2__EndpointReferenceType(soap, "ns2:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTons2__TopicExpressionType(soap, "ns2:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTons2__EndpointReferenceType(soap, "ns2:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (soap_out__ns2__NotificationMessageHolderType_Message(soap, "ns2:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NotificationMessageHolderType * SOAP_FMAC4 soap_in_ns2__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns2__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NotificationMessageHolderType, sizeof(struct ns2__NotificationMessageHolderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NotificationMessageHolderType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EndpointReferenceType(soap, "ns2:SubscriptionReference", &a->SubscriptionReference, "ns2:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TopicExpressionType(soap, "ns2:Topic", &a->Topic, "ns2:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EndpointReferenceType(soap, "ns2:ProducerReference", &a->ProducerReference, "ns2:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__NotificationMessageHolderType_Message(soap, "ns2:Message", &a->Message, ""))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NotificationMessageHolderType, 0, sizeof(struct ns2__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NotificationMessageHolderType(struct soap *soap, const struct ns2__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NotificationMessageHolderType);
	if (soap_out_ns2__NotificationMessageHolderType(soap, tag?tag:"ns2:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NotificationMessageHolderType * SOAP_FMAC4 soap_get_ns2__NotificationMessageHolderType(struct soap *soap, struct ns2__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__union_EventStream(struct soap *soap, struct __ns2__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_EventStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__union_EventStream(struct soap *soap, const struct __ns2__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns2__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_EventStream(struct soap *soap, const char *tag, int id, const struct __ns2__union_EventStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out__ns2__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_EventStream * SOAP_FMAC4 soap_in___ns2__union_EventStream(struct soap *soap, const char *tag, struct __ns2__union_EventStream *a, const char *type)
{
	a = (struct __ns2__union_EventStream *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__union_EventStream, sizeof(struct __ns2__union_EventStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__union_EventStream(soap, a);
		if (!soap_in__ns2__union_EventStream(soap, &a->__union_EventStream, &a->union_EventStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__union_EventStream(struct soap *soap, const struct __ns2__union_EventStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__union_EventStream(soap, tag?tag:"-ns2:union-EventStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_EventStream * SOAP_FMAC4 soap_get___ns2__union_EventStream(struct soap *soap, struct __ns2__union_EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZStreamExtension(struct soap *soap, struct ns2__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZStreamExtension(struct soap *soap, const struct ns2__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZStreamExtension(struct soap *soap, const char *tag, int id, const struct ns2__PTZStreamExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZStreamExtension * SOAP_FMAC4 soap_in_ns2__PTZStreamExtension(struct soap *soap, const char *tag, struct ns2__PTZStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZStreamExtension, sizeof(struct ns2__PTZStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZStreamExtension, 0, sizeof(struct ns2__PTZStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZStreamExtension(struct soap *soap, const struct ns2__PTZStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZStreamExtension);
	if (soap_out_ns2__PTZStreamExtension(soap, tag?tag:"ns2:PTZStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStreamExtension * SOAP_FMAC4 soap_get_ns2__PTZStreamExtension(struct soap *soap, struct ns2__PTZStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__union_PTZStream(struct soap *soap, struct __ns2__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PTZStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__union_PTZStream(struct soap *soap, const struct __ns2__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns2__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_PTZStream(struct soap *soap, const char *tag, int id, const struct __ns2__union_PTZStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out__ns2__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_PTZStream * SOAP_FMAC4 soap_in___ns2__union_PTZStream(struct soap *soap, const char *tag, struct __ns2__union_PTZStream *a, const char *type)
{
	a = (struct __ns2__union_PTZStream *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__union_PTZStream, sizeof(struct __ns2__union_PTZStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__union_PTZStream(soap, a);
		if (!soap_in__ns2__union_PTZStream(soap, &a->__union_PTZStream, &a->union_PTZStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__union_PTZStream(struct soap *soap, const struct __ns2__union_PTZStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__union_PTZStream(soap, tag?tag:"-ns2:union-PTZStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_PTZStream * SOAP_FMAC4 soap_get___ns2__union_PTZStream(struct soap *soap, struct __ns2__union_PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoAnalyticsStreamExtension(struct soap *soap, struct ns2__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoAnalyticsStreamExtension(struct soap *soap, const struct ns2__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const struct ns2__VideoAnalyticsStreamExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_in_ns2__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct ns2__VideoAnalyticsStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoAnalyticsStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension, sizeof(struct ns2__VideoAnalyticsStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoAnalyticsStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension, 0, sizeof(struct ns2__VideoAnalyticsStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoAnalyticsStreamExtension(struct soap *soap, const struct ns2__VideoAnalyticsStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension);
	if (soap_out_ns2__VideoAnalyticsStreamExtension(soap, tag?tag:"ns2:VideoAnalyticsStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_get_ns2__VideoAnalyticsStreamExtension(struct soap *soap, struct ns2__VideoAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__union_VideoAnalyticsStream(struct soap *soap, struct __ns2__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_VideoAnalyticsStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__union_VideoAnalyticsStream(struct soap *soap, const struct __ns2__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns2__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct __ns2__union_VideoAnalyticsStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out__ns2__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in___ns2__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __ns2__union_VideoAnalyticsStream *a, const char *type)
{
	a = (struct __ns2__union_VideoAnalyticsStream *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__union_VideoAnalyticsStream, sizeof(struct __ns2__union_VideoAnalyticsStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__union_VideoAnalyticsStream(soap, a);
		if (!soap_in__ns2__union_VideoAnalyticsStream(soap, &a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__union_VideoAnalyticsStream(struct soap *soap, const struct __ns2__union_VideoAnalyticsStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__union_VideoAnalyticsStream(soap, tag?tag:"-ns2:union-VideoAnalyticsStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_VideoAnalyticsStream * SOAP_FMAC4 soap_get___ns2__union_VideoAnalyticsStream(struct soap *soap, struct __ns2__union_VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MetadataStreamExtension(struct soap *soap, struct ns2__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MetadataStreamExtension(struct soap *soap, const struct ns2__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MetadataStreamExtension(struct soap *soap, const char *tag, int id, const struct ns2__MetadataStreamExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MetadataStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MetadataStreamExtension * SOAP_FMAC4 soap_in_ns2__MetadataStreamExtension(struct soap *soap, const char *tag, struct ns2__MetadataStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MetadataStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MetadataStreamExtension, sizeof(struct ns2__MetadataStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MetadataStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MetadataStreamExtension, 0, sizeof(struct ns2__MetadataStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MetadataStreamExtension(struct soap *soap, const struct ns2__MetadataStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MetadataStreamExtension);
	if (soap_out_ns2__MetadataStreamExtension(soap, tag?tag:"ns2:MetadataStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataStreamExtension * SOAP_FMAC4 soap_get_ns2__MetadataStreamExtension(struct soap *soap, struct ns2__MetadataStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EventStream(struct soap *soap, struct ns2__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EventStream = 0;
	a->__union_EventStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__EventStream(struct soap *soap, const struct ns2__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < a->__size_EventStream; i++)
		{
			soap_serialize___ns2__union_EventStream(soap, a->__union_EventStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventStream(struct soap *soap, const char *tag, int id, const struct ns2__EventStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventStream), type))
		return soap->error;
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < a->__size_EventStream; i++)
			if (soap_out___ns2__union_EventStream(soap, "-union-EventStream", -1, a->__union_EventStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__EventStream * SOAP_FMAC4 soap_in_ns2__EventStream(struct soap *soap, const char *tag, struct ns2__EventStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_EventStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__EventStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventStream, sizeof(struct ns2__EventStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__EventStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EventStream == NULL)
				{	if (soap_blist___union_EventStream == NULL)
						soap_blist___union_EventStream = soap_new_block(soap);
					a->__union_EventStream = (struct __ns2__union_EventStream *)soap_push_block(soap, soap_blist___union_EventStream, sizeof(struct __ns2__union_EventStream));
					if (a->__union_EventStream == NULL)
						return NULL;
					soap_default___ns2__union_EventStream(soap, a->__union_EventStream);
				}
				if (soap_in___ns2__union_EventStream(soap, "-union-EventStream", a->__union_EventStream, "-ns2:union-EventStream"))
				{	a->__size_EventStream++;
					a->__union_EventStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EventStream)
			soap_pop_block(soap, soap_blist___union_EventStream);
		if (a->__size_EventStream)
			a->__union_EventStream = (struct __ns2__union_EventStream *)soap_save_block(soap, soap_blist___union_EventStream, NULL, 1);
		else
		{	a->__union_EventStream = NULL;
			if (soap_blist___union_EventStream)
				soap_end_block(soap, soap_blist___union_EventStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__EventStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventStream, 0, sizeof(struct ns2__EventStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EventStream(struct soap *soap, const struct ns2__EventStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EventStream);
	if (soap_out_ns2__EventStream(soap, tag?tag:"ns2:EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventStream * SOAP_FMAC4 soap_get_ns2__EventStream(struct soap *soap, struct ns2__EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZStream(struct soap *soap, struct ns2__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_PTZStream = 0;
	a->__union_PTZStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZStream(struct soap *soap, const struct ns2__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < a->__size_PTZStream; i++)
		{
			soap_serialize___ns2__union_PTZStream(soap, a->__union_PTZStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZStream(struct soap *soap, const char *tag, int id, const struct ns2__PTZStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZStream), type))
		return soap->error;
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < a->__size_PTZStream; i++)
			if (soap_out___ns2__union_PTZStream(soap, "-union-PTZStream", -1, a->__union_PTZStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZStream * SOAP_FMAC4 soap_in_ns2__PTZStream(struct soap *soap, const char *tag, struct ns2__PTZStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_PTZStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZStream, sizeof(struct ns2__PTZStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_PTZStream == NULL)
				{	if (soap_blist___union_PTZStream == NULL)
						soap_blist___union_PTZStream = soap_new_block(soap);
					a->__union_PTZStream = (struct __ns2__union_PTZStream *)soap_push_block(soap, soap_blist___union_PTZStream, sizeof(struct __ns2__union_PTZStream));
					if (a->__union_PTZStream == NULL)
						return NULL;
					soap_default___ns2__union_PTZStream(soap, a->__union_PTZStream);
				}
				if (soap_in___ns2__union_PTZStream(soap, "-union-PTZStream", a->__union_PTZStream, "-ns2:union-PTZStream"))
				{	a->__size_PTZStream++;
					a->__union_PTZStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_PTZStream)
			soap_pop_block(soap, soap_blist___union_PTZStream);
		if (a->__size_PTZStream)
			a->__union_PTZStream = (struct __ns2__union_PTZStream *)soap_save_block(soap, soap_blist___union_PTZStream, NULL, 1);
		else
		{	a->__union_PTZStream = NULL;
			if (soap_blist___union_PTZStream)
				soap_end_block(soap, soap_blist___union_PTZStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZStream, 0, sizeof(struct ns2__PTZStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZStream(struct soap *soap, const struct ns2__PTZStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZStream);
	if (soap_out_ns2__PTZStream(soap, tag?tag:"ns2:PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStream * SOAP_FMAC4 soap_get_ns2__PTZStream(struct soap *soap, struct ns2__PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoAnalyticsStream(struct soap *soap, struct ns2__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_VideoAnalyticsStream = 0;
	a->__union_VideoAnalyticsStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoAnalyticsStream(struct soap *soap, const struct ns2__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < a->__size_VideoAnalyticsStream; i++)
		{
			soap_serialize___ns2__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct ns2__VideoAnalyticsStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoAnalyticsStream), type))
		return soap->error;
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < a->__size_VideoAnalyticsStream; i++)
			if (soap_out___ns2__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", -1, a->__union_VideoAnalyticsStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStream * SOAP_FMAC4 soap_in_ns2__VideoAnalyticsStream(struct soap *soap, const char *tag, struct ns2__VideoAnalyticsStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_VideoAnalyticsStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoAnalyticsStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoAnalyticsStream, sizeof(struct ns2__VideoAnalyticsStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoAnalyticsStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_VideoAnalyticsStream == NULL)
				{	if (soap_blist___union_VideoAnalyticsStream == NULL)
						soap_blist___union_VideoAnalyticsStream = soap_new_block(soap);
					a->__union_VideoAnalyticsStream = (struct __ns2__union_VideoAnalyticsStream *)soap_push_block(soap, soap_blist___union_VideoAnalyticsStream, sizeof(struct __ns2__union_VideoAnalyticsStream));
					if (a->__union_VideoAnalyticsStream == NULL)
						return NULL;
					soap_default___ns2__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream);
				}
				if (soap_in___ns2__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", a->__union_VideoAnalyticsStream, "-ns2:union-VideoAnalyticsStream"))
				{	a->__size_VideoAnalyticsStream++;
					a->__union_VideoAnalyticsStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_VideoAnalyticsStream)
			soap_pop_block(soap, soap_blist___union_VideoAnalyticsStream);
		if (a->__size_VideoAnalyticsStream)
			a->__union_VideoAnalyticsStream = (struct __ns2__union_VideoAnalyticsStream *)soap_save_block(soap, soap_blist___union_VideoAnalyticsStream, NULL, 1);
		else
		{	a->__union_VideoAnalyticsStream = NULL;
			if (soap_blist___union_VideoAnalyticsStream)
				soap_end_block(soap, soap_blist___union_VideoAnalyticsStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoAnalyticsStream, 0, sizeof(struct ns2__VideoAnalyticsStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoAnalyticsStream(struct soap *soap, const struct ns2__VideoAnalyticsStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoAnalyticsStream);
	if (soap_out_ns2__VideoAnalyticsStream(soap, tag?tag:"ns2:VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStream * SOAP_FMAC4 soap_get_ns2__VideoAnalyticsStream(struct soap *soap, struct ns2__VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__union_MetadataStream(struct soap *soap, struct __ns2__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_MetadataStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__union_MetadataStream(struct soap *soap, const struct __ns2__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ns2__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_MetadataStream(struct soap *soap, const char *tag, int id, const struct __ns2__union_MetadataStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out__ns2__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_MetadataStream * SOAP_FMAC4 soap_in___ns2__union_MetadataStream(struct soap *soap, const char *tag, struct __ns2__union_MetadataStream *a, const char *type)
{
	a = (struct __ns2__union_MetadataStream *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__union_MetadataStream, sizeof(struct __ns2__union_MetadataStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__union_MetadataStream(soap, a);
		if (!soap_in__ns2__union_MetadataStream(soap, &a->__union_MetadataStream, &a->union_MetadataStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__union_MetadataStream(struct soap *soap, const struct __ns2__union_MetadataStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__union_MetadataStream(soap, tag?tag:"-ns2:union-MetadataStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__union_MetadataStream * SOAP_FMAC4 soap_get___ns2__union_MetadataStream(struct soap *soap, struct __ns2__union_MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MetadataStream(struct soap *soap, struct ns2__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_MetadataStream = 0;
	a->__union_MetadataStream = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MetadataStream(struct soap *soap, const struct ns2__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < a->__size_MetadataStream; i++)
		{
			soap_serialize___ns2__union_MetadataStream(soap, a->__union_MetadataStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MetadataStream(struct soap *soap, const char *tag, int id, const struct ns2__MetadataStream *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MetadataStream), type))
		return soap->error;
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < a->__size_MetadataStream; i++)
			if (soap_out___ns2__union_MetadataStream(soap, "-union-MetadataStream", -1, a->__union_MetadataStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MetadataStream * SOAP_FMAC4 soap_in_ns2__MetadataStream(struct soap *soap, const char *tag, struct ns2__MetadataStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_MetadataStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MetadataStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MetadataStream, sizeof(struct ns2__MetadataStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MetadataStream(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_MetadataStream == NULL)
				{	if (soap_blist___union_MetadataStream == NULL)
						soap_blist___union_MetadataStream = soap_new_block(soap);
					a->__union_MetadataStream = (struct __ns2__union_MetadataStream *)soap_push_block(soap, soap_blist___union_MetadataStream, sizeof(struct __ns2__union_MetadataStream));
					if (a->__union_MetadataStream == NULL)
						return NULL;
					soap_default___ns2__union_MetadataStream(soap, a->__union_MetadataStream);
				}
				if (soap_in___ns2__union_MetadataStream(soap, "-union-MetadataStream", a->__union_MetadataStream, "-ns2:union-MetadataStream"))
				{	a->__size_MetadataStream++;
					a->__union_MetadataStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_MetadataStream)
			soap_pop_block(soap, soap_blist___union_MetadataStream);
		if (a->__size_MetadataStream)
			a->__union_MetadataStream = (struct __ns2__union_MetadataStream *)soap_save_block(soap, soap_blist___union_MetadataStream, NULL, 1);
		else
		{	a->__union_MetadataStream = NULL;
			if (soap_blist___union_MetadataStream)
				soap_end_block(soap, soap_blist___union_MetadataStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MetadataStream, 0, sizeof(struct ns2__MetadataStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MetadataStream(struct soap *soap, const struct ns2__MetadataStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MetadataStream);
	if (soap_out_ns2__MetadataStream(soap, tag?tag:"ns2:MetadataStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataStream * SOAP_FMAC4 soap_get_ns2__MetadataStream(struct soap *soap, struct ns2__MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SupportedAnalyticsModulesExtension(struct soap *soap, struct ns2__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SupportedAnalyticsModulesExtension(struct soap *soap, const struct ns2__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, const struct ns2__SupportedAnalyticsModulesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_in_ns2__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct ns2__SupportedAnalyticsModulesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SupportedAnalyticsModulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension, sizeof(struct ns2__SupportedAnalyticsModulesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SupportedAnalyticsModulesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension, 0, sizeof(struct ns2__SupportedAnalyticsModulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SupportedAnalyticsModulesExtension(struct soap *soap, const struct ns2__SupportedAnalyticsModulesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension);
	if (soap_out_ns2__SupportedAnalyticsModulesExtension(soap, tag?tag:"ns2:SupportedAnalyticsModulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_get_ns2__SupportedAnalyticsModulesExtension(struct soap *soap, struct ns2__SupportedAnalyticsModulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SupportedAnalyticsModules(struct soap *soap, struct ns2__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModuleContentSchemaLocation = 0;
	a->AnalyticsModuleContentSchemaLocation = NULL;
	a->__sizeAnalyticsModuleDescription = 0;
	a->AnalyticsModuleDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SupportedAnalyticsModules(struct soap *soap, const struct ns2__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->AnalyticsModuleContentSchemaLocation + i);
		}
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleDescription; i++)
		{
			soap_embedded(soap, a->AnalyticsModuleDescription + i, SOAP_TYPE_ns2__ConfigDescription);
			soap_serialize_ns2__ConfigDescription(soap, a->AnalyticsModuleDescription + i);
		}
	}
	soap_serialize_PointerTons2__SupportedAnalyticsModulesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct ns2__SupportedAnalyticsModules *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SupportedAnalyticsModules), type))
		return soap->error;
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleContentSchemaLocation; i++)
			if (soap_out_xsd__anyURI(soap, "ns2:AnalyticsModuleContentSchemaLocation", -1, a->AnalyticsModuleContentSchemaLocation + i, ""))
				return soap->error;
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleDescription; i++)
			if (soap_out_ns2__ConfigDescription(soap, "ns2:AnalyticsModuleDescription", -1, a->AnalyticsModuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__SupportedAnalyticsModulesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SupportedAnalyticsModules * SOAP_FMAC4 soap_in_ns2__SupportedAnalyticsModules(struct soap *soap, const char *tag, struct ns2__SupportedAnalyticsModules *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_AnalyticsModuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SupportedAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SupportedAnalyticsModules, sizeof(struct ns2__SupportedAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SupportedAnalyticsModules(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AnalyticsModuleContentSchemaLocation", 1, NULL))
			{	if (a->AnalyticsModuleContentSchemaLocation == NULL)
				{	if (soap_blist_AnalyticsModuleContentSchemaLocation == NULL)
						soap_blist_AnalyticsModuleContentSchemaLocation = soap_new_block(soap);
					a->AnalyticsModuleContentSchemaLocation = (char **)soap_push_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation, sizeof(char *));
					if (a->AnalyticsModuleContentSchemaLocation == NULL)
						return NULL;
					*a->AnalyticsModuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "ns2:AnalyticsModuleContentSchemaLocation", a->AnalyticsModuleContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeAnalyticsModuleContentSchemaLocation++;
					a->AnalyticsModuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AnalyticsModuleDescription", 1, NULL))
			{	if (a->AnalyticsModuleDescription == NULL)
				{	if (soap_blist_AnalyticsModuleDescription == NULL)
						soap_blist_AnalyticsModuleDescription = soap_new_block(soap);
					a->AnalyticsModuleDescription = (struct ns2__ConfigDescription *)soap_push_block(soap, soap_blist_AnalyticsModuleDescription, sizeof(struct ns2__ConfigDescription));
					if (a->AnalyticsModuleDescription == NULL)
						return NULL;
					soap_default_ns2__ConfigDescription(soap, a->AnalyticsModuleDescription);
				}
				soap_revert(soap);
				if (soap_in_ns2__ConfigDescription(soap, "ns2:AnalyticsModuleDescription", a->AnalyticsModuleDescription, "ns2:ConfigDescription"))
				{	a->__sizeAnalyticsModuleDescription++;
					a->AnalyticsModuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SupportedAnalyticsModulesExtension(soap, "ns2:Extension", &a->Extension, "ns2:SupportedAnalyticsModulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		if (a->__sizeAnalyticsModuleContentSchemaLocation)
			a->AnalyticsModuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation, NULL, 1);
		else
		{	a->AnalyticsModuleContentSchemaLocation = NULL;
			if (soap_blist_AnalyticsModuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		}
		if (a->AnalyticsModuleDescription)
			soap_pop_block(soap, soap_blist_AnalyticsModuleDescription);
		if (a->__sizeAnalyticsModuleDescription)
			a->AnalyticsModuleDescription = (struct ns2__ConfigDescription *)soap_save_block(soap, soap_blist_AnalyticsModuleDescription, NULL, 1);
		else
		{	a->AnalyticsModuleDescription = NULL;
			if (soap_blist_AnalyticsModuleDescription)
				soap_end_block(soap, soap_blist_AnalyticsModuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SupportedAnalyticsModules, 0, sizeof(struct ns2__SupportedAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SupportedAnalyticsModules(struct soap *soap, const struct ns2__SupportedAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SupportedAnalyticsModules);
	if (soap_out_ns2__SupportedAnalyticsModules(soap, tag?tag:"ns2:SupportedAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportedAnalyticsModules * SOAP_FMAC4 soap_get_ns2__SupportedAnalyticsModules(struct soap *soap, struct ns2__SupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SupportedRulesExtension(struct soap *soap, struct ns2__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SupportedRulesExtension(struct soap *soap, const struct ns2__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SupportedRulesExtension(struct soap *soap, const char *tag, int id, const struct ns2__SupportedRulesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SupportedRulesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SupportedRulesExtension * SOAP_FMAC4 soap_in_ns2__SupportedRulesExtension(struct soap *soap, const char *tag, struct ns2__SupportedRulesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SupportedRulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SupportedRulesExtension, sizeof(struct ns2__SupportedRulesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SupportedRulesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SupportedRulesExtension, 0, sizeof(struct ns2__SupportedRulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SupportedRulesExtension(struct soap *soap, const struct ns2__SupportedRulesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SupportedRulesExtension);
	if (soap_out_ns2__SupportedRulesExtension(soap, tag?tag:"ns2:SupportedRulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportedRulesExtension * SOAP_FMAC4 soap_get_ns2__SupportedRulesExtension(struct soap *soap, struct ns2__SupportedRulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SupportedRules(struct soap *soap, struct ns2__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRuleContentSchemaLocation = 0;
	a->RuleContentSchemaLocation = NULL;
	a->__sizeRuleDescription = 0;
	a->RuleDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SupportedRules(struct soap *soap, const struct ns2__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeRuleContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->RuleContentSchemaLocation + i);
		}
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeRuleDescription; i++)
		{
			soap_embedded(soap, a->RuleDescription + i, SOAP_TYPE_ns2__ConfigDescription);
			soap_serialize_ns2__ConfigDescription(soap, a->RuleDescription + i);
		}
	}
	soap_serialize_PointerTons2__SupportedRulesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SupportedRules(struct soap *soap, const char *tag, int id, const struct ns2__SupportedRules *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SupportedRules), type))
		return soap->error;
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeRuleContentSchemaLocation; i++)
			if (soap_out_xsd__anyURI(soap, "ns2:RuleContentSchemaLocation", -1, a->RuleContentSchemaLocation + i, ""))
				return soap->error;
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeRuleDescription; i++)
			if (soap_out_ns2__ConfigDescription(soap, "ns2:RuleDescription", -1, a->RuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__SupportedRulesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SupportedRules * SOAP_FMAC4 soap_in_ns2__SupportedRules(struct soap *soap, const char *tag, struct ns2__SupportedRules *a, const char *type)
{
	struct soap_blist *soap_blist_RuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_RuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SupportedRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SupportedRules, sizeof(struct ns2__SupportedRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SupportedRules(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:RuleContentSchemaLocation", 1, NULL))
			{	if (a->RuleContentSchemaLocation == NULL)
				{	if (soap_blist_RuleContentSchemaLocation == NULL)
						soap_blist_RuleContentSchemaLocation = soap_new_block(soap);
					a->RuleContentSchemaLocation = (char **)soap_push_block(soap, soap_blist_RuleContentSchemaLocation, sizeof(char *));
					if (a->RuleContentSchemaLocation == NULL)
						return NULL;
					*a->RuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "ns2:RuleContentSchemaLocation", a->RuleContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeRuleContentSchemaLocation++;
					a->RuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:RuleDescription", 1, NULL))
			{	if (a->RuleDescription == NULL)
				{	if (soap_blist_RuleDescription == NULL)
						soap_blist_RuleDescription = soap_new_block(soap);
					a->RuleDescription = (struct ns2__ConfigDescription *)soap_push_block(soap, soap_blist_RuleDescription, sizeof(struct ns2__ConfigDescription));
					if (a->RuleDescription == NULL)
						return NULL;
					soap_default_ns2__ConfigDescription(soap, a->RuleDescription);
				}
				soap_revert(soap);
				if (soap_in_ns2__ConfigDescription(soap, "ns2:RuleDescription", a->RuleDescription, "ns2:ConfigDescription"))
				{	a->__sizeRuleDescription++;
					a->RuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SupportedRulesExtension(soap, "ns2:Extension", &a->Extension, "ns2:SupportedRulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_RuleContentSchemaLocation);
		if (a->__sizeRuleContentSchemaLocation)
			a->RuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_RuleContentSchemaLocation, NULL, 1);
		else
		{	a->RuleContentSchemaLocation = NULL;
			if (soap_blist_RuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_RuleContentSchemaLocation);
		}
		if (a->RuleDescription)
			soap_pop_block(soap, soap_blist_RuleDescription);
		if (a->__sizeRuleDescription)
			a->RuleDescription = (struct ns2__ConfigDescription *)soap_save_block(soap, soap_blist_RuleDescription, NULL, 1);
		else
		{	a->RuleDescription = NULL;
			if (soap_blist_RuleDescription)
				soap_end_block(soap, soap_blist_RuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SupportedRules, 0, sizeof(struct ns2__SupportedRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SupportedRules(struct soap *soap, const struct ns2__SupportedRules *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SupportedRules);
	if (soap_out_ns2__SupportedRules(soap, tag?tag:"ns2:SupportedRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportedRules * SOAP_FMAC4 soap_get_ns2__SupportedRules(struct soap *soap, struct ns2__SupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConfigDescriptionExtension(struct soap *soap, struct ns2__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConfigDescriptionExtension(struct soap *soap, const struct ns2__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, const struct ns2__ConfigDescriptionExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConfigDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConfigDescriptionExtension * SOAP_FMAC4 soap_in_ns2__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct ns2__ConfigDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConfigDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConfigDescriptionExtension, sizeof(struct ns2__ConfigDescriptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConfigDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConfigDescriptionExtension, 0, sizeof(struct ns2__ConfigDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConfigDescriptionExtension(struct soap *soap, const struct ns2__ConfigDescriptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConfigDescriptionExtension);
	if (soap_out_ns2__ConfigDescriptionExtension(soap, tag?tag:"ns2:ConfigDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConfigDescriptionExtension * SOAP_FMAC4 soap_get_ns2__ConfigDescriptionExtension(struct soap *soap, struct ns2__ConfigDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ConfigDescription_Messages(struct soap *soap, struct _ns2__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	a->__anyAttribute = NULL;
	soap_default_string(soap, &a->ParentTopic);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ConfigDescription_Messages(struct soap *soap, const struct _ns2__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTons2__MessageDescriptionExtension(soap, &a->Extension);
	soap_serialize_string(soap, &a->ParentTopic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const struct _ns2__ConfigDescription_Messages *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ConfigDescription_Messages), type))
		return soap->error;
	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTons2__MessageDescriptionExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->ParentTopic)
	{	if (soap_out_string(soap, "ns2:ParentTopic", -1, &a->ParentTopic, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ParentTopic"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ConfigDescription_Messages * SOAP_FMAC4 soap_in__ns2__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _ns2__ConfigDescription_Messages *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_ParentTopic = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ConfigDescription_Messages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ConfigDescription_Messages, sizeof(struct _ns2__ConfigDescription_Messages), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ConfigDescription_Messages(soap, a);
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Source", &a->Source, "ns2:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Key", &a->Key, "ns2:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Data", &a->Data, "ns2:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MessageDescriptionExtension(soap, "ns2:Extension", &a->Extension, "ns2:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap_flag_ParentTopic && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:ParentTopic", &a->ParentTopic, "xsd:string"))
				{	soap_flag_ParentTopic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ConfigDescription_Messages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ConfigDescription_Messages, 0, sizeof(struct _ns2__ConfigDescription_Messages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ParentTopic > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ConfigDescription_Messages(struct soap *soap, const struct _ns2__ConfigDescription_Messages *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ConfigDescription_Messages);
	if (soap_out__ns2__ConfigDescription_Messages(soap, tag?tag:"ns2:ConfigDescription-Messages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ConfigDescription_Messages * SOAP_FMAC4 soap_get__ns2__ConfigDescription_Messages(struct soap *soap, struct _ns2__ConfigDescription_Messages *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConfigDescription(struct soap *soap, struct ns2__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	a->__sizeMessages = 0;
	a->Messages = NULL;
	a->Extension = NULL;
	soap_default__QName(soap, &a->Name);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConfigDescription(struct soap *soap, const struct ns2__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Parameters);
	if (a->Messages)
	{	int i;
		for (i = 0; i < a->__sizeMessages; i++)
		{
			soap_embedded(soap, a->Messages + i, SOAP_TYPE__ns2__ConfigDescription_Messages);
			soap_serialize__ns2__ConfigDescription_Messages(soap, a->Messages + i);
		}
	}
	soap_serialize_PointerTons2__ConfigDescriptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConfigDescription(struct soap *soap, const char *tag, int id, const struct ns2__ConfigDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Name)
		soap_set_attr(soap, "Name", soap_QName2s(soap, a->Name), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConfigDescription), type))
		return soap->error;
	if (a->Parameters)
	{	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Parameters", -1, &a->Parameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Parameters"))
		return soap->error;
	if (a->Messages)
	{	int i;
		for (i = 0; i < a->__sizeMessages; i++)
			if (soap_out__ns2__ConfigDescription_Messages(soap, "ns2:Messages", -1, a->Messages + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ConfigDescriptionExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConfigDescription * SOAP_FMAC4 soap_in_ns2__ConfigDescription(struct soap *soap, const char *tag, struct ns2__ConfigDescription *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	struct soap_blist *soap_blist_Messages = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConfigDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConfigDescription, sizeof(struct ns2__ConfigDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConfigDescription(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Parameters", &a->Parameters, "ns2:ItemListDescription"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Messages", 1, NULL))
			{	if (a->Messages == NULL)
				{	if (soap_blist_Messages == NULL)
						soap_blist_Messages = soap_new_block(soap);
					a->Messages = (struct _ns2__ConfigDescription_Messages *)soap_push_block(soap, soap_blist_Messages, sizeof(struct _ns2__ConfigDescription_Messages));
					if (a->Messages == NULL)
						return NULL;
					soap_default__ns2__ConfigDescription_Messages(soap, a->Messages);
				}
				soap_revert(soap);
				if (soap_in__ns2__ConfigDescription_Messages(soap, "ns2:Messages", a->Messages, ""))
				{	a->__sizeMessages++;
					a->Messages = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConfigDescriptionExtension(soap, "ns2:Extension", &a->Extension, "ns2:ConfigDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Messages)
			soap_pop_block(soap, soap_blist_Messages);
		if (a->__sizeMessages)
			a->Messages = (struct _ns2__ConfigDescription_Messages *)soap_save_block(soap, soap_blist_Messages, NULL, 1);
		else
		{	a->Messages = NULL;
			if (soap_blist_Messages)
				soap_end_block(soap, soap_blist_Messages);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConfigDescription, 0, sizeof(struct ns2__ConfigDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConfigDescription(struct soap *soap, const struct ns2__ConfigDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConfigDescription);
	if (soap_out_ns2__ConfigDescription(soap, tag?tag:"ns2:ConfigDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConfigDescription * SOAP_FMAC4 soap_get_ns2__ConfigDescription(struct soap *soap, struct ns2__ConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RuleEngineConfigurationExtension(struct soap *soap, struct ns2__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RuleEngineConfigurationExtension(struct soap *soap, const struct ns2__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns2__RuleEngineConfigurationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RuleEngineConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_ns2__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct ns2__RuleEngineConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RuleEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RuleEngineConfigurationExtension, sizeof(struct ns2__RuleEngineConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RuleEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RuleEngineConfigurationExtension, 0, sizeof(struct ns2__RuleEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RuleEngineConfigurationExtension(struct soap *soap, const struct ns2__RuleEngineConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RuleEngineConfigurationExtension);
	if (soap_out_ns2__RuleEngineConfigurationExtension(soap, tag?tag:"ns2:RuleEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_ns2__RuleEngineConfigurationExtension(struct soap *soap, struct ns2__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RuleEngineConfiguration(struct soap *soap, struct ns2__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRule = 0;
	a->Rule = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RuleEngineConfiguration(struct soap *soap, const struct ns2__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Rule)
	{	int i;
		for (i = 0; i < a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_ns2__Config);
			soap_serialize_ns2__Config(soap, a->Rule + i);
		}
	}
	soap_serialize_PointerTons2__RuleEngineConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__RuleEngineConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RuleEngineConfiguration), type))
		return soap->error;
	if (a->Rule)
	{	int i;
		for (i = 0; i < a->__sizeRule; i++)
			if (soap_out_ns2__Config(soap, "ns2:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__RuleEngineConfigurationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RuleEngineConfiguration * SOAP_FMAC4 soap_in_ns2__RuleEngineConfiguration(struct soap *soap, const char *tag, struct ns2__RuleEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Rule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RuleEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RuleEngineConfiguration, sizeof(struct ns2__RuleEngineConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RuleEngineConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_new_block(soap);
					a->Rule = (struct ns2__Config *)soap_push_block(soap, soap_blist_Rule, sizeof(struct ns2__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_ns2__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_ns2__Config(soap, "ns2:Rule", a->Rule, "ns2:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RuleEngineConfigurationExtension(soap, "ns2:Extension", &a->Extension, "ns2:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
			a->Rule = (struct ns2__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RuleEngineConfiguration, 0, sizeof(struct ns2__RuleEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RuleEngineConfiguration(struct soap *soap, const struct ns2__RuleEngineConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RuleEngineConfiguration);
	if (soap_out_ns2__RuleEngineConfiguration(soap, tag?tag:"ns2:RuleEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RuleEngineConfiguration * SOAP_FMAC4 soap_get_ns2__RuleEngineConfiguration(struct soap *soap, struct ns2__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AnalyticsEngineConfigurationExtension(struct soap *soap, struct ns2__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct ns2__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns2__AnalyticsEngineConfigurationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_ns2__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct ns2__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AnalyticsEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension, sizeof(struct ns2__AnalyticsEngineConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AnalyticsEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension, 0, sizeof(struct ns2__AnalyticsEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct ns2__AnalyticsEngineConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension);
	if (soap_out_ns2__AnalyticsEngineConfigurationExtension(soap, tag?tag:"ns2:AnalyticsEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_ns2__AnalyticsEngineConfigurationExtension(struct soap *soap, struct ns2__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Config(struct soap *soap, struct ns2__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Config(struct soap *soap, const struct ns2__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ItemList(soap, &a->Parameters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Config(struct soap *soap, const char *tag, int id, const struct ns2__Config *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_QName2s(soap, a->Type), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Config), type))
		return soap->error;
	if (a->Parameters)
	{	if (soap_out_PointerTons2__ItemList(soap, "ns2:Parameters", -1, &a->Parameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Parameters"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Config * SOAP_FMAC4 soap_in_ns2__Config(struct soap *soap, const char *tag, struct ns2__Config *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Config *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Config, sizeof(struct ns2__Config), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Config(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap_s2QName(soap, soap_attr_value(soap, "Type", 1), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemList(soap, "ns2:Parameters", &a->Parameters, "ns2:ItemList"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Config, 0, sizeof(struct ns2__Config), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Config(struct soap *soap, const struct ns2__Config *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Config);
	if (soap_out_ns2__Config(soap, tag?tag:"ns2:Config", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Config * SOAP_FMAC4 soap_get_ns2__Config(struct soap *soap, struct ns2__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AnalyticsEngineConfiguration(struct soap *soap, struct ns2__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AnalyticsEngineConfiguration(struct soap *soap, const struct ns2__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_ns2__Config);
			soap_serialize_ns2__Config(soap, a->AnalyticsModule + i);
		}
	}
	soap_serialize_PointerTons2__AnalyticsEngineConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__AnalyticsEngineConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnalyticsEngineConfiguration), type))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModule; i++)
			if (soap_out_ns2__Config(soap, "ns2:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__AnalyticsEngineConfigurationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_ns2__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct ns2__AnalyticsEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AnalyticsEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnalyticsEngineConfiguration, sizeof(struct ns2__AnalyticsEngineConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AnalyticsEngineConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_new_block(soap);
					a->AnalyticsModule = (struct ns2__Config *)soap_push_block(soap, soap_blist_AnalyticsModule, sizeof(struct ns2__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_ns2__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_ns2__Config(soap, "ns2:AnalyticsModule", a->AnalyticsModule, "ns2:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AnalyticsEngineConfigurationExtension(soap, "ns2:Extension", &a->Extension, "ns2:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
			a->AnalyticsModule = (struct ns2__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnalyticsEngineConfiguration, 0, sizeof(struct ns2__AnalyticsEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AnalyticsEngineConfiguration(struct soap *soap, const struct ns2__AnalyticsEngineConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AnalyticsEngineConfiguration);
	if (soap_out_ns2__AnalyticsEngineConfiguration(soap, tag?tag:"ns2:AnalyticsEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_ns2__AnalyticsEngineConfiguration(struct soap *soap, struct ns2__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObjectTreeExtension(struct soap *soap, struct ns2__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObjectTreeExtension(struct soap *soap, const struct ns2__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObjectTreeExtension(struct soap *soap, const char *tag, int id, const struct ns2__ObjectTreeExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObjectTreeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObjectTreeExtension * SOAP_FMAC4 soap_in_ns2__ObjectTreeExtension(struct soap *soap, const char *tag, struct ns2__ObjectTreeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObjectTreeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObjectTreeExtension, sizeof(struct ns2__ObjectTreeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObjectTreeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectTreeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObjectTreeExtension, 0, sizeof(struct ns2__ObjectTreeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObjectTreeExtension(struct soap *soap, const struct ns2__ObjectTreeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObjectTreeExtension);
	if (soap_out_ns2__ObjectTreeExtension(soap, tag?tag:"ns2:ObjectTreeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectTreeExtension * SOAP_FMAC4 soap_get_ns2__ObjectTreeExtension(struct soap *soap, struct ns2__ObjectTreeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BehaviourExtension(struct soap *soap, struct ns2__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BehaviourExtension(struct soap *soap, const struct ns2__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BehaviourExtension(struct soap *soap, const char *tag, int id, const struct ns2__BehaviourExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BehaviourExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BehaviourExtension * SOAP_FMAC4 soap_in_ns2__BehaviourExtension(struct soap *soap, const char *tag, struct ns2__BehaviourExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BehaviourExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BehaviourExtension, sizeof(struct ns2__BehaviourExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BehaviourExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BehaviourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BehaviourExtension, 0, sizeof(struct ns2__BehaviourExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BehaviourExtension(struct soap *soap, const struct ns2__BehaviourExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BehaviourExtension);
	if (soap_out_ns2__BehaviourExtension(soap, tag?tag:"ns2:BehaviourExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BehaviourExtension * SOAP_FMAC4 soap_get_ns2__BehaviourExtension(struct soap *soap, struct ns2__BehaviourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__Behaviour_Idle(struct soap *soap, struct _ns2__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__Behaviour_Idle(struct soap *soap, const struct _ns2__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__Behaviour_Idle(struct soap *soap, const char *tag, int id, const struct _ns2__Behaviour_Idle *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__Behaviour_Idle), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__Behaviour_Idle * SOAP_FMAC4 soap_in__ns2__Behaviour_Idle(struct soap *soap, const char *tag, struct _ns2__Behaviour_Idle *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__Behaviour_Idle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__Behaviour_Idle, sizeof(struct _ns2__Behaviour_Idle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__Behaviour_Idle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__Behaviour_Idle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__Behaviour_Idle, 0, sizeof(struct _ns2__Behaviour_Idle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__Behaviour_Idle(struct soap *soap, const struct _ns2__Behaviour_Idle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__Behaviour_Idle);
	if (soap_out__ns2__Behaviour_Idle(soap, tag?tag:"ns2:Behaviour-Idle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__Behaviour_Idle * SOAP_FMAC4 soap_get__ns2__Behaviour_Idle(struct soap *soap, struct _ns2__Behaviour_Idle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__Behaviour_Removed(struct soap *soap, struct _ns2__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__Behaviour_Removed(struct soap *soap, const struct _ns2__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__Behaviour_Removed(struct soap *soap, const char *tag, int id, const struct _ns2__Behaviour_Removed *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__Behaviour_Removed), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__Behaviour_Removed * SOAP_FMAC4 soap_in__ns2__Behaviour_Removed(struct soap *soap, const char *tag, struct _ns2__Behaviour_Removed *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__Behaviour_Removed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__Behaviour_Removed, sizeof(struct _ns2__Behaviour_Removed), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__Behaviour_Removed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__Behaviour_Removed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__Behaviour_Removed, 0, sizeof(struct _ns2__Behaviour_Removed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__Behaviour_Removed(struct soap *soap, const struct _ns2__Behaviour_Removed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__Behaviour_Removed);
	if (soap_out__ns2__Behaviour_Removed(soap, tag?tag:"ns2:Behaviour-Removed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__Behaviour_Removed * SOAP_FMAC4 soap_get__ns2__Behaviour_Removed(struct soap *soap, struct _ns2__Behaviour_Removed *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Behaviour(struct soap *soap, struct ns2__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Removed = NULL;
	a->Idle = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Behaviour(struct soap *soap, const struct ns2__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__Behaviour_Removed(soap, &a->Removed);
	soap_serialize_PointerTo_ns2__Behaviour_Idle(soap, &a->Idle);
	soap_serialize_PointerTons2__BehaviourExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Behaviour(struct soap *soap, const char *tag, int id, const struct ns2__Behaviour *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Behaviour), type))
		return soap->error;
	if (soap_out_PointerTo_ns2__Behaviour_Removed(soap, "ns2:Removed", -1, &a->Removed, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__Behaviour_Idle(soap, "ns2:Idle", -1, &a->Idle, ""))
		return soap->error;
	if (soap_out_PointerTons2__BehaviourExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Behaviour * SOAP_FMAC4 soap_in_ns2__Behaviour(struct soap *soap, const char *tag, struct ns2__Behaviour *a, const char *type)
{
	size_t soap_flag_Removed = 1;
	size_t soap_flag_Idle = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Behaviour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Behaviour, sizeof(struct ns2__Behaviour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Behaviour(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Removed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__Behaviour_Removed(soap, "ns2:Removed", &a->Removed, ""))
				{	soap_flag_Removed--;
					continue;
				}
			if (soap_flag_Idle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__Behaviour_Idle(soap, "ns2:Idle", &a->Idle, ""))
				{	soap_flag_Idle--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BehaviourExtension(soap, "ns2:Extension", &a->Extension, "ns2:BehaviourExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Behaviour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Behaviour, 0, sizeof(struct ns2__Behaviour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Behaviour(struct soap *soap, const struct ns2__Behaviour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Behaviour);
	if (soap_out_ns2__Behaviour(soap, tag?tag:"ns2:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Behaviour * SOAP_FMAC4 soap_get_ns2__Behaviour(struct soap *soap, struct ns2__Behaviour *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Rename(struct soap *soap, struct ns2__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Rename(struct soap *soap, const struct ns2__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ObjectId(soap, &a->from);
	soap_serialize_PointerTons2__ObjectId(soap, &a->to);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Rename(struct soap *soap, const char *tag, int id, const struct ns2__Rename *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Rename), type))
		return soap->error;
	if (a->from)
	{	if (soap_out_PointerTons2__ObjectId(soap, "ns2:from", -1, &a->from, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:from"))
		return soap->error;
	if (a->to)
	{	if (soap_out_PointerTons2__ObjectId(soap, "ns2:to", -1, &a->to, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:to"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Rename * SOAP_FMAC4 soap_in_ns2__Rename(struct soap *soap, const char *tag, struct ns2__Rename *a, const char *type)
{
	size_t soap_flag_from = 1;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Rename *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Rename, sizeof(struct ns2__Rename), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Rename(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectId(soap, "ns2:from", &a->from, "ns2:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectId(soap, "ns2:to", &a->to, "ns2:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Rename *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Rename, 0, sizeof(struct ns2__Rename), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || soap_flag_to > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Rename(struct soap *soap, const struct ns2__Rename *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Rename);
	if (soap_out_ns2__Rename(soap, tag?tag:"ns2:Rename", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Rename * SOAP_FMAC4 soap_get_ns2__Rename(struct soap *soap, struct ns2__Rename *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Split(struct soap *soap, struct ns2__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->__sizeto = 0;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Split(struct soap *soap, const struct ns2__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ObjectId(soap, &a->from);
	if (a->to)
	{	int i;
		for (i = 0; i < a->__sizeto; i++)
		{
			soap_embedded(soap, a->to + i, SOAP_TYPE_ns2__ObjectId);
			soap_serialize_ns2__ObjectId(soap, a->to + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Split(struct soap *soap, const char *tag, int id, const struct ns2__Split *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Split), type))
		return soap->error;
	if (a->from)
	{	if (soap_out_PointerTons2__ObjectId(soap, "ns2:from", -1, &a->from, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:from"))
		return soap->error;
	if (a->to)
	{	int i;
		for (i = 0; i < a->__sizeto; i++)
			if (soap_out_ns2__ObjectId(soap, "ns2:to", -1, a->to + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Split * SOAP_FMAC4 soap_in_ns2__Split(struct soap *soap, const char *tag, struct ns2__Split *a, const char *type)
{
	size_t soap_flag_from = 1;
	struct soap_blist *soap_blist_to = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Split *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Split, sizeof(struct ns2__Split), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Split(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectId(soap, "ns2:from", &a->from, "ns2:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:to", 1, NULL))
			{	if (a->to == NULL)
				{	if (soap_blist_to == NULL)
						soap_blist_to = soap_new_block(soap);
					a->to = (struct ns2__ObjectId *)soap_push_block(soap, soap_blist_to, sizeof(struct ns2__ObjectId));
					if (a->to == NULL)
						return NULL;
					soap_default_ns2__ObjectId(soap, a->to);
				}
				soap_revert(soap);
				if (soap_in_ns2__ObjectId(soap, "ns2:to", a->to, "ns2:ObjectId"))
				{	a->__sizeto++;
					a->to = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->to)
			soap_pop_block(soap, soap_blist_to);
		if (a->__sizeto)
			a->to = (struct ns2__ObjectId *)soap_save_block(soap, soap_blist_to, NULL, 1);
		else
		{	a->to = NULL;
			if (soap_blist_to)
				soap_end_block(soap, soap_blist_to);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Split *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Split, 0, sizeof(struct ns2__Split), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || a->__sizeto < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Split(struct soap *soap, const struct ns2__Split *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Split);
	if (soap_out_ns2__Split(soap, tag?tag:"ns2:Split", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Split * SOAP_FMAC4 soap_get_ns2__Split(struct soap *soap, struct ns2__Split *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObjectId(struct soap *soap, struct ns2__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->ObjectId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObjectId(struct soap *soap, const struct ns2__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObjectId(struct soap *soap, const char *tag, int id, const struct ns2__ObjectId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", a->ObjectId, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObjectId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObjectId * SOAP_FMAC4 soap_in_ns2__ObjectId(struct soap *soap, const char *tag, struct ns2__ObjectId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObjectId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObjectId, sizeof(struct ns2__ObjectId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObjectId(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "ObjectId", 0), &a->ObjectId, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObjectId, 0, sizeof(struct ns2__ObjectId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObjectId(struct soap *soap, const struct ns2__ObjectId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObjectId);
	if (soap_out_ns2__ObjectId(soap, tag?tag:"ns2:ObjectId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectId * SOAP_FMAC4 soap_get_ns2__ObjectId(struct soap *soap, struct ns2__ObjectId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Merge(struct soap *soap, struct ns2__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizefrom = 0;
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Merge(struct soap *soap, const struct ns2__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->from)
	{	int i;
		for (i = 0; i < a->__sizefrom; i++)
		{
			soap_embedded(soap, a->from + i, SOAP_TYPE_ns2__ObjectId);
			soap_serialize_ns2__ObjectId(soap, a->from + i);
		}
	}
	soap_serialize_PointerTons2__ObjectId(soap, &a->to);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Merge(struct soap *soap, const char *tag, int id, const struct ns2__Merge *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Merge), type))
		return soap->error;
	if (a->from)
	{	int i;
		for (i = 0; i < a->__sizefrom; i++)
			if (soap_out_ns2__ObjectId(soap, "ns2:from", -1, a->from + i, ""))
				return soap->error;
	}
	if (a->to)
	{	if (soap_out_PointerTons2__ObjectId(soap, "ns2:to", -1, &a->to, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:to"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Merge * SOAP_FMAC4 soap_in_ns2__Merge(struct soap *soap, const char *tag, struct ns2__Merge *a, const char *type)
{
	struct soap_blist *soap_blist_from = NULL;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Merge *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Merge, sizeof(struct ns2__Merge), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Merge(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:from", 1, NULL))
			{	if (a->from == NULL)
				{	if (soap_blist_from == NULL)
						soap_blist_from = soap_new_block(soap);
					a->from = (struct ns2__ObjectId *)soap_push_block(soap, soap_blist_from, sizeof(struct ns2__ObjectId));
					if (a->from == NULL)
						return NULL;
					soap_default_ns2__ObjectId(soap, a->from);
				}
				soap_revert(soap);
				if (soap_in_ns2__ObjectId(soap, "ns2:from", a->from, "ns2:ObjectId"))
				{	a->__sizefrom++;
					a->from = NULL;
					continue;
				}
			}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectId(soap, "ns2:to", &a->to, "ns2:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->from)
			soap_pop_block(soap, soap_blist_from);
		if (a->__sizefrom)
			a->from = (struct ns2__ObjectId *)soap_save_block(soap, soap_blist_from, NULL, 1);
		else
		{	a->from = NULL;
			if (soap_blist_from)
				soap_end_block(soap, soap_blist_from);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Merge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Merge, 0, sizeof(struct ns2__Merge), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizefrom < 2 || soap_flag_to > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Merge(struct soap *soap, const struct ns2__Merge *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Merge);
	if (soap_out_ns2__Merge(soap, tag?tag:"ns2:Merge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Merge * SOAP_FMAC4 soap_get_ns2__Merge(struct soap *soap, struct ns2__Merge *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FrameExtension(struct soap *soap, struct ns2__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FrameExtension(struct soap *soap, const struct ns2__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FrameExtension(struct soap *soap, const char *tag, int id, const struct ns2__FrameExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FrameExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FrameExtension * SOAP_FMAC4 soap_in_ns2__FrameExtension(struct soap *soap, const char *tag, struct ns2__FrameExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FrameExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FrameExtension, sizeof(struct ns2__FrameExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FrameExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FrameExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FrameExtension, 0, sizeof(struct ns2__FrameExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FrameExtension(struct soap *soap, const struct ns2__FrameExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FrameExtension);
	if (soap_out_ns2__FrameExtension(soap, tag?tag:"ns2:FrameExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FrameExtension * SOAP_FMAC4 soap_get_ns2__FrameExtension(struct soap *soap, struct ns2__FrameExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObjectTree(struct soap *soap, struct ns2__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRename = 0;
	a->Rename = NULL;
	a->__sizeSplit = 0;
	a->Split = NULL;
	a->__sizeMerge = 0;
	a->Merge = NULL;
	a->__sizeDelete = 0;
	a->Delete = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObjectTree(struct soap *soap, const struct ns2__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Rename)
	{	int i;
		for (i = 0; i < a->__sizeRename; i++)
		{
			soap_embedded(soap, a->Rename + i, SOAP_TYPE_ns2__Rename);
			soap_serialize_ns2__Rename(soap, a->Rename + i);
		}
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < a->__sizeSplit; i++)
		{
			soap_embedded(soap, a->Split + i, SOAP_TYPE_ns2__Split);
			soap_serialize_ns2__Split(soap, a->Split + i);
		}
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < a->__sizeMerge; i++)
		{
			soap_embedded(soap, a->Merge + i, SOAP_TYPE_ns2__Merge);
			soap_serialize_ns2__Merge(soap, a->Merge + i);
		}
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < a->__sizeDelete; i++)
		{
			soap_embedded(soap, a->Delete + i, SOAP_TYPE_ns2__ObjectId);
			soap_serialize_ns2__ObjectId(soap, a->Delete + i);
		}
	}
	soap_serialize_PointerTons2__ObjectTreeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObjectTree(struct soap *soap, const char *tag, int id, const struct ns2__ObjectTree *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObjectTree), type))
		return soap->error;
	if (a->Rename)
	{	int i;
		for (i = 0; i < a->__sizeRename; i++)
			if (soap_out_ns2__Rename(soap, "ns2:Rename", -1, a->Rename + i, ""))
				return soap->error;
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < a->__sizeSplit; i++)
			if (soap_out_ns2__Split(soap, "ns2:Split", -1, a->Split + i, ""))
				return soap->error;
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < a->__sizeMerge; i++)
			if (soap_out_ns2__Merge(soap, "ns2:Merge", -1, a->Merge + i, ""))
				return soap->error;
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < a->__sizeDelete; i++)
			if (soap_out_ns2__ObjectId(soap, "ns2:Delete", -1, a->Delete + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ObjectTreeExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObjectTree * SOAP_FMAC4 soap_in_ns2__ObjectTree(struct soap *soap, const char *tag, struct ns2__ObjectTree *a, const char *type)
{
	struct soap_blist *soap_blist_Rename = NULL;
	struct soap_blist *soap_blist_Split = NULL;
	struct soap_blist *soap_blist_Merge = NULL;
	struct soap_blist *soap_blist_Delete = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObjectTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObjectTree, sizeof(struct ns2__ObjectTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObjectTree(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Rename", 1, NULL))
			{	if (a->Rename == NULL)
				{	if (soap_blist_Rename == NULL)
						soap_blist_Rename = soap_new_block(soap);
					a->Rename = (struct ns2__Rename *)soap_push_block(soap, soap_blist_Rename, sizeof(struct ns2__Rename));
					if (a->Rename == NULL)
						return NULL;
					soap_default_ns2__Rename(soap, a->Rename);
				}
				soap_revert(soap);
				if (soap_in_ns2__Rename(soap, "ns2:Rename", a->Rename, "ns2:Rename"))
				{	a->__sizeRename++;
					a->Rename = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Split", 1, NULL))
			{	if (a->Split == NULL)
				{	if (soap_blist_Split == NULL)
						soap_blist_Split = soap_new_block(soap);
					a->Split = (struct ns2__Split *)soap_push_block(soap, soap_blist_Split, sizeof(struct ns2__Split));
					if (a->Split == NULL)
						return NULL;
					soap_default_ns2__Split(soap, a->Split);
				}
				soap_revert(soap);
				if (soap_in_ns2__Split(soap, "ns2:Split", a->Split, "ns2:Split"))
				{	a->__sizeSplit++;
					a->Split = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Merge", 1, NULL))
			{	if (a->Merge == NULL)
				{	if (soap_blist_Merge == NULL)
						soap_blist_Merge = soap_new_block(soap);
					a->Merge = (struct ns2__Merge *)soap_push_block(soap, soap_blist_Merge, sizeof(struct ns2__Merge));
					if (a->Merge == NULL)
						return NULL;
					soap_default_ns2__Merge(soap, a->Merge);
				}
				soap_revert(soap);
				if (soap_in_ns2__Merge(soap, "ns2:Merge", a->Merge, "ns2:Merge"))
				{	a->__sizeMerge++;
					a->Merge = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Delete", 1, NULL))
			{	if (a->Delete == NULL)
				{	if (soap_blist_Delete == NULL)
						soap_blist_Delete = soap_new_block(soap);
					a->Delete = (struct ns2__ObjectId *)soap_push_block(soap, soap_blist_Delete, sizeof(struct ns2__ObjectId));
					if (a->Delete == NULL)
						return NULL;
					soap_default_ns2__ObjectId(soap, a->Delete);
				}
				soap_revert(soap);
				if (soap_in_ns2__ObjectId(soap, "ns2:Delete", a->Delete, "ns2:ObjectId"))
				{	a->__sizeDelete++;
					a->Delete = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectTreeExtension(soap, "ns2:Extension", &a->Extension, "ns2:ObjectTreeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rename)
			soap_pop_block(soap, soap_blist_Rename);
		if (a->__sizeRename)
			a->Rename = (struct ns2__Rename *)soap_save_block(soap, soap_blist_Rename, NULL, 1);
		else
		{	a->Rename = NULL;
			if (soap_blist_Rename)
				soap_end_block(soap, soap_blist_Rename);
		}
		if (a->Split)
			soap_pop_block(soap, soap_blist_Split);
		if (a->__sizeSplit)
			a->Split = (struct ns2__Split *)soap_save_block(soap, soap_blist_Split, NULL, 1);
		else
		{	a->Split = NULL;
			if (soap_blist_Split)
				soap_end_block(soap, soap_blist_Split);
		}
		if (a->Merge)
			soap_pop_block(soap, soap_blist_Merge);
		if (a->__sizeMerge)
			a->Merge = (struct ns2__Merge *)soap_save_block(soap, soap_blist_Merge, NULL, 1);
		else
		{	a->Merge = NULL;
			if (soap_blist_Merge)
				soap_end_block(soap, soap_blist_Merge);
		}
		if (a->Delete)
			soap_pop_block(soap, soap_blist_Delete);
		if (a->__sizeDelete)
			a->Delete = (struct ns2__ObjectId *)soap_save_block(soap, soap_blist_Delete, NULL, 1);
		else
		{	a->Delete = NULL;
			if (soap_blist_Delete)
				soap_end_block(soap, soap_blist_Delete);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObjectTree, 0, sizeof(struct ns2__ObjectTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObjectTree(struct soap *soap, const struct ns2__ObjectTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObjectTree);
	if (soap_out_ns2__ObjectTree(soap, tag?tag:"ns2:ObjectTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectTree * SOAP_FMAC4 soap_get_ns2__ObjectTree(struct soap *soap, struct ns2__ObjectTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Object(struct soap *soap, struct ns2__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->ObjectId);
	a->Appearance = NULL;
	a->Behaviour = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Object(struct soap *soap, const struct ns2__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Appearance(soap, &a->Appearance);
	soap_serialize_PointerTons2__Behaviour(soap, &a->Behaviour);
	soap_serialize_PointerTons2__ObjectExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Object(struct soap *soap, const char *tag, int id, const struct ns2__Object *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", a->ObjectId, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Object), type))
		return soap->error;
	if (soap_out_PointerTons2__Appearance(soap, "ns2:Appearance", -1, &a->Appearance, ""))
		return soap->error;
	if (soap_out_PointerTons2__Behaviour(soap, "ns2:Behaviour", -1, &a->Behaviour, ""))
		return soap->error;
	if (soap_out_PointerTons2__ObjectExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Object * SOAP_FMAC4 soap_in_ns2__Object(struct soap *soap, const char *tag, struct ns2__Object *a, const char *type)
{
	size_t soap_flag_Appearance = 1;
	size_t soap_flag_Behaviour = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Object *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Object, sizeof(struct ns2__Object), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Object(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "ObjectId", 0), &a->ObjectId, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Appearance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Appearance(soap, "ns2:Appearance", &a->Appearance, "ns2:Appearance"))
				{	soap_flag_Appearance--;
					continue;
				}
			if (soap_flag_Behaviour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Behaviour(soap, "ns2:Behaviour", &a->Behaviour, "ns2:Behaviour"))
				{	soap_flag_Behaviour--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectExtension(soap, "ns2:Extension", &a->Extension, "ns2:ObjectExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Object, 0, sizeof(struct ns2__Object), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Object(struct soap *soap, const struct ns2__Object *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Object);
	if (soap_out_ns2__Object(soap, tag?tag:"ns2:Object", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Object * SOAP_FMAC4 soap_get_ns2__Object(struct soap *soap, struct ns2__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Frame(struct soap *soap, struct ns2__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
	a->Transformation = NULL;
	a->__sizeObject = 0;
	a->Object = NULL;
	a->ObjectTree = NULL;
	a->Extension = NULL;
	soap_default_time(soap, &a->UtcTime);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Frame(struct soap *soap, const struct ns2__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PTZStatus(soap, &a->PTZStatus);
	soap_serialize_PointerTons2__Transformation(soap, &a->Transformation);
	if (a->Object)
	{	int i;
		for (i = 0; i < a->__sizeObject; i++)
		{
			soap_embedded(soap, a->Object + i, SOAP_TYPE_ns2__Object);
			soap_serialize_ns2__Object(soap, a->Object + i);
		}
	}
	soap_serialize_PointerTons2__ObjectTree(soap, &a->ObjectTree);
	soap_serialize_PointerTons2__FrameExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Frame(struct soap *soap, const char *tag, int id, const struct ns2__Frame *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Frame), type))
		return soap->error;
	if (soap_out_PointerTons2__PTZStatus(soap, "ns2:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTons2__Transformation(soap, "ns2:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (a->Object)
	{	int i;
		for (i = 0; i < a->__sizeObject; i++)
			if (soap_out_ns2__Object(soap, "ns2:Object", -1, a->Object + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ObjectTree(soap, "ns2:ObjectTree", -1, &a->ObjectTree, ""))
		return soap->error;
	if (soap_out_PointerTons2__FrameExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Frame * SOAP_FMAC4 soap_in_ns2__Frame(struct soap *soap, const char *tag, struct ns2__Frame *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Transformation = 1;
	struct soap_blist *soap_blist_Object = NULL;
	size_t soap_flag_ObjectTree = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Frame *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Frame, sizeof(struct ns2__Frame), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Frame(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &a->UtcTime))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZStatus(soap, "ns2:PTZStatus", &a->PTZStatus, "ns2:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Transformation(soap, "ns2:Transformation", &a->Transformation, "ns2:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Object", 1, NULL))
			{	if (a->Object == NULL)
				{	if (soap_blist_Object == NULL)
						soap_blist_Object = soap_new_block(soap);
					a->Object = (struct ns2__Object *)soap_push_block(soap, soap_blist_Object, sizeof(struct ns2__Object));
					if (a->Object == NULL)
						return NULL;
					soap_default_ns2__Object(soap, a->Object);
				}
				soap_revert(soap);
				if (soap_in_ns2__Object(soap, "ns2:Object", a->Object, "ns2:Object"))
				{	a->__sizeObject++;
					a->Object = NULL;
					continue;
				}
			}
			if (soap_flag_ObjectTree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ObjectTree(soap, "ns2:ObjectTree", &a->ObjectTree, "ns2:ObjectTree"))
				{	soap_flag_ObjectTree--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FrameExtension(soap, "ns2:Extension", &a->Extension, "ns2:FrameExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Object)
			soap_pop_block(soap, soap_blist_Object);
		if (a->__sizeObject)
			a->Object = (struct ns2__Object *)soap_save_block(soap, soap_blist_Object, NULL, 1);
		else
		{	a->Object = NULL;
			if (soap_blist_Object)
				soap_end_block(soap, soap_blist_Object);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Frame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Frame, 0, sizeof(struct ns2__Frame), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Frame(struct soap *soap, const struct ns2__Frame *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Frame);
	if (soap_out_ns2__Frame(soap, tag?tag:"ns2:Frame", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Frame * SOAP_FMAC4 soap_get_ns2__Frame(struct soap *soap, struct ns2__Frame *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TransformationExtension(struct soap *soap, struct ns2__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__TransformationExtension(struct soap *soap, const struct ns2__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TransformationExtension(struct soap *soap, const char *tag, int id, const struct ns2__TransformationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TransformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__TransformationExtension * SOAP_FMAC4 soap_in_ns2__TransformationExtension(struct soap *soap, const char *tag, struct ns2__TransformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__TransformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TransformationExtension, sizeof(struct ns2__TransformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__TransformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TransformationExtension, 0, sizeof(struct ns2__TransformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TransformationExtension(struct soap *soap, const struct ns2__TransformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TransformationExtension);
	if (soap_out_ns2__TransformationExtension(soap, tag?tag:"ns2:TransformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__TransformationExtension * SOAP_FMAC4 soap_get_ns2__TransformationExtension(struct soap *soap, struct ns2__TransformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObjectExtension(struct soap *soap, struct ns2__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObjectExtension(struct soap *soap, const struct ns2__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObjectExtension(struct soap *soap, const char *tag, int id, const struct ns2__ObjectExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObjectExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObjectExtension * SOAP_FMAC4 soap_in_ns2__ObjectExtension(struct soap *soap, const char *tag, struct ns2__ObjectExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObjectExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObjectExtension, sizeof(struct ns2__ObjectExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObjectExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObjectExtension, 0, sizeof(struct ns2__ObjectExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObjectExtension(struct soap *soap, const struct ns2__ObjectExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObjectExtension);
	if (soap_out_ns2__ObjectExtension(soap, tag?tag:"ns2:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectExtension * SOAP_FMAC4 soap_get_ns2__ObjectExtension(struct soap *soap, struct ns2__ObjectExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ClassDescriptorExtension(struct soap *soap, struct ns2__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ClassDescriptorExtension(struct soap *soap, const struct ns2__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct ns2__ClassDescriptorExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClassDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ClassDescriptorExtension * SOAP_FMAC4 soap_in_ns2__ClassDescriptorExtension(struct soap *soap, const char *tag, struct ns2__ClassDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ClassDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClassDescriptorExtension, sizeof(struct ns2__ClassDescriptorExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ClassDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClassDescriptorExtension, 0, sizeof(struct ns2__ClassDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ClassDescriptorExtension(struct soap *soap, const struct ns2__ClassDescriptorExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ClassDescriptorExtension);
	if (soap_out_ns2__ClassDescriptorExtension(soap, tag?tag:"ns2:ClassDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ClassDescriptorExtension * SOAP_FMAC4 soap_get_ns2__ClassDescriptorExtension(struct soap *soap, struct ns2__ClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ClassDescriptor_ClassCandidate(struct soap *soap, struct _ns2__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _ns2__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, const struct _ns2__ClassDescriptor_ClassCandidate *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate), type))
		return soap->error;
	if (soap_out_ns2__ClassType(soap, "ns2:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_in__ns2__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _ns2__ClassDescriptor_ClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ClassDescriptor_ClassCandidate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate, sizeof(struct _ns2__ClassDescriptor_ClassCandidate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ClassDescriptor_ClassCandidate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassType(soap, "ns2:Type", &a->Type, "ns2:ClassType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ClassDescriptor_ClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate, 0, sizeof(struct _ns2__ClassDescriptor_ClassCandidate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _ns2__ClassDescriptor_ClassCandidate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate);
	if (soap_out__ns2__ClassDescriptor_ClassCandidate(soap, tag?tag:"ns2:ClassDescriptor-ClassCandidate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_get__ns2__ClassDescriptor_ClassCandidate(struct soap *soap, struct _ns2__ClassDescriptor_ClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ColorDescriptorExtension(struct soap *soap, struct ns2__ColorDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ColorDescriptorExtension(struct soap *soap, const struct ns2__ColorDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, const struct ns2__ColorDescriptorExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ColorDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ColorDescriptorExtension * SOAP_FMAC4 soap_in_ns2__ColorDescriptorExtension(struct soap *soap, const char *tag, struct ns2__ColorDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ColorDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ColorDescriptorExtension, sizeof(struct ns2__ColorDescriptorExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ColorDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ColorDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ColorDescriptorExtension, 0, sizeof(struct ns2__ColorDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ColorDescriptorExtension(struct soap *soap, const struct ns2__ColorDescriptorExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ColorDescriptorExtension);
	if (soap_out_ns2__ColorDescriptorExtension(soap, tag?tag:"ns2:ColorDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ColorDescriptorExtension * SOAP_FMAC4 soap_get_ns2__ColorDescriptorExtension(struct soap *soap, struct ns2__ColorDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ColorDescriptor_ColorCluster(struct soap *soap, struct _ns2__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Weight = NULL;
	a->Covariance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ColorDescriptor_ColorCluster(struct soap *soap, const struct _ns2__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Color(soap, &a->Color);
	soap_serialize_PointerTofloat(soap, &a->Weight);
	soap_serialize_PointerTons2__ColorCovariance(soap, &a->Covariance);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, const struct _ns2__ColorDescriptor_ColorCluster *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster), type))
		return soap->error;
	if (a->Color)
	{	if (soap_out_PointerTons2__Color(soap, "ns2:Color", -1, &a->Color, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Color"))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Weight", -1, &a->Weight, ""))
		return soap->error;
	if (soap_out_PointerTons2__ColorCovariance(soap, "ns2:Covariance", -1, &a->Covariance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_in__ns2__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _ns2__ColorDescriptor_ColorCluster *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Weight = 1;
	size_t soap_flag_Covariance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ColorDescriptor_ColorCluster *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster, sizeof(struct _ns2__ColorDescriptor_ColorCluster), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ColorDescriptor_ColorCluster(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Color(soap, "ns2:Color", &a->Color, "ns2:Color"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Weight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Weight", &a->Weight, "xsd:float"))
				{	soap_flag_Weight--;
					continue;
				}
			if (soap_flag_Covariance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ColorCovariance(soap, "ns2:Covariance", &a->Covariance, "ns2:ColorCovariance"))
				{	soap_flag_Covariance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ColorDescriptor_ColorCluster *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster, 0, sizeof(struct _ns2__ColorDescriptor_ColorCluster), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Color > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ColorDescriptor_ColorCluster(struct soap *soap, const struct _ns2__ColorDescriptor_ColorCluster *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster);
	if (soap_out__ns2__ColorDescriptor_ColorCluster(soap, tag?tag:"ns2:ColorDescriptor-ColorCluster", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_get__ns2__ColorDescriptor_ColorCluster(struct soap *soap, struct _ns2__ColorDescriptor_ColorCluster *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ShapeDescriptorExtension(struct soap *soap, struct ns2__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ShapeDescriptorExtension(struct soap *soap, const struct ns2__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, const struct ns2__ShapeDescriptorExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShapeDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ShapeDescriptorExtension * SOAP_FMAC4 soap_in_ns2__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct ns2__ShapeDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ShapeDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShapeDescriptorExtension, sizeof(struct ns2__ShapeDescriptorExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ShapeDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ShapeDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShapeDescriptorExtension, 0, sizeof(struct ns2__ShapeDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ShapeDescriptorExtension(struct soap *soap, const struct ns2__ShapeDescriptorExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ShapeDescriptorExtension);
	if (soap_out_ns2__ShapeDescriptorExtension(soap, tag?tag:"ns2:ShapeDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ShapeDescriptorExtension * SOAP_FMAC4 soap_get_ns2__ShapeDescriptorExtension(struct soap *soap, struct ns2__ShapeDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AppearanceExtension(struct soap *soap, struct ns2__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AppearanceExtension(struct soap *soap, const struct ns2__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AppearanceExtension(struct soap *soap, const char *tag, int id, const struct ns2__AppearanceExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AppearanceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AppearanceExtension * SOAP_FMAC4 soap_in_ns2__AppearanceExtension(struct soap *soap, const char *tag, struct ns2__AppearanceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AppearanceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AppearanceExtension, sizeof(struct ns2__AppearanceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AppearanceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AppearanceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AppearanceExtension, 0, sizeof(struct ns2__AppearanceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AppearanceExtension(struct soap *soap, const struct ns2__AppearanceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AppearanceExtension);
	if (soap_out_ns2__AppearanceExtension(soap, tag?tag:"ns2:AppearanceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AppearanceExtension * SOAP_FMAC4 soap_get_ns2__AppearanceExtension(struct soap *soap, struct ns2__AppearanceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ClassDescriptor(struct soap *soap, struct ns2__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ClassDescriptor(struct soap *soap, const struct ns2__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate);
			soap_serialize__ns2__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTons2__ClassDescriptorExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClassDescriptor(struct soap *soap, const char *tag, int id, const struct ns2__ClassDescriptor *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < a->__sizeClassCandidate; i++)
			if (soap_out__ns2__ClassDescriptor_ClassCandidate(soap, "ns2:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ClassDescriptorExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ClassDescriptor * SOAP_FMAC4 soap_in_ns2__ClassDescriptor(struct soap *soap, const char *tag, struct ns2__ClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ClassDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClassDescriptor, sizeof(struct ns2__ClassDescriptor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ClassDescriptor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_new_block(soap);
					a->ClassCandidate = (struct _ns2__ClassDescriptor_ClassCandidate *)soap_push_block(soap, soap_blist_ClassCandidate, sizeof(struct _ns2__ClassDescriptor_ClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default__ns2__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in__ns2__ClassDescriptor_ClassCandidate(soap, "ns2:ClassCandidate", a->ClassCandidate, ""))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ClassDescriptorExtension(soap, "ns2:Extension", &a->Extension, "ns2:ClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
			a->ClassCandidate = (struct _ns2__ClassDescriptor_ClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClassDescriptor, 0, sizeof(struct ns2__ClassDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ClassDescriptor(struct soap *soap, const struct ns2__ClassDescriptor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ClassDescriptor);
	if (soap_out_ns2__ClassDescriptor(soap, tag?tag:"ns2:ClassDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ClassDescriptor * SOAP_FMAC4 soap_get_ns2__ClassDescriptor(struct soap *soap, struct ns2__ClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ColorDescriptor(struct soap *soap, struct ns2__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorCluster = 0;
	a->ColorCluster = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ColorDescriptor(struct soap *soap, const struct ns2__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < a->__sizeColorCluster; i++)
		{
			soap_embedded(soap, a->ColorCluster + i, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster);
			soap_serialize__ns2__ColorDescriptor_ColorCluster(soap, a->ColorCluster + i);
		}
	}
	soap_serialize_PointerTons2__ColorDescriptorExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ColorDescriptor(struct soap *soap, const char *tag, int id, const struct ns2__ColorDescriptor *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ColorDescriptor), type))
		return soap->error;
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < a->__sizeColorCluster; i++)
			if (soap_out__ns2__ColorDescriptor_ColorCluster(soap, "ns2:ColorCluster", -1, a->ColorCluster + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ColorDescriptorExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ColorDescriptor * SOAP_FMAC4 soap_in_ns2__ColorDescriptor(struct soap *soap, const char *tag, struct ns2__ColorDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ColorCluster = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ColorDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ColorDescriptor, sizeof(struct ns2__ColorDescriptor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ColorDescriptor(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ColorCluster", 1, NULL))
			{	if (a->ColorCluster == NULL)
				{	if (soap_blist_ColorCluster == NULL)
						soap_blist_ColorCluster = soap_new_block(soap);
					a->ColorCluster = (struct _ns2__ColorDescriptor_ColorCluster *)soap_push_block(soap, soap_blist_ColorCluster, sizeof(struct _ns2__ColorDescriptor_ColorCluster));
					if (a->ColorCluster == NULL)
						return NULL;
					soap_default__ns2__ColorDescriptor_ColorCluster(soap, a->ColorCluster);
				}
				soap_revert(soap);
				if (soap_in__ns2__ColorDescriptor_ColorCluster(soap, "ns2:ColorCluster", a->ColorCluster, ""))
				{	a->__sizeColorCluster++;
					a->ColorCluster = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ColorDescriptorExtension(soap, "ns2:Extension", &a->Extension, "ns2:ColorDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorCluster)
			soap_pop_block(soap, soap_blist_ColorCluster);
		if (a->__sizeColorCluster)
			a->ColorCluster = (struct _ns2__ColorDescriptor_ColorCluster *)soap_save_block(soap, soap_blist_ColorCluster, NULL, 1);
		else
		{	a->ColorCluster = NULL;
			if (soap_blist_ColorCluster)
				soap_end_block(soap, soap_blist_ColorCluster);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ColorDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ColorDescriptor, 0, sizeof(struct ns2__ColorDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ColorDescriptor(struct soap *soap, const struct ns2__ColorDescriptor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ColorDescriptor);
	if (soap_out_ns2__ColorDescriptor(soap, tag?tag:"ns2:ColorDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ColorDescriptor * SOAP_FMAC4 soap_get_ns2__ColorDescriptor(struct soap *soap, struct ns2__ColorDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ShapeDescriptor(struct soap *soap, struct ns2__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundingBox = NULL;
	a->CenterOfGravity = NULL;
	a->__sizePolygon = 0;
	a->Polygon = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ShapeDescriptor(struct soap *soap, const struct ns2__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Rectangle(soap, &a->BoundingBox);
	soap_serialize_PointerTons2__Vector(soap, &a->CenterOfGravity);
	if (a->Polygon)
	{	int i;
		for (i = 0; i < a->__sizePolygon; i++)
		{
			soap_embedded(soap, a->Polygon + i, SOAP_TYPE_ns2__Polygon);
			soap_serialize_ns2__Polygon(soap, a->Polygon + i);
		}
	}
	soap_serialize_PointerTons2__ShapeDescriptorExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShapeDescriptor(struct soap *soap, const char *tag, int id, const struct ns2__ShapeDescriptor *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShapeDescriptor), type))
		return soap->error;
	if (a->BoundingBox)
	{	if (soap_out_PointerTons2__Rectangle(soap, "ns2:BoundingBox", -1, &a->BoundingBox, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:BoundingBox"))
		return soap->error;
	if (a->CenterOfGravity)
	{	if (soap_out_PointerTons2__Vector(soap, "ns2:CenterOfGravity", -1, &a->CenterOfGravity, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:CenterOfGravity"))
		return soap->error;
	if (a->Polygon)
	{	int i;
		for (i = 0; i < a->__sizePolygon; i++)
			if (soap_out_ns2__Polygon(soap, "ns2:Polygon", -1, a->Polygon + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ShapeDescriptorExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ShapeDescriptor * SOAP_FMAC4 soap_in_ns2__ShapeDescriptor(struct soap *soap, const char *tag, struct ns2__ShapeDescriptor *a, const char *type)
{
	size_t soap_flag_BoundingBox = 1;
	size_t soap_flag_CenterOfGravity = 1;
	struct soap_blist *soap_blist_Polygon = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ShapeDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShapeDescriptor, sizeof(struct ns2__ShapeDescriptor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ShapeDescriptor(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundingBox && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Rectangle(soap, "ns2:BoundingBox", &a->BoundingBox, "ns2:Rectangle"))
				{	soap_flag_BoundingBox--;
					continue;
				}
			if (soap_flag_CenterOfGravity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector(soap, "ns2:CenterOfGravity", &a->CenterOfGravity, "ns2:Vector"))
				{	soap_flag_CenterOfGravity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Polygon", 1, NULL))
			{	if (a->Polygon == NULL)
				{	if (soap_blist_Polygon == NULL)
						soap_blist_Polygon = soap_new_block(soap);
					a->Polygon = (struct ns2__Polygon *)soap_push_block(soap, soap_blist_Polygon, sizeof(struct ns2__Polygon));
					if (a->Polygon == NULL)
						return NULL;
					soap_default_ns2__Polygon(soap, a->Polygon);
				}
				soap_revert(soap);
				if (soap_in_ns2__Polygon(soap, "ns2:Polygon", a->Polygon, "ns2:Polygon"))
				{	a->__sizePolygon++;
					a->Polygon = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShapeDescriptorExtension(soap, "ns2:Extension", &a->Extension, "ns2:ShapeDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Polygon)
			soap_pop_block(soap, soap_blist_Polygon);
		if (a->__sizePolygon)
			a->Polygon = (struct ns2__Polygon *)soap_save_block(soap, soap_blist_Polygon, NULL, 1);
		else
		{	a->Polygon = NULL;
			if (soap_blist_Polygon)
				soap_end_block(soap, soap_blist_Polygon);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ShapeDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShapeDescriptor, 0, sizeof(struct ns2__ShapeDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundingBox > 0 || soap_flag_CenterOfGravity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ShapeDescriptor(struct soap *soap, const struct ns2__ShapeDescriptor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ShapeDescriptor);
	if (soap_out_ns2__ShapeDescriptor(soap, tag?tag:"ns2:ShapeDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ShapeDescriptor * SOAP_FMAC4 soap_get_ns2__ShapeDescriptor(struct soap *soap, struct ns2__ShapeDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Transformation(struct soap *soap, struct ns2__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Translate = NULL;
	a->Scale = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Transformation(struct soap *soap, const struct ns2__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Vector(soap, &a->Translate);
	soap_serialize_PointerTons2__Vector(soap, &a->Scale);
	soap_serialize_PointerTons2__TransformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Transformation(struct soap *soap, const char *tag, int id, const struct ns2__Transformation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Transformation), type))
		return soap->error;
	if (soap_out_PointerTons2__Vector(soap, "ns2:Translate", -1, &a->Translate, ""))
		return soap->error;
	if (soap_out_PointerTons2__Vector(soap, "ns2:Scale", -1, &a->Scale, ""))
		return soap->error;
	if (soap_out_PointerTons2__TransformationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Transformation * SOAP_FMAC4 soap_in_ns2__Transformation(struct soap *soap, const char *tag, struct ns2__Transformation *a, const char *type)
{
	size_t soap_flag_Translate = 1;
	size_t soap_flag_Scale = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Transformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Transformation, sizeof(struct ns2__Transformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Transformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Translate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector(soap, "ns2:Translate", &a->Translate, "ns2:Vector"))
				{	soap_flag_Translate--;
					continue;
				}
			if (soap_flag_Scale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector(soap, "ns2:Scale", &a->Scale, "ns2:Vector"))
				{	soap_flag_Scale--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TransformationExtension(soap, "ns2:Extension", &a->Extension, "ns2:TransformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Transformation, 0, sizeof(struct ns2__Transformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Transformation(struct soap *soap, const struct ns2__Transformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Transformation);
	if (soap_out_ns2__Transformation(soap, tag?tag:"ns2:Transformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Transformation * SOAP_FMAC4 soap_get_ns2__Transformation(struct soap *soap, struct ns2__Transformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Appearance(struct soap *soap, struct ns2__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transformation = NULL;
	a->Shape = NULL;
	a->Color = NULL;
	a->Class = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Appearance(struct soap *soap, const struct ns2__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Transformation(soap, &a->Transformation);
	soap_serialize_PointerTons2__ShapeDescriptor(soap, &a->Shape);
	soap_serialize_PointerTons2__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerTons2__ClassDescriptor(soap, &a->Class);
	soap_serialize_PointerTons2__AppearanceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Appearance(struct soap *soap, const char *tag, int id, const struct ns2__Appearance *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Appearance), type))
		return soap->error;
	if (soap_out_PointerTons2__Transformation(soap, "ns2:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (soap_out_PointerTons2__ShapeDescriptor(soap, "ns2:Shape", -1, &a->Shape, ""))
		return soap->error;
	if (soap_out_PointerTons2__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTons2__ClassDescriptor(soap, "ns2:Class", -1, &a->Class, ""))
		return soap->error;
	if (soap_out_PointerTons2__AppearanceExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Appearance * SOAP_FMAC4 soap_in_ns2__Appearance(struct soap *soap, const char *tag, struct ns2__Appearance *a, const char *type)
{
	size_t soap_flag_Transformation = 1;
	size_t soap_flag_Shape = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Class = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Appearance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Appearance, sizeof(struct ns2__Appearance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Appearance(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Transformation(soap, "ns2:Transformation", &a->Transformation, "ns2:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap_flag_Shape && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShapeDescriptor(soap, "ns2:Shape", &a->Shape, "ns2:ShapeDescriptor"))
				{	soap_flag_Shape--;
					continue;
				}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ColorDescriptor(soap, "ns2:Color", &a->Color, "ns2:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Class && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ClassDescriptor(soap, "ns2:Class", &a->Class, "ns2:ClassDescriptor"))
				{	soap_flag_Class--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AppearanceExtension(soap, "ns2:Extension", &a->Extension, "ns2:AppearanceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Appearance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Appearance, 0, sizeof(struct ns2__Appearance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Appearance(struct soap *soap, const struct ns2__Appearance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Appearance);
	if (soap_out_ns2__Appearance(soap, tag?tag:"ns2:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Appearance * SOAP_FMAC4 soap_get_ns2__Appearance(struct soap *soap, struct ns2__Appearance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ColorCovariance(struct soap *soap, struct ns2__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->XX);
	soap_default_float(soap, &a->YY);
	soap_default_float(soap, &a->ZZ);
	a->XY = NULL;
	a->XZ = NULL;
	a->YZ = NULL;
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ColorCovariance(struct soap *soap, const struct ns2__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ColorCovariance(struct soap *soap, const char *tag, int id, const struct ns2__ColorCovariance *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "XX", soap_float2s(soap, a->XX), 1);
	soap_set_attr(soap, "YY", soap_float2s(soap, a->YY), 1);
	soap_set_attr(soap, "ZZ", soap_float2s(soap, a->ZZ), 1);
	if (a->XY)
		soap_set_attr(soap, "XY", soap_float2s(soap, *a->XY), 1);
	if (a->XZ)
		soap_set_attr(soap, "XZ", soap_float2s(soap, *a->XZ), 1);
	if (a->YZ)
		soap_set_attr(soap, "YZ", soap_float2s(soap, *a->YZ), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", a->Colorspace, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ColorCovariance), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ColorCovariance * SOAP_FMAC4 soap_in_ns2__ColorCovariance(struct soap *soap, const char *tag, struct ns2__ColorCovariance *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ColorCovariance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ColorCovariance, sizeof(struct ns2__ColorCovariance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ColorCovariance(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "XX", 1), &a->XX))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "YY", 1), &a->YY))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "ZZ", 1), &a->ZZ))
		return NULL;
	{	const char *t = soap_attr_value(soap, "XY", 0);
		if (t)
		{
			if (!(a->XY = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XY))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "XZ", 0);
		if (t)
		{
			if (!(a->XZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "YZ", 0);
		if (t)
		{
			if (!(a->YZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->YZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Colorspace", 0), &a->Colorspace, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ColorCovariance, 0, sizeof(struct ns2__ColorCovariance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ColorCovariance(struct soap *soap, const struct ns2__ColorCovariance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ColorCovariance);
	if (soap_out_ns2__ColorCovariance(soap, tag?tag:"ns2:ColorCovariance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ColorCovariance * SOAP_FMAC4 soap_get_ns2__ColorCovariance(struct soap *soap, struct ns2__ColorCovariance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Color(struct soap *soap, struct ns2__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->X);
	soap_default_float(soap, &a->Y);
	soap_default_float(soap, &a->Z);
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Color(struct soap *soap, const struct ns2__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Color(struct soap *soap, const char *tag, int id, const struct ns2__Color *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "X", soap_float2s(soap, a->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, a->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, a->Z), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", a->Colorspace, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Color), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Color * SOAP_FMAC4 soap_in_ns2__Color(struct soap *soap, const char *tag, struct ns2__Color *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Color *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Color, sizeof(struct ns2__Color), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Color(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 1), &a->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 1), &a->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 1), &a->Z))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Colorspace", 0), &a->Colorspace, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Color, 0, sizeof(struct ns2__Color), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Color(struct soap *soap, const struct ns2__Color *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Color);
	if (soap_out_ns2__Color(soap, tag?tag:"ns2:Color", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Color * SOAP_FMAC4 soap_get_ns2__Color(struct soap *soap, struct ns2__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Polyline(struct soap *soap, struct ns2__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Polyline(struct soap *soap, const struct ns2__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_ns2__Vector);
			soap_serialize_ns2__Vector(soap, a->Point + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Polyline(struct soap *soap, const char *tag, int id, const struct ns2__Polyline *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Polyline), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
			if (soap_out_ns2__Vector(soap, "ns2:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Polyline * SOAP_FMAC4 soap_in_ns2__Polyline(struct soap *soap, const char *tag, struct ns2__Polyline *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Polyline *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Polyline, sizeof(struct ns2__Polyline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Polyline(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_new_block(soap);
					a->Point = (struct ns2__Vector *)soap_push_block(soap, soap_blist_Point, sizeof(struct ns2__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_ns2__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_ns2__Vector(soap, "ns2:Point", a->Point, "ns2:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
			a->Point = (struct ns2__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Polyline, 0, sizeof(struct ns2__Polyline), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Polyline(struct soap *soap, const struct ns2__Polyline *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Polyline);
	if (soap_out_ns2__Polyline(soap, tag?tag:"ns2:Polyline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Polyline * SOAP_FMAC4 soap_get_ns2__Polyline(struct soap *soap, struct ns2__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Polygon(struct soap *soap, struct ns2__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Polygon(struct soap *soap, const struct ns2__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_ns2__Vector);
			soap_serialize_ns2__Vector(soap, a->Point + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Polygon(struct soap *soap, const char *tag, int id, const struct ns2__Polygon *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Polygon), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
			if (soap_out_ns2__Vector(soap, "ns2:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Polygon * SOAP_FMAC4 soap_in_ns2__Polygon(struct soap *soap, const char *tag, struct ns2__Polygon *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Polygon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Polygon, sizeof(struct ns2__Polygon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Polygon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_new_block(soap);
					a->Point = (struct ns2__Vector *)soap_push_block(soap, soap_blist_Point, sizeof(struct ns2__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_ns2__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_ns2__Vector(soap, "ns2:Point", a->Point, "ns2:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
			a->Point = (struct ns2__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Polygon, 0, sizeof(struct ns2__Polygon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 3))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Polygon(struct soap *soap, const struct ns2__Polygon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Polygon);
	if (soap_out_ns2__Polygon(soap, tag?tag:"ns2:Polygon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Polygon * SOAP_FMAC4 soap_get_ns2__Polygon(struct soap *soap, struct ns2__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Vector(struct soap *soap, struct ns2__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->x = NULL;
	a->y = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Vector(struct soap *soap, const struct ns2__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Vector(struct soap *soap, const char *tag, int id, const struct ns2__Vector *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->x)
		soap_set_attr(soap, "x", soap_float2s(soap, *a->x), 1);
	if (a->y)
		soap_set_attr(soap, "y", soap_float2s(soap, *a->y), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Vector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Vector * SOAP_FMAC4 soap_in_ns2__Vector(struct soap *soap, const char *tag, struct ns2__Vector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Vector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Vector, sizeof(struct ns2__Vector), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Vector(soap, a);
	{	const char *t = soap_attr_value(soap, "x", 0);
		if (t)
		{
			if (!(a->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "y", 0);
		if (t)
		{
			if (!(a->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Vector, 0, sizeof(struct ns2__Vector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Vector(struct soap *soap, const struct ns2__Vector *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Vector);
	if (soap_out_ns2__Vector(soap, tag?tag:"ns2:Vector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Vector * SOAP_FMAC4 soap_get_ns2__Vector(struct soap *soap, struct ns2__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ItemListDescriptionExtension(struct soap *soap, struct ns2__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ItemListDescriptionExtension(struct soap *soap, const struct ns2__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const struct ns2__ItemListDescriptionExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ItemListDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_ns2__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct ns2__ItemListDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ItemListDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ItemListDescriptionExtension, sizeof(struct ns2__ItemListDescriptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ItemListDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ItemListDescriptionExtension, 0, sizeof(struct ns2__ItemListDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ItemListDescriptionExtension(struct soap *soap, const struct ns2__ItemListDescriptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ItemListDescriptionExtension);
	if (soap_out_ns2__ItemListDescriptionExtension(soap, tag?tag:"ns2:ItemListDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_ns2__ItemListDescriptionExtension(struct soap *soap, struct ns2__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ItemListDescription_ElementItemDescription(struct soap *soap, struct _ns2__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _ns2__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const struct _ns2__ItemListDescription_ElementItemDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_QName2s(soap, a->Type), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_in__ns2__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _ns2__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ItemListDescription_ElementItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription, sizeof(struct _ns2__ItemListDescription_ElementItemDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ItemListDescription_ElementItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap_s2QName(soap, soap_attr_value(soap, "Type", 1), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription, 0, sizeof(struct _ns2__ItemListDescription_ElementItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _ns2__ItemListDescription_ElementItemDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription);
	if (soap_out__ns2__ItemListDescription_ElementItemDescription(soap, tag?tag:"ns2:ItemListDescription-ElementItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_get__ns2__ItemListDescription_ElementItemDescription(struct soap *soap, struct _ns2__ItemListDescription_ElementItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _ns2__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _ns2__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const struct _ns2__ItemListDescription_SimpleItemDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_QName2s(soap, a->Type), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_in__ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _ns2__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ItemListDescription_SimpleItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription, sizeof(struct _ns2__ItemListDescription_SimpleItemDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ItemListDescription_SimpleItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap_s2QName(soap, soap_attr_value(soap, "Type", 1), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription, 0, sizeof(struct _ns2__ItemListDescription_SimpleItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _ns2__ItemListDescription_SimpleItemDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription);
	if (soap_out__ns2__ItemListDescription_SimpleItemDescription(soap, tag?tag:"ns2:ItemListDescription-SimpleItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_get__ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _ns2__ItemListDescription_SimpleItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MessageDescriptionExtension(struct soap *soap, struct ns2__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MessageDescriptionExtension(struct soap *soap, const struct ns2__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const struct ns2__MessageDescriptionExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MessageDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MessageDescriptionExtension * SOAP_FMAC4 soap_in_ns2__MessageDescriptionExtension(struct soap *soap, const char *tag, struct ns2__MessageDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MessageDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MessageDescriptionExtension, sizeof(struct ns2__MessageDescriptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MessageDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MessageDescriptionExtension, 0, sizeof(struct ns2__MessageDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MessageDescriptionExtension(struct soap *soap, const struct ns2__MessageDescriptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MessageDescriptionExtension);
	if (soap_out_ns2__MessageDescriptionExtension(soap, tag?tag:"ns2:MessageDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MessageDescriptionExtension * SOAP_FMAC4 soap_get_ns2__MessageDescriptionExtension(struct soap *soap, struct ns2__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ItemListDescription(struct soap *soap, struct ns2__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItemDescription = 0;
	a->SimpleItemDescription = NULL;
	a->__sizeElementItemDescription = 0;
	a->ElementItemDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ItemListDescription(struct soap *soap, const struct ns2__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItemDescription; i++)
		{
			soap_embedded(soap, a->SimpleItemDescription + i, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription);
			soap_serialize__ns2__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription + i);
		}
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeElementItemDescription; i++)
		{
			soap_embedded(soap, a->ElementItemDescription + i, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription);
			soap_serialize__ns2__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription + i);
		}
	}
	soap_serialize_PointerTons2__ItemListDescriptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ItemListDescription(struct soap *soap, const char *tag, int id, const struct ns2__ItemListDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ItemListDescription), type))
		return soap->error;
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItemDescription; i++)
			if (soap_out__ns2__ItemListDescription_SimpleItemDescription(soap, "ns2:SimpleItemDescription", -1, a->SimpleItemDescription + i, ""))
				return soap->error;
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeElementItemDescription; i++)
			if (soap_out__ns2__ItemListDescription_ElementItemDescription(soap, "ns2:ElementItemDescription", -1, a->ElementItemDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ItemListDescriptionExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ItemListDescription * SOAP_FMAC4 soap_in_ns2__ItemListDescription(struct soap *soap, const char *tag, struct ns2__ItemListDescription *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItemDescription = NULL;
	struct soap_blist *soap_blist_ElementItemDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ItemListDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ItemListDescription, sizeof(struct ns2__ItemListDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ItemListDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:SimpleItemDescription", 1, NULL))
			{	if (a->SimpleItemDescription == NULL)
				{	if (soap_blist_SimpleItemDescription == NULL)
						soap_blist_SimpleItemDescription = soap_new_block(soap);
					a->SimpleItemDescription = (struct _ns2__ItemListDescription_SimpleItemDescription *)soap_push_block(soap, soap_blist_SimpleItemDescription, sizeof(struct _ns2__ItemListDescription_SimpleItemDescription));
					if (a->SimpleItemDescription == NULL)
						return NULL;
					soap_default__ns2__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription);
				}
				soap_revert(soap);
				if (soap_in__ns2__ItemListDescription_SimpleItemDescription(soap, "ns2:SimpleItemDescription", a->SimpleItemDescription, ""))
				{	a->__sizeSimpleItemDescription++;
					a->SimpleItemDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ElementItemDescription", 1, NULL))
			{	if (a->ElementItemDescription == NULL)
				{	if (soap_blist_ElementItemDescription == NULL)
						soap_blist_ElementItemDescription = soap_new_block(soap);
					a->ElementItemDescription = (struct _ns2__ItemListDescription_ElementItemDescription *)soap_push_block(soap, soap_blist_ElementItemDescription, sizeof(struct _ns2__ItemListDescription_ElementItemDescription));
					if (a->ElementItemDescription == NULL)
						return NULL;
					soap_default__ns2__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription);
				}
				soap_revert(soap);
				if (soap_in__ns2__ItemListDescription_ElementItemDescription(soap, "ns2:ElementItemDescription", a->ElementItemDescription, ""))
				{	a->__sizeElementItemDescription++;
					a->ElementItemDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescriptionExtension(soap, "ns2:Extension", &a->Extension, "ns2:ItemListDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItemDescription)
			soap_pop_block(soap, soap_blist_SimpleItemDescription);
		if (a->__sizeSimpleItemDescription)
			a->SimpleItemDescription = (struct _ns2__ItemListDescription_SimpleItemDescription *)soap_save_block(soap, soap_blist_SimpleItemDescription, NULL, 1);
		else
		{	a->SimpleItemDescription = NULL;
			if (soap_blist_SimpleItemDescription)
				soap_end_block(soap, soap_blist_SimpleItemDescription);
		}
		if (a->ElementItemDescription)
			soap_pop_block(soap, soap_blist_ElementItemDescription);
		if (a->__sizeElementItemDescription)
			a->ElementItemDescription = (struct _ns2__ItemListDescription_ElementItemDescription *)soap_save_block(soap, soap_blist_ElementItemDescription, NULL, 1);
		else
		{	a->ElementItemDescription = NULL;
			if (soap_blist_ElementItemDescription)
				soap_end_block(soap, soap_blist_ElementItemDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ItemListDescription, 0, sizeof(struct ns2__ItemListDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ItemListDescription(struct soap *soap, const struct ns2__ItemListDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ItemListDescription);
	if (soap_out_ns2__ItemListDescription(soap, tag?tag:"ns2:ItemListDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemListDescription * SOAP_FMAC4 soap_get_ns2__ItemListDescription(struct soap *soap, struct ns2__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MessageDescription(struct soap *soap, struct ns2__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MessageDescription(struct soap *soap, const struct ns2__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTons2__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTons2__MessageDescriptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MessageDescription(struct soap *soap, const char *tag, int id, const struct ns2__MessageDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTons2__ItemListDescription(soap, "ns2:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTons2__MessageDescriptionExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MessageDescription * SOAP_FMAC4 soap_in_ns2__MessageDescription(struct soap *soap, const char *tag, struct ns2__MessageDescription *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MessageDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MessageDescription, sizeof(struct ns2__MessageDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MessageDescription(soap, a);
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Source", &a->Source, "ns2:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Key", &a->Key, "ns2:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListDescription(soap, "ns2:Data", &a->Data, "ns2:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MessageDescriptionExtension(soap, "ns2:Extension", &a->Extension, "ns2:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MessageDescription, 0, sizeof(struct ns2__MessageDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MessageDescription(struct soap *soap, const struct ns2__MessageDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MessageDescription);
	if (soap_out_ns2__MessageDescription(soap, tag?tag:"ns2:MessageDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MessageDescription * SOAP_FMAC4 soap_get_ns2__MessageDescription(struct soap *soap, struct ns2__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ItemListExtension(struct soap *soap, struct ns2__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ItemListExtension(struct soap *soap, const struct ns2__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ItemListExtension(struct soap *soap, const char *tag, int id, const struct ns2__ItemListExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ItemListExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ItemListExtension * SOAP_FMAC4 soap_in_ns2__ItemListExtension(struct soap *soap, const char *tag, struct ns2__ItemListExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ItemListExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ItemListExtension, sizeof(struct ns2__ItemListExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ItemListExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ItemListExtension, 0, sizeof(struct ns2__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ItemListExtension(struct soap *soap, const struct ns2__ItemListExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ItemListExtension);
	if (soap_out_ns2__ItemListExtension(soap, tag?tag:"ns2:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemListExtension * SOAP_FMAC4 soap_get_ns2__ItemListExtension(struct soap *soap, struct ns2__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ItemList_ElementItem(struct soap *soap, struct _ns2__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ItemList_ElementItem(struct soap *soap, const struct _ns2__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const struct _ns2__ItemList_ElementItem *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ItemList_ElementItem), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ItemList_ElementItem * SOAP_FMAC4 soap_in__ns2__ItemList_ElementItem(struct soap *soap, const char *tag, struct _ns2__ItemList_ElementItem *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ItemList_ElementItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ItemList_ElementItem, sizeof(struct _ns2__ItemList_ElementItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ItemList_ElementItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ItemList_ElementItem, 0, sizeof(struct _ns2__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ItemList_ElementItem(struct soap *soap, const struct _ns2__ItemList_ElementItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ItemList_ElementItem);
	if (soap_out__ns2__ItemList_ElementItem(soap, tag?tag:"ns2:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemList_ElementItem * SOAP_FMAC4 soap_get__ns2__ItemList_ElementItem(struct soap *soap, struct _ns2__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__ItemList_SimpleItem(struct soap *soap, struct _ns2__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__ItemList_SimpleItem(struct soap *soap, const struct _ns2__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const struct _ns2__ItemList_SimpleItem *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Value)
		soap_set_attr(soap, "Value", a->Value, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__ItemList_SimpleItem * SOAP_FMAC4 soap_in__ns2__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _ns2__ItemList_SimpleItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__ItemList_SimpleItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ItemList_SimpleItem, sizeof(struct _ns2__ItemList_SimpleItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__ItemList_SimpleItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Value", 1), &a->Value, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ItemList_SimpleItem, 0, sizeof(struct _ns2__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__ItemList_SimpleItem(struct soap *soap, const struct _ns2__ItemList_SimpleItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__ItemList_SimpleItem);
	if (soap_out__ns2__ItemList_SimpleItem(soap, tag?tag:"ns2:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemList_SimpleItem * SOAP_FMAC4 soap_get__ns2__ItemList_SimpleItem(struct soap *soap, struct _ns2__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ItemList(struct soap *soap, struct ns2__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItem = 0;
	a->SimpleItem = NULL;
	a->__sizeElementItem = 0;
	a->ElementItem = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ItemList(struct soap *soap, const struct ns2__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItem; i++)
		{
			soap_embedded(soap, a->SimpleItem + i, SOAP_TYPE__ns2__ItemList_SimpleItem);
			soap_serialize__ns2__ItemList_SimpleItem(soap, a->SimpleItem + i);
		}
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < a->__sizeElementItem; i++)
		{
			soap_embedded(soap, a->ElementItem + i, SOAP_TYPE__ns2__ItemList_ElementItem);
			soap_serialize__ns2__ItemList_ElementItem(soap, a->ElementItem + i);
		}
	}
	soap_serialize_PointerTons2__ItemListExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ItemList(struct soap *soap, const char *tag, int id, const struct ns2__ItemList *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ItemList), type))
		return soap->error;
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItem; i++)
			if (soap_out__ns2__ItemList_SimpleItem(soap, "ns2:SimpleItem", -1, a->SimpleItem + i, ""))
				return soap->error;
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < a->__sizeElementItem; i++)
			if (soap_out__ns2__ItemList_ElementItem(soap, "ns2:ElementItem", -1, a->ElementItem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__ItemListExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ItemList * SOAP_FMAC4 soap_in_ns2__ItemList(struct soap *soap, const char *tag, struct ns2__ItemList *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItem = NULL;
	struct soap_blist *soap_blist_ElementItem = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ItemList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ItemList, sizeof(struct ns2__ItemList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ItemList(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:SimpleItem", 1, NULL))
			{	if (a->SimpleItem == NULL)
				{	if (soap_blist_SimpleItem == NULL)
						soap_blist_SimpleItem = soap_new_block(soap);
					a->SimpleItem = (struct _ns2__ItemList_SimpleItem *)soap_push_block(soap, soap_blist_SimpleItem, sizeof(struct _ns2__ItemList_SimpleItem));
					if (a->SimpleItem == NULL)
						return NULL;
					soap_default__ns2__ItemList_SimpleItem(soap, a->SimpleItem);
				}
				soap_revert(soap);
				if (soap_in__ns2__ItemList_SimpleItem(soap, "ns2:SimpleItem", a->SimpleItem, ""))
				{	a->__sizeSimpleItem++;
					a->SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ElementItem", 1, NULL))
			{	if (a->ElementItem == NULL)
				{	if (soap_blist_ElementItem == NULL)
						soap_blist_ElementItem = soap_new_block(soap);
					a->ElementItem = (struct _ns2__ItemList_ElementItem *)soap_push_block(soap, soap_blist_ElementItem, sizeof(struct _ns2__ItemList_ElementItem));
					if (a->ElementItem == NULL)
						return NULL;
					soap_default__ns2__ItemList_ElementItem(soap, a->ElementItem);
				}
				soap_revert(soap);
				if (soap_in__ns2__ItemList_ElementItem(soap, "ns2:ElementItem", a->ElementItem, ""))
				{	a->__sizeElementItem++;
					a->ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ItemListExtension(soap, "ns2:Extension", &a->Extension, "ns2:ItemListExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem);
		if (a->__sizeSimpleItem)
			a->SimpleItem = (struct _ns2__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem, NULL, 1);
		else
		{	a->SimpleItem = NULL;
			if (soap_blist_SimpleItem)
				soap_end_block(soap, soap_blist_SimpleItem);
		}
		if (a->ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem);
		if (a->__sizeElementItem)
			a->ElementItem = (struct _ns2__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem, NULL, 1);
		else
		{	a->ElementItem = NULL;
			if (soap_blist_ElementItem)
				soap_end_block(soap, soap_blist_ElementItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ItemList, 0, sizeof(struct ns2__ItemList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ItemList(struct soap *soap, const struct ns2__ItemList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ItemList);
	if (soap_out_ns2__ItemList(soap, tag?tag:"ns2:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemList * SOAP_FMAC4 soap_get_ns2__ItemList(struct soap *soap, struct ns2__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MessageExtension(struct soap *soap, struct ns2__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MessageExtension(struct soap *soap, const struct ns2__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MessageExtension(struct soap *soap, const char *tag, int id, const struct ns2__MessageExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MessageExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MessageExtension * SOAP_FMAC4 soap_in_ns2__MessageExtension(struct soap *soap, const char *tag, struct ns2__MessageExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MessageExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MessageExtension, sizeof(struct ns2__MessageExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MessageExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MessageExtension, 0, sizeof(struct ns2__MessageExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MessageExtension(struct soap *soap, const struct ns2__MessageExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MessageExtension);
	if (soap_out_ns2__MessageExtension(soap, tag?tag:"ns2:MessageExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MessageExtension * SOAP_FMAC4 soap_get_ns2__MessageExtension(struct soap *soap, struct ns2__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusOptions20Extension(struct soap *soap, struct ns2__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusOptions20Extension(struct soap *soap, const struct ns2__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const struct ns2__FocusOptions20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusOptions20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusOptions20Extension * SOAP_FMAC4 soap_in_ns2__FocusOptions20Extension(struct soap *soap, const char *tag, struct ns2__FocusOptions20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusOptions20Extension, sizeof(struct ns2__FocusOptions20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusOptions20Extension, 0, sizeof(struct ns2__FocusOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusOptions20Extension(struct soap *soap, const struct ns2__FocusOptions20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusOptions20Extension);
	if (soap_out_ns2__FocusOptions20Extension(soap, tag?tag:"ns2:FocusOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusOptions20Extension * SOAP_FMAC4 soap_get_ns2__FocusOptions20Extension(struct soap *soap, struct ns2__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalanceOptions20Extension(struct soap *soap, struct ns2__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WhiteBalanceOptions20Extension(struct soap *soap, const struct ns2__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const struct ns2__WhiteBalanceOptions20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_ns2__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct ns2__WhiteBalanceOptions20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WhiteBalanceOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension, sizeof(struct ns2__WhiteBalanceOptions20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WhiteBalanceOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension, 0, sizeof(struct ns2__WhiteBalanceOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalanceOptions20Extension(struct soap *soap, const struct ns2__WhiteBalanceOptions20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension);
	if (soap_out_ns2__WhiteBalanceOptions20Extension(soap, tag?tag:"ns2:WhiteBalanceOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_ns2__WhiteBalanceOptions20Extension(struct soap *soap, struct ns2__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusConfiguration20Extension(struct soap *soap, struct ns2__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusConfiguration20Extension(struct soap *soap, const struct ns2__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const struct ns2__FocusConfiguration20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusConfiguration20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_ns2__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct ns2__FocusConfiguration20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusConfiguration20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusConfiguration20Extension, sizeof(struct ns2__FocusConfiguration20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusConfiguration20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusConfiguration20Extension, 0, sizeof(struct ns2__FocusConfiguration20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusConfiguration20Extension(struct soap *soap, const struct ns2__FocusConfiguration20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusConfiguration20Extension);
	if (soap_out_ns2__FocusConfiguration20Extension(soap, tag?tag:"ns2:FocusConfiguration20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_ns2__FocusConfiguration20Extension(struct soap *soap, struct ns2__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalance20Extension(struct soap *soap, struct ns2__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WhiteBalance20Extension(struct soap *soap, const struct ns2__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const struct ns2__WhiteBalance20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalance20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WhiteBalance20Extension * SOAP_FMAC4 soap_in_ns2__WhiteBalance20Extension(struct soap *soap, const char *tag, struct ns2__WhiteBalance20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WhiteBalance20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalance20Extension, sizeof(struct ns2__WhiteBalance20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WhiteBalance20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalance20Extension, 0, sizeof(struct ns2__WhiteBalance20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalance20Extension(struct soap *soap, const struct ns2__WhiteBalance20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalance20Extension);
	if (soap_out_ns2__WhiteBalance20Extension(soap, tag?tag:"ns2:WhiteBalance20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalance20Extension * SOAP_FMAC4 soap_get_ns2__WhiteBalance20Extension(struct soap *soap, struct ns2__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelativeFocusOptions20(struct soap *soap, struct ns2__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RelativeFocusOptions20(struct soap *soap, const struct ns2__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const struct ns2__RelativeFocusOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelativeFocusOptions20), type))
		return soap->error;
	if (a->Distance)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Distance", -1, &a->Distance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Distance"))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_ns2__RelativeFocusOptions20(struct soap *soap, const char *tag, struct ns2__RelativeFocusOptions20 *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RelativeFocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelativeFocusOptions20, sizeof(struct ns2__RelativeFocusOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RelativeFocusOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Distance", &a->Distance, "ns2:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Speed", &a->Speed, "ns2:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelativeFocusOptions20, 0, sizeof(struct ns2__RelativeFocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelativeFocusOptions20(struct soap *soap, const struct ns2__RelativeFocusOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelativeFocusOptions20);
	if (soap_out_ns2__RelativeFocusOptions20(soap, tag?tag:"ns2:RelativeFocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_ns2__RelativeFocusOptions20(struct soap *soap, struct ns2__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MoveOptions20(struct soap *soap, struct ns2__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MoveOptions20(struct soap *soap, const struct ns2__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTons2__RelativeFocusOptions20(soap, &a->Relative);
	soap_serialize_PointerTons2__ContinuousFocusOptions(soap, &a->Continuous);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MoveOptions20(struct soap *soap, const char *tag, int id, const struct ns2__MoveOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MoveOptions20), type))
		return soap->error;
	if (soap_out_PointerTons2__AbsoluteFocusOptions(soap, "ns2:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTons2__RelativeFocusOptions20(soap, "ns2:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTons2__ContinuousFocusOptions(soap, "ns2:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MoveOptions20 * SOAP_FMAC4 soap_in_ns2__MoveOptions20(struct soap *soap, const char *tag, struct ns2__MoveOptions20 *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MoveOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MoveOptions20, sizeof(struct ns2__MoveOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MoveOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbsoluteFocusOptions(soap, "ns2:Absolute", &a->Absolute, "ns2:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RelativeFocusOptions20(soap, "ns2:Relative", &a->Relative, "ns2:RelativeFocusOptions20"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContinuousFocusOptions(soap, "ns2:Continuous", &a->Continuous, "ns2:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MoveOptions20, 0, sizeof(struct ns2__MoveOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MoveOptions20(struct soap *soap, const struct ns2__MoveOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MoveOptions20);
	if (soap_out_ns2__MoveOptions20(soap, tag?tag:"ns2:MoveOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MoveOptions20 * SOAP_FMAC4 soap_get_ns2__MoveOptions20(struct soap *soap, struct ns2__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingOptions20Extension(struct soap *soap, struct ns2__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingOptions20Extension(struct soap *soap, const struct ns2__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const struct ns2__ImagingOptions20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingOptions20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingOptions20Extension * SOAP_FMAC4 soap_in_ns2__ImagingOptions20Extension(struct soap *soap, const char *tag, struct ns2__ImagingOptions20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingOptions20Extension, sizeof(struct ns2__ImagingOptions20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingOptions20Extension, 0, sizeof(struct ns2__ImagingOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingOptions20Extension(struct soap *soap, const struct ns2__ImagingOptions20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingOptions20Extension);
	if (soap_out_ns2__ImagingOptions20Extension(soap, tag?tag:"ns2:ImagingOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingOptions20Extension * SOAP_FMAC4 soap_get_ns2__ImagingOptions20Extension(struct soap *soap, struct ns2__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalanceOptions20(struct soap *soap, struct ns2__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WhiteBalanceOptions20(struct soap *soap, const struct ns2__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->YbGain);
	soap_serialize_PointerTons2__WhiteBalanceOptions20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const struct ns2__WhiteBalanceOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalanceOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__WhiteBalanceMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:YrGain", -1, &a->YrGain, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:YbGain", -1, &a->YbGain, ""))
		return soap->error;
	if (soap_out_PointerTons2__WhiteBalanceOptions20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_ns2__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct ns2__WhiteBalanceOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WhiteBalanceOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalanceOptions20, sizeof(struct ns2__WhiteBalanceOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WhiteBalanceOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__WhiteBalanceMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__WhiteBalanceMode(soap, "ns2:Mode", a->Mode, "ns2:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:YrGain", &a->YrGain, "ns2:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:YbGain", &a->YbGain, "ns2:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WhiteBalanceOptions20Extension(soap, "ns2:Extension", &a->Extension, "ns2:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalanceOptions20, 0, sizeof(struct ns2__WhiteBalanceOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalanceOptions20(struct soap *soap, const struct ns2__WhiteBalanceOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalanceOptions20);
	if (soap_out_ns2__WhiteBalanceOptions20(soap, tag?tag:"ns2:WhiteBalanceOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_ns2__WhiteBalanceOptions20(struct soap *soap, struct ns2__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WideDynamicRangeOptions20(struct soap *soap, struct ns2__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WideDynamicRangeOptions20(struct soap *soap, const struct ns2__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__WideDynamicMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const struct ns2__WideDynamicRangeOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WideDynamicRangeOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__WideDynamicMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_ns2__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct ns2__WideDynamicRangeOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WideDynamicRangeOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WideDynamicRangeOptions20, sizeof(struct ns2__WideDynamicRangeOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WideDynamicRangeOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__WideDynamicMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__WideDynamicMode(soap, "ns2:Mode", a->Mode, "ns2:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Level", &a->Level, "ns2:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WideDynamicRangeOptions20, 0, sizeof(struct ns2__WideDynamicRangeOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WideDynamicRangeOptions20(struct soap *soap, const struct ns2__WideDynamicRangeOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WideDynamicRangeOptions20);
	if (soap_out_ns2__WideDynamicRangeOptions20(soap, tag?tag:"ns2:WideDynamicRangeOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_ns2__WideDynamicRangeOptions20(struct soap *soap, struct ns2__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusOptions20(struct soap *soap, struct ns2__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusOptions20(struct soap *soap, const struct ns2__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_ns2__AutoFocusMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTons2__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTons2__FloatRange(soap, &a->FarLimit);
	soap_serialize_PointerTons2__FocusOptions20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusOptions20(struct soap *soap, const char *tag, int id, const struct ns2__FocusOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusOptions20), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
			if (soap_out_ns2__AutoFocusMode(soap, "ns2:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTons2__FocusOptions20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusOptions20 * SOAP_FMAC4 soap_in_ns2__FocusOptions20(struct soap *soap, const char *tag, struct ns2__FocusOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusOptions20, sizeof(struct ns2__FocusOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_new_block(soap);
					a->AutoFocusModes = (enum ns2__AutoFocusMode *)soap_push_block(soap, soap_blist_AutoFocusModes, sizeof(enum ns2__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_ns2__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_ns2__AutoFocusMode(soap, "ns2:AutoFocusModes", a->AutoFocusModes, "ns2:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:DefaultSpeed", &a->DefaultSpeed, "ns2:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:NearLimit", &a->NearLimit, "ns2:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:FarLimit", &a->FarLimit, "ns2:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusOptions20Extension(soap, "ns2:Extension", &a->Extension, "ns2:FocusOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
			a->AutoFocusModes = (enum ns2__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusOptions20, 0, sizeof(struct ns2__FocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusOptions20(struct soap *soap, const struct ns2__FocusOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusOptions20);
	if (soap_out_ns2__FocusOptions20(soap, tag?tag:"ns2:FocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusOptions20 * SOAP_FMAC4 soap_get_ns2__FocusOptions20(struct soap *soap, struct ns2__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ExposureOptions20(struct soap *soap, struct ns2__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ExposureOptions20(struct soap *soap, const struct ns2__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_ns2__ExposurePriority);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTons2__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExposureOptions20(struct soap *soap, const char *tag, int id, const struct ns2__ExposureOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExposureOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__ExposureMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
			if (soap_out_ns2__ExposurePriority(soap, "ns2:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ExposureOptions20 * SOAP_FMAC4 soap_in_ns2__ExposureOptions20(struct soap *soap, const char *tag, struct ns2__ExposureOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ExposureOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExposureOptions20, sizeof(struct ns2__ExposureOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ExposureOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__ExposureMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__ExposureMode(soap, "ns2:Mode", a->Mode, "ns2:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_new_block(soap);
					a->Priority = (enum ns2__ExposurePriority *)soap_push_block(soap, soap_blist_Priority, sizeof(enum ns2__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_ns2__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_ns2__ExposurePriority(soap, "ns2:Priority", a->Priority, "ns2:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MinExposureTime", &a->MinExposureTime, "ns2:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MaxExposureTime", &a->MaxExposureTime, "ns2:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MinGain", &a->MinGain, "ns2:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MaxGain", &a->MaxGain, "ns2:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MinIris", &a->MinIris, "ns2:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MaxIris", &a->MaxIris, "ns2:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:ExposureTime", &a->ExposureTime, "ns2:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Gain", &a->Gain, "ns2:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Iris", &a->Iris, "ns2:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
			a->Priority = (enum ns2__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExposureOptions20, 0, sizeof(struct ns2__ExposureOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ExposureOptions20(struct soap *soap, const struct ns2__ExposureOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ExposureOptions20);
	if (soap_out_ns2__ExposureOptions20(soap, tag?tag:"ns2:ExposureOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ExposureOptions20 * SOAP_FMAC4 soap_get_ns2__ExposureOptions20(struct soap *soap, struct ns2__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BacklightCompensationOptions20(struct soap *soap, struct ns2__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BacklightCompensationOptions20(struct soap *soap, const struct ns2__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__BacklightCompensationMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const struct ns2__BacklightCompensationOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BacklightCompensationOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__BacklightCompensationMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_ns2__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct ns2__BacklightCompensationOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BacklightCompensationOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BacklightCompensationOptions20, sizeof(struct ns2__BacklightCompensationOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BacklightCompensationOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__BacklightCompensationMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__BacklightCompensationMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__BacklightCompensationMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__BacklightCompensationMode(soap, "ns2:Mode", a->Mode, "ns2:BacklightCompensationMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Level", &a->Level, "ns2:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__BacklightCompensationMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BacklightCompensationOptions20, 0, sizeof(struct ns2__BacklightCompensationOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BacklightCompensationOptions20(struct soap *soap, const struct ns2__BacklightCompensationOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BacklightCompensationOptions20);
	if (soap_out_ns2__BacklightCompensationOptions20(soap, tag?tag:"ns2:BacklightCompensationOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_ns2__BacklightCompensationOptions20(struct soap *soap, struct ns2__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingOptions20(struct soap *soap, struct ns2__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingOptions20(struct soap *soap, const struct ns2__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__BacklightCompensationOptions20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTons2__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTons2__ExposureOptions20(soap, &a->Exposure);
	soap_serialize_PointerTons2__FocusOptions20(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_ns2__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTons2__WideDynamicRangeOptions20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTons2__WhiteBalanceOptions20(soap, &a->WhiteBalance);
	soap_serialize_PointerTons2__ImagingOptions20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingOptions20(struct soap *soap, const char *tag, int id, const struct ns2__ImagingOptions20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingOptions20), type))
		return soap->error;
	if (soap_out_PointerTons2__BacklightCompensationOptions20(soap, "ns2:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTons2__ExposureOptions20(soap, "ns2:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTons2__FocusOptions20(soap, "ns2:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
			if (soap_out_ns2__IrCutFilterMode(soap, "ns2:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTons2__WideDynamicRangeOptions20(soap, "ns2:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTons2__WhiteBalanceOptions20(soap, "ns2:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTons2__ImagingOptions20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingOptions20 * SOAP_FMAC4 soap_in_ns2__ImagingOptions20(struct soap *soap, const char *tag, struct ns2__ImagingOptions20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingOptions20, sizeof(struct ns2__ImagingOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingOptions20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BacklightCompensationOptions20(soap, "ns2:BacklightCompensation", &a->BacklightCompensation, "ns2:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Brightness", &a->Brightness, "ns2:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:ColorSaturation", &a->ColorSaturation, "ns2:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Contrast", &a->Contrast, "ns2:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExposureOptions20(soap, "ns2:Exposure", &a->Exposure, "ns2:ExposureOptions20"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusOptions20(soap, "ns2:Focus", &a->Focus, "ns2:FocusOptions20"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_new_block(soap);
					a->IrCutFilterModes = (enum ns2__IrCutFilterMode *)soap_push_block(soap, soap_blist_IrCutFilterModes, sizeof(enum ns2__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_ns2__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_ns2__IrCutFilterMode(soap, "ns2:IrCutFilterModes", a->IrCutFilterModes, "ns2:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Sharpness", &a->Sharpness, "ns2:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WideDynamicRangeOptions20(soap, "ns2:WideDynamicRange", &a->WideDynamicRange, "ns2:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WhiteBalanceOptions20(soap, "ns2:WhiteBalance", &a->WhiteBalance, "ns2:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ImagingOptions20Extension(soap, "ns2:Extension", &a->Extension, "ns2:ImagingOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
			a->IrCutFilterModes = (enum ns2__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingOptions20, 0, sizeof(struct ns2__ImagingOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingOptions20(struct soap *soap, const struct ns2__ImagingOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingOptions20);
	if (soap_out_ns2__ImagingOptions20(soap, tag?tag:"ns2:ImagingOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingOptions20 * SOAP_FMAC4 soap_get_ns2__ImagingOptions20(struct soap *soap, struct ns2__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingSettingsExtension20(struct soap *soap, struct ns2__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingSettingsExtension20(struct soap *soap, const struct ns2__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const struct ns2__ImagingSettingsExtension20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingSettingsExtension20), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_ns2__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct ns2__ImagingSettingsExtension20 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingSettingsExtension20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingSettingsExtension20, sizeof(struct ns2__ImagingSettingsExtension20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingSettingsExtension20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingSettingsExtension20, 0, sizeof(struct ns2__ImagingSettingsExtension20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingSettingsExtension20(struct soap *soap, const struct ns2__ImagingSettingsExtension20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingSettingsExtension20);
	if (soap_out_ns2__ImagingSettingsExtension20(soap, tag?tag:"ns2:ImagingSettingsExtension20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_ns2__ImagingSettingsExtension20(struct soap *soap, struct ns2__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalance20(struct soap *soap, struct ns2__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__WhiteBalanceMode(soap, &a->Mode);
	a->CrGain = NULL;
	a->CbGain = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WhiteBalance20(struct soap *soap, const struct ns2__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__WhiteBalanceMode);
	soap_serialize_PointerTofloat(soap, &a->CrGain);
	soap_serialize_PointerTofloat(soap, &a->CbGain);
	soap_serialize_PointerTons2__WhiteBalance20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalance20(struct soap *soap, const char *tag, int id, const struct ns2__WhiteBalance20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalance20), type))
		return soap->error;
	if (soap_out_ns2__WhiteBalanceMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:CrGain", -1, &a->CrGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:CbGain", -1, &a->CbGain, ""))
		return soap->error;
	if (soap_out_PointerTons2__WhiteBalance20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WhiteBalance20 * SOAP_FMAC4 soap_in_ns2__WhiteBalance20(struct soap *soap, const char *tag, struct ns2__WhiteBalance20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WhiteBalance20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalance20, sizeof(struct ns2__WhiteBalance20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WhiteBalance20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__WhiteBalanceMode(soap, "ns2:Mode", &a->Mode, "ns2:WhiteBalanceMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:CrGain", &a->CrGain, "xsd:float"))
				{	soap_flag_CrGain--;
					continue;
				}
			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:CbGain", &a->CbGain, "xsd:float"))
				{	soap_flag_CbGain--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WhiteBalance20Extension(soap, "ns2:Extension", &a->Extension, "ns2:WhiteBalance20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalance20, 0, sizeof(struct ns2__WhiteBalance20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalance20(struct soap *soap, const struct ns2__WhiteBalance20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalance20);
	if (soap_out_ns2__WhiteBalance20(soap, tag?tag:"ns2:WhiteBalance20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalance20 * SOAP_FMAC4 soap_get_ns2__WhiteBalance20(struct soap *soap, struct ns2__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WideDynamicRange20(struct soap *soap, struct ns2__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__WideDynamicMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WideDynamicRange20(struct soap *soap, const struct ns2__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__WideDynamicMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WideDynamicRange20(struct soap *soap, const char *tag, int id, const struct ns2__WideDynamicRange20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WideDynamicRange20), type))
		return soap->error;
	if (soap_out_ns2__WideDynamicMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WideDynamicRange20 * SOAP_FMAC4 soap_in_ns2__WideDynamicRange20(struct soap *soap, const char *tag, struct ns2__WideDynamicRange20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WideDynamicRange20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WideDynamicRange20, sizeof(struct ns2__WideDynamicRange20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WideDynamicRange20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__WideDynamicMode(soap, "ns2:Mode", &a->Mode, "ns2:WideDynamicMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WideDynamicRange20, 0, sizeof(struct ns2__WideDynamicRange20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WideDynamicRange20(struct soap *soap, const struct ns2__WideDynamicRange20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WideDynamicRange20);
	if (soap_out_ns2__WideDynamicRange20(soap, tag?tag:"ns2:WideDynamicRange20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRange20 * SOAP_FMAC4 soap_get_ns2__WideDynamicRange20(struct soap *soap, struct ns2__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusConfiguration20(struct soap *soap, struct ns2__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__AutoFocusMode(soap, &a->AutoFocusMode);
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusConfiguration20(struct soap *soap, const struct ns2__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_ns2__AutoFocusMode);
	soap_serialize_PointerTofloat(soap, &a->DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &a->NearLimit);
	soap_serialize_PointerTofloat(soap, &a->FarLimit);
	soap_serialize_PointerTons2__FocusConfiguration20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusConfiguration20(struct soap *soap, const char *tag, int id, const struct ns2__FocusConfiguration20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusConfiguration20), type))
		return soap->error;
	if (soap_out_ns2__AutoFocusMode(soap, "ns2:AutoFocusMode", -1, &a->AutoFocusMode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (a->Extension)
	{	if (soap_out_PointerTons2__FocusConfiguration20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Extension"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20 * SOAP_FMAC4 soap_in_ns2__FocusConfiguration20(struct soap *soap, const char *tag, struct ns2__FocusConfiguration20 *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusConfiguration20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusConfiguration20, sizeof(struct ns2__FocusConfiguration20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusConfiguration20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AutoFocusMode(soap, "ns2:AutoFocusMode", &a->AutoFocusMode, "ns2:AutoFocusMode"))
				{	soap_flag_AutoFocusMode--;
					continue;
				}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:NearLimit", &a->NearLimit, "xsd:float"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:FarLimit", &a->FarLimit, "xsd:float"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusConfiguration20Extension(soap, "ns2:Extension", &a->Extension, "ns2:FocusConfiguration20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusConfiguration20, 0, sizeof(struct ns2__FocusConfiguration20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0 || soap_flag_Extension > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusConfiguration20(struct soap *soap, const struct ns2__FocusConfiguration20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusConfiguration20);
	if (soap_out_ns2__FocusConfiguration20(soap, tag?tag:"ns2:FocusConfiguration20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20 * SOAP_FMAC4 soap_get_ns2__FocusConfiguration20(struct soap *soap, struct ns2__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Exposure20(struct soap *soap, struct ns2__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ExposureMode(soap, &a->Mode);
	a->Priority = NULL;
	a->Window = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Exposure20(struct soap *soap, const struct ns2__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__ExposureMode);
	soap_serialize_PointerTons2__ExposurePriority(soap, &a->Priority);
	soap_serialize_PointerTons2__Rectangle(soap, &a->Window);
	soap_serialize_PointerTofloat(soap, &a->MinExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MinGain);
	soap_serialize_PointerTofloat(soap, &a->MaxGain);
	soap_serialize_PointerTofloat(soap, &a->MinIris);
	soap_serialize_PointerTofloat(soap, &a->MaxIris);
	soap_serialize_PointerTofloat(soap, &a->ExposureTime);
	soap_serialize_PointerTofloat(soap, &a->Gain);
	soap_serialize_PointerTofloat(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Exposure20(struct soap *soap, const char *tag, int id, const struct ns2__Exposure20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Exposure20), type))
		return soap->error;
	if (soap_out_ns2__ExposureMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTons2__ExposurePriority(soap, "ns2:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (soap_out_PointerTons2__Rectangle(soap, "ns2:Window", -1, &a->Window, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Exposure20 * SOAP_FMAC4 soap_in_ns2__Exposure20(struct soap *soap, const char *tag, struct ns2__Exposure20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Exposure20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Exposure20, sizeof(struct ns2__Exposure20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Exposure20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ExposureMode(soap, "ns2:Mode", &a->Mode, "ns2:ExposureMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExposurePriority(soap, "ns2:Priority", &a->Priority, "ns2:ExposurePriority"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Rectangle(soap, "ns2:Window", &a->Window, "ns2:Rectangle"))
				{	soap_flag_Window--;
					continue;
				}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:MinExposureTime", &a->MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:MinGain", &a->MinGain, "xsd:float"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:MaxGain", &a->MaxGain, "xsd:float"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:MinIris", &a->MinIris, "xsd:float"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:MaxIris", &a->MaxIris, "xsd:float"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:ExposureTime", &a->ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Gain", &a->Gain, "xsd:float"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Iris", &a->Iris, "xsd:float"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Exposure20, 0, sizeof(struct ns2__Exposure20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Exposure20(struct soap *soap, const struct ns2__Exposure20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Exposure20);
	if (soap_out_ns2__Exposure20(soap, tag?tag:"ns2:Exposure20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Exposure20 * SOAP_FMAC4 soap_get_ns2__Exposure20(struct soap *soap, struct ns2__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BacklightCompensation20(struct soap *soap, struct ns2__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__BacklightCompensationMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BacklightCompensation20(struct soap *soap, const struct ns2__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__BacklightCompensationMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BacklightCompensation20(struct soap *soap, const char *tag, int id, const struct ns2__BacklightCompensation20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BacklightCompensation20), type))
		return soap->error;
	if (soap_out_ns2__BacklightCompensationMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BacklightCompensation20 * SOAP_FMAC4 soap_in_ns2__BacklightCompensation20(struct soap *soap, const char *tag, struct ns2__BacklightCompensation20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BacklightCompensation20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BacklightCompensation20, sizeof(struct ns2__BacklightCompensation20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BacklightCompensation20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__BacklightCompensationMode(soap, "ns2:Mode", &a->Mode, "ns2:BacklightCompensationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BacklightCompensation20, 0, sizeof(struct ns2__BacklightCompensation20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BacklightCompensation20(struct soap *soap, const struct ns2__BacklightCompensation20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BacklightCompensation20);
	if (soap_out_ns2__BacklightCompensation20(soap, tag?tag:"ns2:BacklightCompensation20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensation20 * SOAP_FMAC4 soap_get_ns2__BacklightCompensation20(struct soap *soap, struct ns2__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingSettings20(struct soap *soap, struct ns2__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingSettings20(struct soap *soap, const struct ns2__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__BacklightCompensation20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTons2__Exposure20(soap, &a->Exposure);
	soap_serialize_PointerTons2__FocusConfiguration20(soap, &a->Focus);
	soap_serialize_PointerTons2__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTons2__WideDynamicRange20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTons2__WhiteBalance20(soap, &a->WhiteBalance);
	soap_serialize_PointerTons2__ImagingSettingsExtension20(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingSettings20(struct soap *soap, const char *tag, int id, const struct ns2__ImagingSettings20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingSettings20), type))
		return soap->error;
	if (soap_out_PointerTons2__BacklightCompensation20(soap, "ns2:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTons2__Exposure20(soap, "ns2:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTons2__FocusConfiguration20(soap, "ns2:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (soap_out_PointerTons2__IrCutFilterMode(soap, "ns2:IrCutFilter", -1, &a->IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTons2__WideDynamicRange20(soap, "ns2:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTons2__WhiteBalance20(soap, "ns2:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTons2__ImagingSettingsExtension20(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingSettings20 * SOAP_FMAC4 soap_in_ns2__ImagingSettings20(struct soap *soap, const char *tag, struct ns2__ImagingSettings20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingSettings20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingSettings20, sizeof(struct ns2__ImagingSettings20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingSettings20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BacklightCompensation20(soap, "ns2:BacklightCompensation", &a->BacklightCompensation, "ns2:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Brightness", &a->Brightness, "xsd:float"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:ColorSaturation", &a->ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Contrast", &a->Contrast, "xsd:float"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Exposure20(soap, "ns2:Exposure", &a->Exposure, "ns2:Exposure20"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusConfiguration20(soap, "ns2:Focus", &a->Focus, "ns2:FocusConfiguration20"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IrCutFilterMode(soap, "ns2:IrCutFilter", &a->IrCutFilter, "ns2:IrCutFilterMode"))
				{	soap_flag_IrCutFilter--;
					continue;
				}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Sharpness", &a->Sharpness, "xsd:float"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WideDynamicRange20(soap, "ns2:WideDynamicRange", &a->WideDynamicRange, "ns2:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WhiteBalance20(soap, "ns2:WhiteBalance", &a->WhiteBalance, "ns2:WhiteBalance20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ImagingSettingsExtension20(soap, "ns2:Extension", &a->Extension, "ns2:ImagingSettingsExtension20"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingSettings20, 0, sizeof(struct ns2__ImagingSettings20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingSettings20(struct soap *soap, const struct ns2__ImagingSettings20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingSettings20);
	if (soap_out_ns2__ImagingSettings20(soap, tag?tag:"ns2:ImagingSettings20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettings20 * SOAP_FMAC4 soap_get_ns2__ImagingSettings20(struct soap *soap, struct ns2__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusStatus20Extension(struct soap *soap, struct ns2__FocusStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusStatus20Extension(struct soap *soap, const struct ns2__FocusStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const struct ns2__FocusStatus20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusStatus20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusStatus20Extension * SOAP_FMAC4 soap_in_ns2__FocusStatus20Extension(struct soap *soap, const char *tag, struct ns2__FocusStatus20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusStatus20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusStatus20Extension, sizeof(struct ns2__FocusStatus20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusStatus20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusStatus20Extension, 0, sizeof(struct ns2__FocusStatus20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusStatus20Extension(struct soap *soap, const struct ns2__FocusStatus20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusStatus20Extension);
	if (soap_out_ns2__FocusStatus20Extension(soap, tag?tag:"ns2:FocusStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusStatus20Extension * SOAP_FMAC4 soap_get_ns2__FocusStatus20Extension(struct soap *soap, struct ns2__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingStatus20Extension(struct soap *soap, struct ns2__ImagingStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingStatus20Extension(struct soap *soap, const struct ns2__ImagingStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const struct ns2__ImagingStatus20Extension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingStatus20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingStatus20Extension * SOAP_FMAC4 soap_in_ns2__ImagingStatus20Extension(struct soap *soap, const char *tag, struct ns2__ImagingStatus20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingStatus20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingStatus20Extension, sizeof(struct ns2__ImagingStatus20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingStatus20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingStatus20Extension, 0, sizeof(struct ns2__ImagingStatus20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingStatus20Extension(struct soap *soap, const struct ns2__ImagingStatus20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingStatus20Extension);
	if (soap_out_ns2__ImagingStatus20Extension(soap, tag?tag:"ns2:ImagingStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingStatus20Extension * SOAP_FMAC4 soap_get_ns2__ImagingStatus20Extension(struct soap *soap, struct ns2__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusStatus20(struct soap *soap, struct ns2__FocusStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	soap_default_ns2__MoveStatus(soap, &a->MoveStatus);
	soap_default_string(soap, &a->Error);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusStatus20(struct soap *soap, const struct ns2__FocusStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_embedded(soap, &a->MoveStatus, SOAP_TYPE_ns2__MoveStatus);
	soap_serialize_string(soap, &a->Error);
	soap_serialize_PointerTons2__FocusStatus20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusStatus20(struct soap *soap, const char *tag, int id, const struct ns2__FocusStatus20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusStatus20), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_ns2__MoveStatus(soap, "ns2:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Error", -1, &a->Error, ""))
		return soap->error;
	if (soap_out_PointerTons2__FocusStatus20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusStatus20 * SOAP_FMAC4 soap_in_ns2__FocusStatus20(struct soap *soap, const char *tag, struct ns2__FocusStatus20 *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusStatus20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusStatus20, sizeof(struct ns2__FocusStatus20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusStatus20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__MoveStatus(soap, "ns2:MoveStatus", &a->MoveStatus, "ns2:MoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusStatus20Extension(soap, "ns2:Extension", &a->Extension, "ns2:FocusStatus20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusStatus20, 0, sizeof(struct ns2__FocusStatus20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusStatus20(struct soap *soap, const struct ns2__FocusStatus20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusStatus20);
	if (soap_out_ns2__FocusStatus20(soap, tag?tag:"ns2:FocusStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusStatus20 * SOAP_FMAC4 soap_get_ns2__FocusStatus20(struct soap *soap, struct ns2__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingStatus20(struct soap *soap, struct ns2__ImagingStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FocusStatus20 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingStatus20(struct soap *soap, const struct ns2__ImagingStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FocusStatus20(soap, &a->FocusStatus20);
	soap_serialize_PointerTons2__ImagingStatus20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingStatus20(struct soap *soap, const char *tag, int id, const struct ns2__ImagingStatus20 *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingStatus20), type))
		return soap->error;
	if (soap_out_PointerTons2__FocusStatus20(soap, "ns2:FocusStatus20", -1, &a->FocusStatus20, ""))
		return soap->error;
	if (soap_out_PointerTons2__ImagingStatus20Extension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingStatus20 * SOAP_FMAC4 soap_in_ns2__ImagingStatus20(struct soap *soap, const char *tag, struct ns2__ImagingStatus20 *a, const char *type)
{
	size_t soap_flag_FocusStatus20 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingStatus20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingStatus20, sizeof(struct ns2__ImagingStatus20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingStatus20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus20 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusStatus20(soap, "ns2:FocusStatus20", &a->FocusStatus20, "ns2:FocusStatus20"))
				{	soap_flag_FocusStatus20--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ImagingStatus20Extension(soap, "ns2:Extension", &a->Extension, "ns2:ImagingStatus20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingStatus20, 0, sizeof(struct ns2__ImagingStatus20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingStatus20(struct soap *soap, const struct ns2__ImagingStatus20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingStatus20);
	if (soap_out_ns2__ImagingStatus20(soap, tag?tag:"ns2:ImagingStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingStatus20 * SOAP_FMAC4 soap_get_ns2__ImagingStatus20(struct soap *soap, struct ns2__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ContinuousFocusOptions(struct soap *soap, struct ns2__ContinuousFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ContinuousFocusOptions(struct soap *soap, const struct ns2__ContinuousFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const struct ns2__ContinuousFocusOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContinuousFocusOptions), type))
		return soap->error;
	if (a->Speed)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Speed", -1, &a->Speed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Speed"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ContinuousFocusOptions * SOAP_FMAC4 soap_in_ns2__ContinuousFocusOptions(struct soap *soap, const char *tag, struct ns2__ContinuousFocusOptions *a, const char *type)
{
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ContinuousFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContinuousFocusOptions, sizeof(struct ns2__ContinuousFocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ContinuousFocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Speed", &a->Speed, "ns2:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContinuousFocusOptions, 0, sizeof(struct ns2__ContinuousFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ContinuousFocusOptions(struct soap *soap, const struct ns2__ContinuousFocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ContinuousFocusOptions);
	if (soap_out_ns2__ContinuousFocusOptions(soap, tag?tag:"ns2:ContinuousFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ContinuousFocusOptions * SOAP_FMAC4 soap_get_ns2__ContinuousFocusOptions(struct soap *soap, struct ns2__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelativeFocusOptions(struct soap *soap, struct ns2__RelativeFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RelativeFocusOptions(struct soap *soap, const struct ns2__RelativeFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelativeFocusOptions(struct soap *soap, const char *tag, int id, const struct ns2__RelativeFocusOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelativeFocusOptions), type))
		return soap->error;
	if (a->Distance)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Distance", -1, &a->Distance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Distance"))
		return soap->error;
	if (a->Speed)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Speed", -1, &a->Speed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Speed"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions * SOAP_FMAC4 soap_in_ns2__RelativeFocusOptions(struct soap *soap, const char *tag, struct ns2__RelativeFocusOptions *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RelativeFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelativeFocusOptions, sizeof(struct ns2__RelativeFocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RelativeFocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Distance", &a->Distance, "ns2:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Speed", &a->Speed, "ns2:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RelativeFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelativeFocusOptions, 0, sizeof(struct ns2__RelativeFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0 || soap_flag_Speed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelativeFocusOptions(struct soap *soap, const struct ns2__RelativeFocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelativeFocusOptions);
	if (soap_out_ns2__RelativeFocusOptions(soap, tag?tag:"ns2:RelativeFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions * SOAP_FMAC4 soap_get_ns2__RelativeFocusOptions(struct soap *soap, struct ns2__RelativeFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AbsoluteFocusOptions(struct soap *soap, struct ns2__AbsoluteFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AbsoluteFocusOptions(struct soap *soap, const struct ns2__AbsoluteFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FloatRange(soap, &a->Position);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const struct ns2__AbsoluteFocusOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbsoluteFocusOptions), type))
		return soap->error;
	if (a->Position)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Position", -1, &a->Position, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Position"))
		return soap->error;
	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_ns2__AbsoluteFocusOptions(struct soap *soap, const char *tag, struct ns2__AbsoluteFocusOptions *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AbsoluteFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbsoluteFocusOptions, sizeof(struct ns2__AbsoluteFocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AbsoluteFocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Position", &a->Position, "ns2:FloatRange"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Speed", &a->Speed, "ns2:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbsoluteFocusOptions, 0, sizeof(struct ns2__AbsoluteFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AbsoluteFocusOptions(struct soap *soap, const struct ns2__AbsoluteFocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AbsoluteFocusOptions);
	if (soap_out_ns2__AbsoluteFocusOptions(soap, tag?tag:"ns2:AbsoluteFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_ns2__AbsoluteFocusOptions(struct soap *soap, struct ns2__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MoveOptions(struct soap *soap, struct ns2__MoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MoveOptions(struct soap *soap, const struct ns2__MoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTons2__RelativeFocusOptions(soap, &a->Relative);
	soap_serialize_PointerTons2__ContinuousFocusOptions(soap, &a->Continuous);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MoveOptions(struct soap *soap, const char *tag, int id, const struct ns2__MoveOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MoveOptions), type))
		return soap->error;
	if (soap_out_PointerTons2__AbsoluteFocusOptions(soap, "ns2:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTons2__RelativeFocusOptions(soap, "ns2:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTons2__ContinuousFocusOptions(soap, "ns2:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MoveOptions * SOAP_FMAC4 soap_in_ns2__MoveOptions(struct soap *soap, const char *tag, struct ns2__MoveOptions *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MoveOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MoveOptions, sizeof(struct ns2__MoveOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MoveOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbsoluteFocusOptions(soap, "ns2:Absolute", &a->Absolute, "ns2:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RelativeFocusOptions(soap, "ns2:Relative", &a->Relative, "ns2:RelativeFocusOptions"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContinuousFocusOptions(soap, "ns2:Continuous", &a->Continuous, "ns2:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MoveOptions, 0, sizeof(struct ns2__MoveOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MoveOptions(struct soap *soap, const struct ns2__MoveOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MoveOptions);
	if (soap_out_ns2__MoveOptions(soap, tag?tag:"ns2:MoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MoveOptions * SOAP_FMAC4 soap_get_ns2__MoveOptions(struct soap *soap, struct ns2__MoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ContinuousFocus(struct soap *soap, struct ns2__ContinuousFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Speed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ContinuousFocus(struct soap *soap, const struct ns2__ContinuousFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Speed, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContinuousFocus(struct soap *soap, const char *tag, int id, const struct ns2__ContinuousFocus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContinuousFocus), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ContinuousFocus * SOAP_FMAC4 soap_in_ns2__ContinuousFocus(struct soap *soap, const char *tag, struct ns2__ContinuousFocus *a, const char *type)
{
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ContinuousFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContinuousFocus, sizeof(struct ns2__ContinuousFocus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ContinuousFocus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContinuousFocus, 0, sizeof(struct ns2__ContinuousFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ContinuousFocus(struct soap *soap, const struct ns2__ContinuousFocus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ContinuousFocus);
	if (soap_out_ns2__ContinuousFocus(soap, tag?tag:"ns2:ContinuousFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ContinuousFocus * SOAP_FMAC4 soap_get_ns2__ContinuousFocus(struct soap *soap, struct ns2__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelativeFocus(struct soap *soap, struct ns2__RelativeFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Distance);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RelativeFocus(struct soap *soap, const struct ns2__RelativeFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelativeFocus(struct soap *soap, const char *tag, int id, const struct ns2__RelativeFocus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelativeFocus), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Distance", -1, &a->Distance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RelativeFocus * SOAP_FMAC4 soap_in_ns2__RelativeFocus(struct soap *soap, const char *tag, struct ns2__RelativeFocus *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RelativeFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelativeFocus, sizeof(struct ns2__RelativeFocus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RelativeFocus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Distance", &a->Distance, "xsd:float"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelativeFocus, 0, sizeof(struct ns2__RelativeFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelativeFocus(struct soap *soap, const struct ns2__RelativeFocus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelativeFocus);
	if (soap_out_ns2__RelativeFocus(soap, tag?tag:"ns2:RelativeFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelativeFocus * SOAP_FMAC4 soap_get_ns2__RelativeFocus(struct soap *soap, struct ns2__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AbsoluteFocus(struct soap *soap, struct ns2__AbsoluteFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AbsoluteFocus(struct soap *soap, const struct ns2__AbsoluteFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbsoluteFocus(struct soap *soap, const char *tag, int id, const struct ns2__AbsoluteFocus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbsoluteFocus), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AbsoluteFocus * SOAP_FMAC4 soap_in_ns2__AbsoluteFocus(struct soap *soap, const char *tag, struct ns2__AbsoluteFocus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AbsoluteFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbsoluteFocus, sizeof(struct ns2__AbsoluteFocus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AbsoluteFocus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbsoluteFocus, 0, sizeof(struct ns2__AbsoluteFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AbsoluteFocus(struct soap *soap, const struct ns2__AbsoluteFocus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AbsoluteFocus);
	if (soap_out_ns2__AbsoluteFocus(soap, tag?tag:"ns2:AbsoluteFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AbsoluteFocus * SOAP_FMAC4 soap_get_ns2__AbsoluteFocus(struct soap *soap, struct ns2__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusMove(struct soap *soap, struct ns2__FocusMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusMove(struct soap *soap, const struct ns2__FocusMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbsoluteFocus(soap, &a->Absolute);
	soap_serialize_PointerTons2__RelativeFocus(soap, &a->Relative);
	soap_serialize_PointerTons2__ContinuousFocus(soap, &a->Continuous);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusMove(struct soap *soap, const char *tag, int id, const struct ns2__FocusMove *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusMove), type))
		return soap->error;
	if (soap_out_PointerTons2__AbsoluteFocus(soap, "ns2:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTons2__RelativeFocus(soap, "ns2:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTons2__ContinuousFocus(soap, "ns2:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusMove * SOAP_FMAC4 soap_in_ns2__FocusMove(struct soap *soap, const char *tag, struct ns2__FocusMove *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusMove, sizeof(struct ns2__FocusMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbsoluteFocus(soap, "ns2:Absolute", &a->Absolute, "ns2:AbsoluteFocus"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RelativeFocus(soap, "ns2:Relative", &a->Relative, "ns2:RelativeFocus"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContinuousFocus(soap, "ns2:Continuous", &a->Continuous, "ns2:ContinuousFocus"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusMove, 0, sizeof(struct ns2__FocusMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusMove(struct soap *soap, const struct ns2__FocusMove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusMove);
	if (soap_out_ns2__FocusMove(soap, tag?tag:"ns2:FocusMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusMove * SOAP_FMAC4 soap_get_ns2__FocusMove(struct soap *soap, struct ns2__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalanceOptions(struct soap *soap, struct ns2__WhiteBalanceOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WhiteBalanceOptions(struct soap *soap, const struct ns2__WhiteBalanceOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->YbGain);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, const struct ns2__WhiteBalanceOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalanceOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__WhiteBalanceMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->YrGain)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:YrGain", -1, &a->YrGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:YrGain"))
		return soap->error;
	if (a->YbGain)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:YbGain", -1, &a->YbGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:YbGain"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions * SOAP_FMAC4 soap_in_ns2__WhiteBalanceOptions(struct soap *soap, const char *tag, struct ns2__WhiteBalanceOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WhiteBalanceOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalanceOptions, sizeof(struct ns2__WhiteBalanceOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WhiteBalanceOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__WhiteBalanceMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__WhiteBalanceMode(soap, "ns2:Mode", a->Mode, "ns2:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:YrGain", &a->YrGain, "ns2:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:YbGain", &a->YbGain, "ns2:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalanceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalanceOptions, 0, sizeof(struct ns2__WhiteBalanceOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_YrGain > 0 || soap_flag_YbGain > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalanceOptions(struct soap *soap, const struct ns2__WhiteBalanceOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalanceOptions);
	if (soap_out_ns2__WhiteBalanceOptions(soap, tag?tag:"ns2:WhiteBalanceOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions * SOAP_FMAC4 soap_get_ns2__WhiteBalanceOptions(struct soap *soap, struct ns2__WhiteBalanceOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WideDynamicRangeOptions(struct soap *soap, struct ns2__WideDynamicRangeOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WideDynamicRangeOptions(struct soap *soap, const struct ns2__WideDynamicRangeOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__WideDynamicMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, const struct ns2__WideDynamicRangeOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WideDynamicRangeOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__WideDynamicMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Level)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Level", -1, &a->Level, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Level"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions * SOAP_FMAC4 soap_in_ns2__WideDynamicRangeOptions(struct soap *soap, const char *tag, struct ns2__WideDynamicRangeOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WideDynamicRangeOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WideDynamicRangeOptions, sizeof(struct ns2__WideDynamicRangeOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WideDynamicRangeOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__WideDynamicMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__WideDynamicMode(soap, "ns2:Mode", a->Mode, "ns2:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Level", &a->Level, "ns2:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRangeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WideDynamicRangeOptions, 0, sizeof(struct ns2__WideDynamicRangeOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WideDynamicRangeOptions(struct soap *soap, const struct ns2__WideDynamicRangeOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WideDynamicRangeOptions);
	if (soap_out_ns2__WideDynamicRangeOptions(soap, tag?tag:"ns2:WideDynamicRangeOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions * SOAP_FMAC4 soap_get_ns2__WideDynamicRangeOptions(struct soap *soap, struct ns2__WideDynamicRangeOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusOptions(struct soap *soap, struct ns2__FocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusOptions(struct soap *soap, const struct ns2__FocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_ns2__AutoFocusMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTons2__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTons2__FloatRange(soap, &a->FarLimit);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusOptions(struct soap *soap, const char *tag, int id, const struct ns2__FocusOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusOptions), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
			if (soap_out_ns2__AutoFocusMode(soap, "ns2:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (a->DefaultSpeed)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:DefaultSpeed", -1, &a->DefaultSpeed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:DefaultSpeed"))
		return soap->error;
	if (a->NearLimit)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:NearLimit", -1, &a->NearLimit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:NearLimit"))
		return soap->error;
	if (a->FarLimit)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:FarLimit", -1, &a->FarLimit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:FarLimit"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusOptions * SOAP_FMAC4 soap_in_ns2__FocusOptions(struct soap *soap, const char *tag, struct ns2__FocusOptions *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusOptions, sizeof(struct ns2__FocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_new_block(soap);
					a->AutoFocusModes = (enum ns2__AutoFocusMode *)soap_push_block(soap, soap_blist_AutoFocusModes, sizeof(enum ns2__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_ns2__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_ns2__AutoFocusMode(soap, "ns2:AutoFocusModes", a->AutoFocusModes, "ns2:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:DefaultSpeed", &a->DefaultSpeed, "ns2:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:NearLimit", &a->NearLimit, "ns2:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:FarLimit", &a->FarLimit, "ns2:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
			a->AutoFocusModes = (enum ns2__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusOptions, 0, sizeof(struct ns2__FocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DefaultSpeed > 0 || soap_flag_NearLimit > 0 || soap_flag_FarLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusOptions(struct soap *soap, const struct ns2__FocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusOptions);
	if (soap_out_ns2__FocusOptions(soap, tag?tag:"ns2:FocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusOptions * SOAP_FMAC4 soap_get_ns2__FocusOptions(struct soap *soap, struct ns2__FocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ExposureOptions(struct soap *soap, struct ns2__ExposureOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ExposureOptions(struct soap *soap, const struct ns2__ExposureOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_ns2__ExposurePriority);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTons2__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTons2__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExposureOptions(struct soap *soap, const char *tag, int id, const struct ns2__ExposureOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExposureOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__ExposureMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
			if (soap_out_ns2__ExposurePriority(soap, "ns2:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (a->MinExposureTime)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MinExposureTime", -1, &a->MinExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MinExposureTime"))
		return soap->error;
	if (a->MaxExposureTime)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MaxExposureTime", -1, &a->MaxExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MaxExposureTime"))
		return soap->error;
	if (a->MinGain)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MinGain", -1, &a->MinGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MinGain"))
		return soap->error;
	if (a->MaxGain)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MaxGain", -1, &a->MaxGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MaxGain"))
		return soap->error;
	if (a->MinIris)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MinIris", -1, &a->MinIris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MinIris"))
		return soap->error;
	if (a->MaxIris)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:MaxIris", -1, &a->MaxIris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:MaxIris"))
		return soap->error;
	if (a->ExposureTime)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:ExposureTime", -1, &a->ExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ExposureTime"))
		return soap->error;
	if (a->Gain)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Gain", -1, &a->Gain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Gain"))
		return soap->error;
	if (a->Iris)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Iris", -1, &a->Iris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Iris"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ExposureOptions * SOAP_FMAC4 soap_in_ns2__ExposureOptions(struct soap *soap, const char *tag, struct ns2__ExposureOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ExposureOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExposureOptions, sizeof(struct ns2__ExposureOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ExposureOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__ExposureMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__ExposureMode(soap, "ns2:Mode", a->Mode, "ns2:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_new_block(soap);
					a->Priority = (enum ns2__ExposurePriority *)soap_push_block(soap, soap_blist_Priority, sizeof(enum ns2__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_ns2__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_ns2__ExposurePriority(soap, "ns2:Priority", a->Priority, "ns2:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MinExposureTime", &a->MinExposureTime, "ns2:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MaxExposureTime", &a->MaxExposureTime, "ns2:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MinGain", &a->MinGain, "ns2:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MaxGain", &a->MaxGain, "ns2:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MinIris", &a->MinIris, "ns2:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:MaxIris", &a->MaxIris, "ns2:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:ExposureTime", &a->ExposureTime, "ns2:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Gain", &a->Gain, "ns2:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Iris", &a->Iris, "ns2:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
			a->Priority = (enum ns2__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ExposureOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExposureOptions, 0, sizeof(struct ns2__ExposureOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || a->__sizePriority < 1 || soap_flag_MinExposureTime > 0 || soap_flag_MaxExposureTime > 0 || soap_flag_MinGain > 0 || soap_flag_MaxGain > 0 || soap_flag_MinIris > 0 || soap_flag_MaxIris > 0 || soap_flag_ExposureTime > 0 || soap_flag_Gain > 0 || soap_flag_Iris > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ExposureOptions(struct soap *soap, const struct ns2__ExposureOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ExposureOptions);
	if (soap_out_ns2__ExposureOptions(soap, tag?tag:"ns2:ExposureOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ExposureOptions * SOAP_FMAC4 soap_get_ns2__ExposureOptions(struct soap *soap, struct ns2__ExposureOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BacklightCompensationOptions(struct soap *soap, struct ns2__BacklightCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BacklightCompensationOptions(struct soap *soap, const struct ns2__BacklightCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_ns2__WideDynamicMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, const struct ns2__BacklightCompensationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BacklightCompensationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_ns2__WideDynamicMode(soap, "ns2:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Level)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Level", -1, &a->Level, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Level"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions * SOAP_FMAC4 soap_in_ns2__BacklightCompensationOptions(struct soap *soap, const char *tag, struct ns2__BacklightCompensationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BacklightCompensationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BacklightCompensationOptions, sizeof(struct ns2__BacklightCompensationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BacklightCompensationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum ns2__WideDynamicMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum ns2__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_ns2__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_ns2__WideDynamicMode(soap, "ns2:Mode", a->Mode, "ns2:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Level", &a->Level, "ns2:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum ns2__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BacklightCompensationOptions, 0, sizeof(struct ns2__BacklightCompensationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BacklightCompensationOptions(struct soap *soap, const struct ns2__BacklightCompensationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BacklightCompensationOptions);
	if (soap_out_ns2__BacklightCompensationOptions(soap, tag?tag:"ns2:BacklightCompensationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions * SOAP_FMAC4 soap_get_ns2__BacklightCompensationOptions(struct soap *soap, struct ns2__BacklightCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingOptions(struct soap *soap, struct ns2__ImagingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingOptions(struct soap *soap, const struct ns2__ImagingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__BacklightCompensationOptions(soap, &a->BacklightCompensation);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTons2__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTons2__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTons2__ExposureOptions(soap, &a->Exposure);
	soap_serialize_PointerTons2__FocusOptions(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_ns2__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTons2__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTons2__WideDynamicRangeOptions(soap, &a->WideDynamicRange);
	soap_serialize_PointerTons2__WhiteBalanceOptions(soap, &a->WhiteBalance);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingOptions(struct soap *soap, const char *tag, int id, const struct ns2__ImagingOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingOptions), type))
		return soap->error;
	if (a->BacklightCompensation)
	{	if (soap_out_PointerTons2__BacklightCompensationOptions(soap, "ns2:BacklightCompensation", -1, &a->BacklightCompensation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:BacklightCompensation"))
		return soap->error;
	if (a->Brightness)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Brightness", -1, &a->Brightness, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Brightness"))
		return soap->error;
	if (a->ColorSaturation)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:ColorSaturation", -1, &a->ColorSaturation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ColorSaturation"))
		return soap->error;
	if (a->Contrast)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Contrast", -1, &a->Contrast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Contrast"))
		return soap->error;
	if (a->Exposure)
	{	if (soap_out_PointerTons2__ExposureOptions(soap, "ns2:Exposure", -1, &a->Exposure, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Exposure"))
		return soap->error;
	if (a->Focus)
	{	if (soap_out_PointerTons2__FocusOptions(soap, "ns2:Focus", -1, &a->Focus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Focus"))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
			if (soap_out_ns2__IrCutFilterMode(soap, "ns2:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (a->Sharpness)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:Sharpness", -1, &a->Sharpness, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Sharpness"))
		return soap->error;
	if (a->WideDynamicRange)
	{	if (soap_out_PointerTons2__WideDynamicRangeOptions(soap, "ns2:WideDynamicRange", -1, &a->WideDynamicRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:WideDynamicRange"))
		return soap->error;
	if (a->WhiteBalance)
	{	if (soap_out_PointerTons2__WhiteBalanceOptions(soap, "ns2:WhiteBalance", -1, &a->WhiteBalance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:WhiteBalance"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingOptions * SOAP_FMAC4 soap_in_ns2__ImagingOptions(struct soap *soap, const char *tag, struct ns2__ImagingOptions *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingOptions, sizeof(struct ns2__ImagingOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BacklightCompensationOptions(soap, "ns2:BacklightCompensation", &a->BacklightCompensation, "ns2:BacklightCompensationOptions"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Brightness", &a->Brightness, "ns2:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:ColorSaturation", &a->ColorSaturation, "ns2:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Contrast", &a->Contrast, "ns2:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExposureOptions(soap, "ns2:Exposure", &a->Exposure, "ns2:ExposureOptions"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusOptions(soap, "ns2:Focus", &a->Focus, "ns2:FocusOptions"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_new_block(soap);
					a->IrCutFilterModes = (enum ns2__IrCutFilterMode *)soap_push_block(soap, soap_blist_IrCutFilterModes, sizeof(enum ns2__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_ns2__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_ns2__IrCutFilterMode(soap, "ns2:IrCutFilterModes", a->IrCutFilterModes, "ns2:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:Sharpness", &a->Sharpness, "ns2:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WideDynamicRangeOptions(soap, "ns2:WideDynamicRange", &a->WideDynamicRange, "ns2:WideDynamicRangeOptions"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WhiteBalanceOptions(soap, "ns2:WhiteBalance", &a->WhiteBalance, "ns2:WhiteBalanceOptions"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
			a->IrCutFilterModes = (enum ns2__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingOptions, 0, sizeof(struct ns2__ImagingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BacklightCompensation > 0 || soap_flag_Brightness > 0 || soap_flag_ColorSaturation > 0 || soap_flag_Contrast > 0 || soap_flag_Exposure > 0 || soap_flag_Focus > 0 || a->__sizeIrCutFilterModes < 1 || soap_flag_Sharpness > 0 || soap_flag_WideDynamicRange > 0 || soap_flag_WhiteBalance > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingOptions(struct soap *soap, const struct ns2__ImagingOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingOptions);
	if (soap_out_ns2__ImagingOptions(soap, tag?tag:"ns2:ImagingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingOptions * SOAP_FMAC4 soap_get_ns2__ImagingOptions(struct soap *soap, struct ns2__ImagingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Rectangle(struct soap *soap, struct ns2__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bottom = NULL;
	a->top = NULL;
	a->right = NULL;
	a->left = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Rectangle(struct soap *soap, const struct ns2__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Rectangle(struct soap *soap, const char *tag, int id, const struct ns2__Rectangle *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->bottom)
		soap_set_attr(soap, "bottom", soap_float2s(soap, *a->bottom), 1);
	if (a->top)
		soap_set_attr(soap, "top", soap_float2s(soap, *a->top), 1);
	if (a->right)
		soap_set_attr(soap, "right", soap_float2s(soap, *a->right), 1);
	if (a->left)
		soap_set_attr(soap, "left", soap_float2s(soap, *a->left), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Rectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Rectangle * SOAP_FMAC4 soap_in_ns2__Rectangle(struct soap *soap, const char *tag, struct ns2__Rectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Rectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Rectangle, sizeof(struct ns2__Rectangle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Rectangle(soap, a);
	{	const char *t = soap_attr_value(soap, "bottom", 0);
		if (t)
		{
			if (!(a->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "top", 0);
		if (t)
		{
			if (!(a->top = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "right", 0);
		if (t)
		{
			if (!(a->right = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "left", 0);
		if (t)
		{
			if (!(a->left = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Rectangle, 0, sizeof(struct ns2__Rectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Rectangle(struct soap *soap, const struct ns2__Rectangle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Rectangle);
	if (soap_out_ns2__Rectangle(soap, tag?tag:"ns2:Rectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Rectangle * SOAP_FMAC4 soap_get_ns2__Rectangle(struct soap *soap, struct ns2__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingSettingsExtension(struct soap *soap, struct ns2__ImagingSettingsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingSettingsExtension(struct soap *soap, const struct ns2__ImagingSettingsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, const struct ns2__ImagingSettingsExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingSettingsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension * SOAP_FMAC4 soap_in_ns2__ImagingSettingsExtension(struct soap *soap, const char *tag, struct ns2__ImagingSettingsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingSettingsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingSettingsExtension, sizeof(struct ns2__ImagingSettingsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingSettingsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettingsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingSettingsExtension, 0, sizeof(struct ns2__ImagingSettingsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingSettingsExtension(struct soap *soap, const struct ns2__ImagingSettingsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingSettingsExtension);
	if (soap_out_ns2__ImagingSettingsExtension(soap, tag?tag:"ns2:ImagingSettingsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension * SOAP_FMAC4 soap_get_ns2__ImagingSettingsExtension(struct soap *soap, struct ns2__ImagingSettingsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WhiteBalance(struct soap *soap, struct ns2__WhiteBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__WhiteBalanceMode(soap, &a->Mode);
	soap_default_float(soap, &a->CrGain);
	soap_default_float(soap, &a->CbGain);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WhiteBalance(struct soap *soap, const struct ns2__WhiteBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__WhiteBalanceMode);
	soap_embedded(soap, &a->CrGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->CbGain, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WhiteBalance(struct soap *soap, const char *tag, int id, const struct ns2__WhiteBalance *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WhiteBalance), type))
		return soap->error;
	if (soap_out_ns2__WhiteBalanceMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:CrGain", -1, &a->CrGain, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:CbGain", -1, &a->CbGain, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WhiteBalance * SOAP_FMAC4 soap_in_ns2__WhiteBalance(struct soap *soap, const char *tag, struct ns2__WhiteBalance *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WhiteBalance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WhiteBalance, sizeof(struct ns2__WhiteBalance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WhiteBalance(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__WhiteBalanceMode(soap, "ns2:Mode", &a->Mode, "ns2:WhiteBalanceMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:CrGain", &a->CrGain, "xsd:float"))
				{	soap_flag_CrGain--;
					continue;
				}
			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:CbGain", &a->CbGain, "xsd:float"))
				{	soap_flag_CbGain--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WhiteBalance, 0, sizeof(struct ns2__WhiteBalance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_CrGain > 0 || soap_flag_CbGain > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WhiteBalance(struct soap *soap, const struct ns2__WhiteBalance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WhiteBalance);
	if (soap_out_ns2__WhiteBalance(soap, tag?tag:"ns2:WhiteBalance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalance * SOAP_FMAC4 soap_get_ns2__WhiteBalance(struct soap *soap, struct ns2__WhiteBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WideDynamicRange(struct soap *soap, struct ns2__WideDynamicRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__WideDynamicMode(soap, &a->Mode);
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__WideDynamicRange(struct soap *soap, const struct ns2__WideDynamicRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__WideDynamicMode);
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WideDynamicRange(struct soap *soap, const char *tag, int id, const struct ns2__WideDynamicRange *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WideDynamicRange), type))
		return soap->error;
	if (soap_out_ns2__WideDynamicMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__WideDynamicRange * SOAP_FMAC4 soap_in_ns2__WideDynamicRange(struct soap *soap, const char *tag, struct ns2__WideDynamicRange *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__WideDynamicRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WideDynamicRange, sizeof(struct ns2__WideDynamicRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__WideDynamicRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__WideDynamicMode(soap, "ns2:Mode", &a->Mode, "ns2:WideDynamicMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WideDynamicRange, 0, sizeof(struct ns2__WideDynamicRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WideDynamicRange(struct soap *soap, const struct ns2__WideDynamicRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WideDynamicRange);
	if (soap_out_ns2__WideDynamicRange(soap, tag?tag:"ns2:WideDynamicRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRange * SOAP_FMAC4 soap_get_ns2__WideDynamicRange(struct soap *soap, struct ns2__WideDynamicRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Exposure(struct soap *soap, struct ns2__Exposure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ExposureMode(soap, &a->Mode);
	soap_default_ns2__ExposurePriority(soap, &a->Priority);
	a->Window = NULL;
	soap_default_float(soap, &a->MinExposureTime);
	soap_default_float(soap, &a->MaxExposureTime);
	soap_default_float(soap, &a->MinGain);
	soap_default_float(soap, &a->MaxGain);
	soap_default_float(soap, &a->MinIris);
	soap_default_float(soap, &a->MaxIris);
	soap_default_float(soap, &a->ExposureTime);
	soap_default_float(soap, &a->Gain);
	soap_default_float(soap, &a->Iris);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Exposure(struct soap *soap, const struct ns2__Exposure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__ExposureMode);
	soap_embedded(soap, &a->Priority, SOAP_TYPE_ns2__ExposurePriority);
	soap_serialize_PointerTons2__Rectangle(soap, &a->Window);
	soap_embedded(soap, &a->MinExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->MinGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->MinIris, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxIris, SOAP_TYPE_float);
	soap_embedded(soap, &a->ExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->Gain, SOAP_TYPE_float);
	soap_embedded(soap, &a->Iris, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Exposure(struct soap *soap, const char *tag, int id, const struct ns2__Exposure *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Exposure), type))
		return soap->error;
	if (soap_out_ns2__ExposureMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_ns2__ExposurePriority(soap, "ns2:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Window)
	{	if (soap_out_PointerTons2__Rectangle(soap, "ns2:Window", -1, &a->Window, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Window"))
		return soap->error;
	if (soap_out_float(soap, "ns2:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Exposure * SOAP_FMAC4 soap_in_ns2__Exposure(struct soap *soap, const char *tag, struct ns2__Exposure *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Exposure *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Exposure, sizeof(struct ns2__Exposure), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Exposure(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ExposureMode(soap, "ns2:Mode", &a->Mode, "ns2:ExposureMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ExposurePriority(soap, "ns2:Priority", &a->Priority, "ns2:ExposurePriority"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Rectangle(soap, "ns2:Window", &a->Window, "ns2:Rectangle"))
				{	soap_flag_Window--;
					continue;
				}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:MinExposureTime", &a->MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:MinGain", &a->MinGain, "xsd:float"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:MaxGain", &a->MaxGain, "xsd:float"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:MinIris", &a->MinIris, "xsd:float"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:MaxIris", &a->MaxIris, "xsd:float"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:ExposureTime", &a->ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Gain", &a->Gain, "xsd:float"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Iris", &a->Iris, "xsd:float"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Exposure, 0, sizeof(struct ns2__Exposure), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Priority > 0 || soap_flag_Window > 0 || soap_flag_MinExposureTime > 0 || soap_flag_MaxExposureTime > 0 || soap_flag_MinGain > 0 || soap_flag_MaxGain > 0 || soap_flag_MinIris > 0 || soap_flag_MaxIris > 0 || soap_flag_ExposureTime > 0 || soap_flag_Gain > 0 || soap_flag_Iris > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Exposure(struct soap *soap, const struct ns2__Exposure *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Exposure);
	if (soap_out_ns2__Exposure(soap, tag?tag:"ns2:Exposure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Exposure * SOAP_FMAC4 soap_get_ns2__Exposure(struct soap *soap, struct ns2__Exposure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BacklightCompensation(struct soap *soap, struct ns2__BacklightCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__BacklightCompensationMode(soap, &a->Mode);
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BacklightCompensation(struct soap *soap, const struct ns2__BacklightCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_ns2__BacklightCompensationMode);
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BacklightCompensation(struct soap *soap, const char *tag, int id, const struct ns2__BacklightCompensation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BacklightCompensation), type))
		return soap->error;
	if (soap_out_ns2__BacklightCompensationMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BacklightCompensation * SOAP_FMAC4 soap_in_ns2__BacklightCompensation(struct soap *soap, const char *tag, struct ns2__BacklightCompensation *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BacklightCompensation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BacklightCompensation, sizeof(struct ns2__BacklightCompensation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BacklightCompensation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__BacklightCompensationMode(soap, "ns2:Mode", &a->Mode, "ns2:BacklightCompensationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BacklightCompensation, 0, sizeof(struct ns2__BacklightCompensation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BacklightCompensation(struct soap *soap, const struct ns2__BacklightCompensation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BacklightCompensation);
	if (soap_out_ns2__BacklightCompensation(soap, tag?tag:"ns2:BacklightCompensation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensation * SOAP_FMAC4 soap_get_ns2__BacklightCompensation(struct soap *soap, struct ns2__BacklightCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingSettings(struct soap *soap, struct ns2__ImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingSettings(struct soap *soap, const struct ns2__ImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__BacklightCompensation(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTons2__Exposure(soap, &a->Exposure);
	soap_serialize_PointerTons2__FocusConfiguration(soap, &a->Focus);
	soap_serialize_PointerTons2__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTons2__WideDynamicRange(soap, &a->WideDynamicRange);
	soap_serialize_PointerTons2__WhiteBalance(soap, &a->WhiteBalance);
	soap_serialize_PointerTons2__ImagingSettingsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingSettings(struct soap *soap, const char *tag, int id, const struct ns2__ImagingSettings *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingSettings), type))
		return soap->error;
	if (soap_out_PointerTons2__BacklightCompensation(soap, "ns2:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTons2__Exposure(soap, "ns2:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTons2__FocusConfiguration(soap, "ns2:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (soap_out_PointerTons2__IrCutFilterMode(soap, "ns2:IrCutFilter", -1, &a->IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns2:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTons2__WideDynamicRange(soap, "ns2:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTons2__WhiteBalance(soap, "ns2:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTons2__ImagingSettingsExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingSettings * SOAP_FMAC4 soap_in_ns2__ImagingSettings(struct soap *soap, const char *tag, struct ns2__ImagingSettings *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingSettings, sizeof(struct ns2__ImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingSettings(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BacklightCompensation(soap, "ns2:BacklightCompensation", &a->BacklightCompensation, "ns2:BacklightCompensation"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Brightness", &a->Brightness, "xsd:float"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:ColorSaturation", &a->ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Contrast", &a->Contrast, "xsd:float"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Exposure(soap, "ns2:Exposure", &a->Exposure, "ns2:Exposure"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusConfiguration(soap, "ns2:Focus", &a->Focus, "ns2:FocusConfiguration"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IrCutFilterMode(soap, "ns2:IrCutFilter", &a->IrCutFilter, "ns2:IrCutFilterMode"))
				{	soap_flag_IrCutFilter--;
					continue;
				}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns2:Sharpness", &a->Sharpness, "xsd:float"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WideDynamicRange(soap, "ns2:WideDynamicRange", &a->WideDynamicRange, "ns2:WideDynamicRange"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__WhiteBalance(soap, "ns2:WhiteBalance", &a->WhiteBalance, "ns2:WhiteBalance"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ImagingSettingsExtension(soap, "ns2:Extension", &a->Extension, "ns2:ImagingSettingsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingSettings, 0, sizeof(struct ns2__ImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingSettings(struct soap *soap, const struct ns2__ImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingSettings);
	if (soap_out_ns2__ImagingSettings(soap, tag?tag:"ns2:ImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettings * SOAP_FMAC4 soap_get_ns2__ImagingSettings(struct soap *soap, struct ns2__ImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusConfiguration(struct soap *soap, struct ns2__FocusConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__AutoFocusMode(soap, &a->AutoFocusMode);
	soap_default_float(soap, &a->DefaultSpeed);
	soap_default_float(soap, &a->NearLimit);
	soap_default_float(soap, &a->FarLimit);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusConfiguration(struct soap *soap, const struct ns2__FocusConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_ns2__AutoFocusMode);
	soap_embedded(soap, &a->DefaultSpeed, SOAP_TYPE_float);
	soap_embedded(soap, &a->NearLimit, SOAP_TYPE_float);
	soap_embedded(soap, &a->FarLimit, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__FocusConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusConfiguration), type))
		return soap->error;
	if (soap_out_ns2__AutoFocusMode(soap, "ns2:AutoFocusMode", -1, &a->AutoFocusMode, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusConfiguration * SOAP_FMAC4 soap_in_ns2__FocusConfiguration(struct soap *soap, const char *tag, struct ns2__FocusConfiguration *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusConfiguration, sizeof(struct ns2__FocusConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AutoFocusMode(soap, "ns2:AutoFocusMode", &a->AutoFocusMode, "ns2:AutoFocusMode"))
				{	soap_flag_AutoFocusMode--;
					continue;
				}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:NearLimit", &a->NearLimit, "xsd:float"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:FarLimit", &a->FarLimit, "xsd:float"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusConfiguration, 0, sizeof(struct ns2__FocusConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0 || soap_flag_DefaultSpeed > 0 || soap_flag_NearLimit > 0 || soap_flag_FarLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusConfiguration(struct soap *soap, const struct ns2__FocusConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusConfiguration);
	if (soap_out_ns2__FocusConfiguration(soap, tag?tag:"ns2:FocusConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusConfiguration * SOAP_FMAC4 soap_get_ns2__FocusConfiguration(struct soap *soap, struct ns2__FocusConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FocusStatus(struct soap *soap, struct ns2__FocusStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	soap_default_ns2__MoveStatus(soap, &a->MoveStatus);
	soap_default_string(soap, &a->Error);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FocusStatus(struct soap *soap, const struct ns2__FocusStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_embedded(soap, &a->MoveStatus, SOAP_TYPE_ns2__MoveStatus);
	soap_serialize_string(soap, &a->Error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FocusStatus(struct soap *soap, const char *tag, int id, const struct ns2__FocusStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FocusStatus), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_ns2__MoveStatus(soap, "ns2:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (a->Error)
	{	if (soap_out_string(soap, "ns2:Error", -1, &a->Error, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Error"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FocusStatus * SOAP_FMAC4 soap_in_ns2__FocusStatus(struct soap *soap, const char *tag, struct ns2__FocusStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FocusStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FocusStatus, sizeof(struct ns2__FocusStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FocusStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__MoveStatus(soap, "ns2:MoveStatus", &a->MoveStatus, "ns2:MoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FocusStatus, 0, sizeof(struct ns2__FocusStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0 || soap_flag_Error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FocusStatus(struct soap *soap, const struct ns2__FocusStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FocusStatus);
	if (soap_out_ns2__FocusStatus(soap, tag?tag:"ns2:FocusStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusStatus * SOAP_FMAC4 soap_get_ns2__FocusStatus(struct soap *soap, struct ns2__FocusStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingStatus(struct soap *soap, struct ns2__ImagingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FocusStatus = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingStatus(struct soap *soap, const struct ns2__ImagingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FocusStatus(soap, &a->FocusStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingStatus(struct soap *soap, const char *tag, int id, const struct ns2__ImagingStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingStatus), type))
		return soap->error;
	if (a->FocusStatus)
	{	if (soap_out_PointerTons2__FocusStatus(soap, "ns2:FocusStatus", -1, &a->FocusStatus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:FocusStatus"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingStatus * SOAP_FMAC4 soap_in_ns2__ImagingStatus(struct soap *soap, const char *tag, struct ns2__ImagingStatus *a, const char *type)
{
	size_t soap_flag_FocusStatus = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingStatus, sizeof(struct ns2__ImagingStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FocusStatus(soap, "ns2:FocusStatus", &a->FocusStatus, "ns2:FocusStatus"))
				{	soap_flag_FocusStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingStatus, 0, sizeof(struct ns2__ImagingStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FocusStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingStatus(struct soap *soap, const struct ns2__ImagingStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingStatus);
	if (soap_out_ns2__ImagingStatus(soap, tag?tag:"ns2:ImagingStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingStatus * SOAP_FMAC4 soap_get_ns2__ImagingStatus(struct soap *soap, struct ns2__ImagingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZPreset(struct soap *soap, struct ns2__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	a->PTZPosition = NULL;
	soap_default_ns2__ReferenceToken(soap, &a->token);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZPreset(struct soap *soap, const struct ns2__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_serialize_PointerTons2__PTZVector(soap, &a->PTZPosition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZPreset(struct soap *soap, const char *tag, int id, const struct ns2__PTZPreset *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZPreset), type))
		return soap->error;
	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZVector(soap, "ns2:PTZPosition", -1, &a->PTZPosition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZPreset * SOAP_FMAC4 soap_in_ns2__PTZPreset(struct soap *soap, const char *tag, struct ns2__PTZPreset *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_PTZPosition = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZPreset, sizeof(struct ns2__PTZPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZPreset(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 0), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_PTZPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZVector(soap, "ns2:PTZPosition", &a->PTZPosition, "ns2:PTZVector"))
				{	soap_flag_PTZPosition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZPreset, 0, sizeof(struct ns2__PTZPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZPreset(struct soap *soap, const struct ns2__PTZPreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZPreset);
	if (soap_out_ns2__PTZPreset(soap, tag?tag:"ns2:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZPreset * SOAP_FMAC4 soap_get_ns2__PTZPreset(struct soap *soap, struct ns2__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZMoveStatus(struct soap *soap, struct ns2__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZMoveStatus(struct soap *soap, const struct ns2__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MoveStatus(soap, &a->PanTilt);
	soap_serialize_PointerTons2__MoveStatus(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZMoveStatus(struct soap *soap, const char *tag, int id, const struct ns2__PTZMoveStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTons2__MoveStatus(soap, "ns2:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTons2__MoveStatus(soap, "ns2:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZMoveStatus * SOAP_FMAC4 soap_in_ns2__PTZMoveStatus(struct soap *soap, const char *tag, struct ns2__PTZMoveStatus *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZMoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZMoveStatus, sizeof(struct ns2__PTZMoveStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZMoveStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MoveStatus(soap, "ns2:PanTilt", &a->PanTilt, "ns2:MoveStatus"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MoveStatus(soap, "ns2:Zoom", &a->Zoom, "ns2:MoveStatus"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZMoveStatus, 0, sizeof(struct ns2__PTZMoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZMoveStatus(struct soap *soap, const struct ns2__PTZMoveStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZMoveStatus);
	if (soap_out_ns2__PTZMoveStatus(soap, tag?tag:"ns2:PTZMoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZMoveStatus * SOAP_FMAC4 soap_get_ns2__PTZMoveStatus(struct soap *soap, struct ns2__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZStatus(struct soap *soap, struct ns2__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->MoveStatus = NULL;
	soap_default_string(soap, &a->Error);
	soap_default_time(soap, &a->UtcTime);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZStatus(struct soap *soap, const struct ns2__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PTZVector(soap, &a->Position);
	soap_serialize_PointerTons2__PTZMoveStatus(soap, &a->MoveStatus);
	soap_serialize_string(soap, &a->Error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZStatus(struct soap *soap, const char *tag, int id, const struct ns2__PTZStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTons2__PTZVector(soap, "ns2:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZMoveStatus(soap, "ns2:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Error", -1, &a->Error, ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZStatus * SOAP_FMAC4 soap_in_ns2__PTZStatus(struct soap *soap, const char *tag, struct ns2__PTZStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_UtcTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZStatus, sizeof(struct ns2__PTZStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZVector(soap, "ns2:Position", &a->Position, "ns2:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZMoveStatus(soap, "ns2:MoveStatus", &a->MoveStatus, "ns2:PTZMoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZStatus, 0, sizeof(struct ns2__PTZStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZStatus(struct soap *soap, const struct ns2__PTZStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZStatus);
	if (soap_out_ns2__PTZStatus(soap, tag?tag:"ns2:PTZStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStatus * SOAP_FMAC4 soap_get_ns2__PTZStatus(struct soap *soap, struct ns2__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZSpeed(struct soap *soap, struct ns2__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZSpeed(struct soap *soap, const struct ns2__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTons2__Vector1D(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZSpeed(struct soap *soap, const char *tag, int id, const struct ns2__PTZSpeed *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTons2__Vector2D(soap, "ns2:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTons2__Vector1D(soap, "ns2:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZSpeed * SOAP_FMAC4 soap_in_ns2__PTZSpeed(struct soap *soap, const char *tag, struct ns2__PTZSpeed *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZSpeed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZSpeed, sizeof(struct ns2__PTZSpeed), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZSpeed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector2D(soap, "ns2:PanTilt", &a->PanTilt, "ns2:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector1D(soap, "ns2:Zoom", &a->Zoom, "ns2:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZSpeed, 0, sizeof(struct ns2__PTZSpeed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZSpeed(struct soap *soap, const struct ns2__PTZSpeed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZSpeed);
	if (soap_out_ns2__PTZSpeed(soap, tag?tag:"ns2:PTZSpeed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZSpeed * SOAP_FMAC4 soap_get_ns2__PTZSpeed(struct soap *soap, struct ns2__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZVector(struct soap *soap, struct ns2__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZVector(struct soap *soap, const struct ns2__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTons2__Vector1D(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZVector(struct soap *soap, const char *tag, int id, const struct ns2__PTZVector *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTons2__Vector2D(soap, "ns2:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTons2__Vector1D(soap, "ns2:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZVector * SOAP_FMAC4 soap_in_ns2__PTZVector(struct soap *soap, const char *tag, struct ns2__PTZVector *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZVector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZVector, sizeof(struct ns2__PTZVector), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZVector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector2D(soap, "ns2:PanTilt", &a->PanTilt, "ns2:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Vector1D(soap, "ns2:Zoom", &a->Zoom, "ns2:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZVector, 0, sizeof(struct ns2__PTZVector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZVector(struct soap *soap, const struct ns2__PTZVector *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZVector);
	if (soap_out_ns2__PTZVector(soap, tag?tag:"ns2:PTZVector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZVector * SOAP_FMAC4 soap_get_ns2__PTZVector(struct soap *soap, struct ns2__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Vector1D(struct soap *soap, struct ns2__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Vector1D(struct soap *soap, const struct ns2__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Vector1D(struct soap *soap, const char *tag, int id, const struct ns2__Vector1D *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	if (a->space)
		soap_set_attr(soap, "space", a->space, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Vector1D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Vector1D * SOAP_FMAC4 soap_in_ns2__Vector1D(struct soap *soap, const char *tag, struct ns2__Vector1D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Vector1D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Vector1D, sizeof(struct ns2__Vector1D), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Vector1D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "space", 0), &a->space, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Vector1D, 0, sizeof(struct ns2__Vector1D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Vector1D(struct soap *soap, const struct ns2__Vector1D *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Vector1D);
	if (soap_out_ns2__Vector1D(soap, tag?tag:"ns2:Vector1D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Vector1D * SOAP_FMAC4 soap_get_ns2__Vector1D(struct soap *soap, struct ns2__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Vector2D(struct soap *soap, struct ns2__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_float(soap, &a->y);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Vector2D(struct soap *soap, const struct ns2__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Vector2D(struct soap *soap, const char *tag, int id, const struct ns2__Vector2D *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, a->y), 1);
	if (a->space)
		soap_set_attr(soap, "space", a->space, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Vector2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Vector2D * SOAP_FMAC4 soap_in_ns2__Vector2D(struct soap *soap, const char *tag, struct ns2__Vector2D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Vector2D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Vector2D, sizeof(struct ns2__Vector2D), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Vector2D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 1), &a->y))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "space", 0), &a->space, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Vector2D, 0, sizeof(struct ns2__Vector2D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Vector2D(struct soap *soap, const struct ns2__Vector2D *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Vector2D);
	if (soap_out_ns2__Vector2D(soap, tag?tag:"ns2:Vector2D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Vector2D * SOAP_FMAC4 soap_get_ns2__Vector2D(struct soap *soap, struct ns2__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZSpacesExtension(struct soap *soap, struct ns2__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZSpacesExtension(struct soap *soap, const struct ns2__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const struct ns2__PTZSpacesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZSpacesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZSpacesExtension * SOAP_FMAC4 soap_in_ns2__PTZSpacesExtension(struct soap *soap, const char *tag, struct ns2__PTZSpacesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZSpacesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZSpacesExtension, sizeof(struct ns2__PTZSpacesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZSpacesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZSpacesExtension, 0, sizeof(struct ns2__PTZSpacesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZSpacesExtension(struct soap *soap, const struct ns2__PTZSpacesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZSpacesExtension);
	if (soap_out_ns2__PTZSpacesExtension(soap, tag?tag:"ns2:PTZSpacesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZSpacesExtension * SOAP_FMAC4 soap_get_ns2__PTZSpacesExtension(struct soap *soap, struct ns2__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Space1DDescription(struct soap *soap, struct ns2__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Space1DDescription(struct soap *soap, const struct ns2__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->URI);
	soap_serialize_PointerTons2__FloatRange(soap, &a->XRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Space1DDescription(struct soap *soap, const char *tag, int id, const struct ns2__Space1DDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Space1DDescription), type))
		return soap->error;
	if (a->URI)
	{	if (soap_out_xsd__anyURI(soap, "ns2:URI", -1, &a->URI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:URI"))
		return soap->error;
	if (a->XRange)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:XRange", -1, &a->XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Space1DDescription * SOAP_FMAC4 soap_in_ns2__Space1DDescription(struct soap *soap, const char *tag, struct ns2__Space1DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Space1DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Space1DDescription, sizeof(struct ns2__Space1DDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Space1DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:URI", &a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:XRange", &a->XRange, "ns2:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Space1DDescription, 0, sizeof(struct ns2__Space1DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Space1DDescription(struct soap *soap, const struct ns2__Space1DDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Space1DDescription);
	if (soap_out_ns2__Space1DDescription(soap, tag?tag:"ns2:Space1DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Space1DDescription * SOAP_FMAC4 soap_get_ns2__Space1DDescription(struct soap *soap, struct ns2__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ZoomLimits(struct soap *soap, struct ns2__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ZoomLimits(struct soap *soap, const struct ns2__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Space1DDescription(soap, &a->Range);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ZoomLimits(struct soap *soap, const char *tag, int id, const struct ns2__ZoomLimits *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ZoomLimits), type))
		return soap->error;
	if (a->Range)
	{	if (soap_out_PointerTons2__Space1DDescription(soap, "ns2:Range", -1, &a->Range, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Range"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ZoomLimits * SOAP_FMAC4 soap_in_ns2__ZoomLimits(struct soap *soap, const char *tag, struct ns2__ZoomLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ZoomLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ZoomLimits, sizeof(struct ns2__ZoomLimits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ZoomLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Space1DDescription(soap, "ns2:Range", &a->Range, "ns2:Space1DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ZoomLimits, 0, sizeof(struct ns2__ZoomLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ZoomLimits(struct soap *soap, const struct ns2__ZoomLimits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ZoomLimits);
	if (soap_out_ns2__ZoomLimits(soap, tag?tag:"ns2:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ZoomLimits * SOAP_FMAC4 soap_get_ns2__ZoomLimits(struct soap *soap, struct ns2__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Space2DDescription(struct soap *soap, struct ns2__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
	a->YRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Space2DDescription(struct soap *soap, const struct ns2__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->URI);
	soap_serialize_PointerTons2__FloatRange(soap, &a->XRange);
	soap_serialize_PointerTons2__FloatRange(soap, &a->YRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Space2DDescription(struct soap *soap, const char *tag, int id, const struct ns2__Space2DDescription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Space2DDescription), type))
		return soap->error;
	if (a->URI)
	{	if (soap_out_xsd__anyURI(soap, "ns2:URI", -1, &a->URI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:URI"))
		return soap->error;
	if (a->XRange)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:XRange", -1, &a->XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XRange"))
		return soap->error;
	if (a->YRange)
	{	if (soap_out_PointerTons2__FloatRange(soap, "ns2:YRange", -1, &a->YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:YRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Space2DDescription * SOAP_FMAC4 soap_in_ns2__Space2DDescription(struct soap *soap, const char *tag, struct ns2__Space2DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Space2DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Space2DDescription, sizeof(struct ns2__Space2DDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Space2DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:URI", &a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:XRange", &a->XRange, "ns2:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FloatRange(soap, "ns2:YRange", &a->YRange, "ns2:FloatRange"))
				{	soap_flag_YRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Space2DDescription, 0, sizeof(struct ns2__Space2DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0 || soap_flag_YRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Space2DDescription(struct soap *soap, const struct ns2__Space2DDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Space2DDescription);
	if (soap_out_ns2__Space2DDescription(soap, tag?tag:"ns2:Space2DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Space2DDescription * SOAP_FMAC4 soap_get_ns2__Space2DDescription(struct soap *soap, struct ns2__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PanTiltLimits(struct soap *soap, struct ns2__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PanTiltLimits(struct soap *soap, const struct ns2__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Space2DDescription(soap, &a->Range);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PanTiltLimits(struct soap *soap, const char *tag, int id, const struct ns2__PanTiltLimits *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PanTiltLimits), type))
		return soap->error;
	if (a->Range)
	{	if (soap_out_PointerTons2__Space2DDescription(soap, "ns2:Range", -1, &a->Range, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Range"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PanTiltLimits * SOAP_FMAC4 soap_in_ns2__PanTiltLimits(struct soap *soap, const char *tag, struct ns2__PanTiltLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PanTiltLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PanTiltLimits, sizeof(struct ns2__PanTiltLimits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PanTiltLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Space2DDescription(soap, "ns2:Range", &a->Range, "ns2:Space2DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PanTiltLimits, 0, sizeof(struct ns2__PanTiltLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PanTiltLimits(struct soap *soap, const struct ns2__PanTiltLimits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PanTiltLimits);
	if (soap_out_ns2__PanTiltLimits(soap, tag?tag:"ns2:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PanTiltLimits * SOAP_FMAC4 soap_get_ns2__PanTiltLimits(struct soap *soap, struct ns2__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZSpaces(struct soap *soap, struct ns2__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAbsolutePanTiltPositionSpace = 0;
	a->AbsolutePanTiltPositionSpace = NULL;
	a->__sizeAbsoluteZoomPositionSpace = 0;
	a->AbsoluteZoomPositionSpace = NULL;
	a->__sizeRelativePanTiltTranslationSpace = 0;
	a->RelativePanTiltTranslationSpace = NULL;
	a->__sizeRelativeZoomTranslationSpace = 0;
	a->RelativeZoomTranslationSpace = NULL;
	a->__sizeContinuousPanTiltVelocitySpace = 0;
	a->ContinuousPanTiltVelocitySpace = NULL;
	a->__sizeContinuousZoomVelocitySpace = 0;
	a->ContinuousZoomVelocitySpace = NULL;
	a->__sizePanTiltSpeedSpace = 0;
	a->PanTiltSpeedSpace = NULL;
	a->__sizeZoomSpeedSpace = 0;
	a->ZoomSpeedSpace = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZSpaces(struct soap *soap, const struct ns2__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsolutePanTiltPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsolutePanTiltPositionSpace + i, SOAP_TYPE_ns2__Space2DDescription);
			soap_serialize_ns2__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace + i);
		}
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsoluteZoomPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsoluteZoomPositionSpace + i, SOAP_TYPE_ns2__Space1DDescription);
			soap_serialize_ns2__Space1DDescription(soap, a->AbsoluteZoomPositionSpace + i);
		}
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativePanTiltTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativePanTiltTranslationSpace + i, SOAP_TYPE_ns2__Space2DDescription);
			soap_serialize_ns2__Space2DDescription(soap, a->RelativePanTiltTranslationSpace + i);
		}
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativeZoomTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativeZoomTranslationSpace + i, SOAP_TYPE_ns2__Space1DDescription);
			soap_serialize_ns2__Space1DDescription(soap, a->RelativeZoomTranslationSpace + i);
		}
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousPanTiltVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousPanTiltVelocitySpace + i, SOAP_TYPE_ns2__Space2DDescription);
			soap_serialize_ns2__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace + i);
		}
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousZoomVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousZoomVelocitySpace + i, SOAP_TYPE_ns2__Space1DDescription);
			soap_serialize_ns2__Space1DDescription(soap, a->ContinuousZoomVelocitySpace + i);
		}
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizePanTiltSpeedSpace; i++)
		{
			soap_embedded(soap, a->PanTiltSpeedSpace + i, SOAP_TYPE_ns2__Space1DDescription);
			soap_serialize_ns2__Space1DDescription(soap, a->PanTiltSpeedSpace + i);
		}
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizeZoomSpeedSpace; i++)
		{
			soap_embedded(soap, a->ZoomSpeedSpace + i, SOAP_TYPE_ns2__Space1DDescription);
			soap_serialize_ns2__Space1DDescription(soap, a->ZoomSpeedSpace + i);
		}
	}
	soap_serialize_PointerTons2__PTZSpacesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZSpaces(struct soap *soap, const char *tag, int id, const struct ns2__PTZSpaces *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZSpaces), type))
		return soap->error;
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsolutePanTiltPositionSpace; i++)
			if (soap_out_ns2__Space2DDescription(soap, "ns2:AbsolutePanTiltPositionSpace", -1, a->AbsolutePanTiltPositionSpace + i, ""))
				return soap->error;
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsoluteZoomPositionSpace; i++)
			if (soap_out_ns2__Space1DDescription(soap, "ns2:AbsoluteZoomPositionSpace", -1, a->AbsoluteZoomPositionSpace + i, ""))
				return soap->error;
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativePanTiltTranslationSpace; i++)
			if (soap_out_ns2__Space2DDescription(soap, "ns2:RelativePanTiltTranslationSpace", -1, a->RelativePanTiltTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativeZoomTranslationSpace; i++)
			if (soap_out_ns2__Space1DDescription(soap, "ns2:RelativeZoomTranslationSpace", -1, a->RelativeZoomTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousPanTiltVelocitySpace; i++)
			if (soap_out_ns2__Space2DDescription(soap, "ns2:ContinuousPanTiltVelocitySpace", -1, a->ContinuousPanTiltVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousZoomVelocitySpace; i++)
			if (soap_out_ns2__Space1DDescription(soap, "ns2:ContinuousZoomVelocitySpace", -1, a->ContinuousZoomVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizePanTiltSpeedSpace; i++)
			if (soap_out_ns2__Space1DDescription(soap, "ns2:PanTiltSpeedSpace", -1, a->PanTiltSpeedSpace + i, ""))
				return soap->error;
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizeZoomSpeedSpace; i++)
			if (soap_out_ns2__Space1DDescription(soap, "ns2:ZoomSpeedSpace", -1, a->ZoomSpeedSpace + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__PTZSpacesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZSpaces * SOAP_FMAC4 soap_in_ns2__PTZSpaces(struct soap *soap, const char *tag, struct ns2__PTZSpaces *a, const char *type)
{
	struct soap_blist *soap_blist_AbsolutePanTiltPositionSpace = NULL;
	struct soap_blist *soap_blist_AbsoluteZoomPositionSpace = NULL;
	struct soap_blist *soap_blist_RelativePanTiltTranslationSpace = NULL;
	struct soap_blist *soap_blist_RelativeZoomTranslationSpace = NULL;
	struct soap_blist *soap_blist_ContinuousPanTiltVelocitySpace = NULL;
	struct soap_blist *soap_blist_ContinuousZoomVelocitySpace = NULL;
	struct soap_blist *soap_blist_PanTiltSpeedSpace = NULL;
	struct soap_blist *soap_blist_ZoomSpeedSpace = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZSpaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZSpaces, sizeof(struct ns2__PTZSpaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZSpaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AbsolutePanTiltPositionSpace", 1, NULL))
			{	if (a->AbsolutePanTiltPositionSpace == NULL)
				{	if (soap_blist_AbsolutePanTiltPositionSpace == NULL)
						soap_blist_AbsolutePanTiltPositionSpace = soap_new_block(soap);
					a->AbsolutePanTiltPositionSpace = (struct ns2__Space2DDescription *)soap_push_block(soap, soap_blist_AbsolutePanTiltPositionSpace, sizeof(struct ns2__Space2DDescription));
					if (a->AbsolutePanTiltPositionSpace == NULL)
						return NULL;
					soap_default_ns2__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space2DDescription(soap, "ns2:AbsolutePanTiltPositionSpace", a->AbsolutePanTiltPositionSpace, "ns2:Space2DDescription"))
				{	a->__sizeAbsolutePanTiltPositionSpace++;
					a->AbsolutePanTiltPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:AbsoluteZoomPositionSpace", 1, NULL))
			{	if (a->AbsoluteZoomPositionSpace == NULL)
				{	if (soap_blist_AbsoluteZoomPositionSpace == NULL)
						soap_blist_AbsoluteZoomPositionSpace = soap_new_block(soap);
					a->AbsoluteZoomPositionSpace = (struct ns2__Space1DDescription *)soap_push_block(soap, soap_blist_AbsoluteZoomPositionSpace, sizeof(struct ns2__Space1DDescription));
					if (a->AbsoluteZoomPositionSpace == NULL)
						return NULL;
					soap_default_ns2__Space1DDescription(soap, a->AbsoluteZoomPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space1DDescription(soap, "ns2:AbsoluteZoomPositionSpace", a->AbsoluteZoomPositionSpace, "ns2:Space1DDescription"))
				{	a->__sizeAbsoluteZoomPositionSpace++;
					a->AbsoluteZoomPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:RelativePanTiltTranslationSpace", 1, NULL))
			{	if (a->RelativePanTiltTranslationSpace == NULL)
				{	if (soap_blist_RelativePanTiltTranslationSpace == NULL)
						soap_blist_RelativePanTiltTranslationSpace = soap_new_block(soap);
					a->RelativePanTiltTranslationSpace = (struct ns2__Space2DDescription *)soap_push_block(soap, soap_blist_RelativePanTiltTranslationSpace, sizeof(struct ns2__Space2DDescription));
					if (a->RelativePanTiltTranslationSpace == NULL)
						return NULL;
					soap_default_ns2__Space2DDescription(soap, a->RelativePanTiltTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space2DDescription(soap, "ns2:RelativePanTiltTranslationSpace", a->RelativePanTiltTranslationSpace, "ns2:Space2DDescription"))
				{	a->__sizeRelativePanTiltTranslationSpace++;
					a->RelativePanTiltTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:RelativeZoomTranslationSpace", 1, NULL))
			{	if (a->RelativeZoomTranslationSpace == NULL)
				{	if (soap_blist_RelativeZoomTranslationSpace == NULL)
						soap_blist_RelativeZoomTranslationSpace = soap_new_block(soap);
					a->RelativeZoomTranslationSpace = (struct ns2__Space1DDescription *)soap_push_block(soap, soap_blist_RelativeZoomTranslationSpace, sizeof(struct ns2__Space1DDescription));
					if (a->RelativeZoomTranslationSpace == NULL)
						return NULL;
					soap_default_ns2__Space1DDescription(soap, a->RelativeZoomTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space1DDescription(soap, "ns2:RelativeZoomTranslationSpace", a->RelativeZoomTranslationSpace, "ns2:Space1DDescription"))
				{	a->__sizeRelativeZoomTranslationSpace++;
					a->RelativeZoomTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ContinuousPanTiltVelocitySpace", 1, NULL))
			{	if (a->ContinuousPanTiltVelocitySpace == NULL)
				{	if (soap_blist_ContinuousPanTiltVelocitySpace == NULL)
						soap_blist_ContinuousPanTiltVelocitySpace = soap_new_block(soap);
					a->ContinuousPanTiltVelocitySpace = (struct ns2__Space2DDescription *)soap_push_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, sizeof(struct ns2__Space2DDescription));
					if (a->ContinuousPanTiltVelocitySpace == NULL)
						return NULL;
					soap_default_ns2__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space2DDescription(soap, "ns2:ContinuousPanTiltVelocitySpace", a->ContinuousPanTiltVelocitySpace, "ns2:Space2DDescription"))
				{	a->__sizeContinuousPanTiltVelocitySpace++;
					a->ContinuousPanTiltVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ContinuousZoomVelocitySpace", 1, NULL))
			{	if (a->ContinuousZoomVelocitySpace == NULL)
				{	if (soap_blist_ContinuousZoomVelocitySpace == NULL)
						soap_blist_ContinuousZoomVelocitySpace = soap_new_block(soap);
					a->ContinuousZoomVelocitySpace = (struct ns2__Space1DDescription *)soap_push_block(soap, soap_blist_ContinuousZoomVelocitySpace, sizeof(struct ns2__Space1DDescription));
					if (a->ContinuousZoomVelocitySpace == NULL)
						return NULL;
					soap_default_ns2__Space1DDescription(soap, a->ContinuousZoomVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space1DDescription(soap, "ns2:ContinuousZoomVelocitySpace", a->ContinuousZoomVelocitySpace, "ns2:Space1DDescription"))
				{	a->__sizeContinuousZoomVelocitySpace++;
					a->ContinuousZoomVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:PanTiltSpeedSpace", 1, NULL))
			{	if (a->PanTiltSpeedSpace == NULL)
				{	if (soap_blist_PanTiltSpeedSpace == NULL)
						soap_blist_PanTiltSpeedSpace = soap_new_block(soap);
					a->PanTiltSpeedSpace = (struct ns2__Space1DDescription *)soap_push_block(soap, soap_blist_PanTiltSpeedSpace, sizeof(struct ns2__Space1DDescription));
					if (a->PanTiltSpeedSpace == NULL)
						return NULL;
					soap_default_ns2__Space1DDescription(soap, a->PanTiltSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space1DDescription(soap, "ns2:PanTiltSpeedSpace", a->PanTiltSpeedSpace, "ns2:Space1DDescription"))
				{	a->__sizePanTiltSpeedSpace++;
					a->PanTiltSpeedSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ZoomSpeedSpace", 1, NULL))
			{	if (a->ZoomSpeedSpace == NULL)
				{	if (soap_blist_ZoomSpeedSpace == NULL)
						soap_blist_ZoomSpeedSpace = soap_new_block(soap);
					a->ZoomSpeedSpace = (struct ns2__Space1DDescription *)soap_push_block(soap, soap_blist_ZoomSpeedSpace, sizeof(struct ns2__Space1DDescription));
					if (a->ZoomSpeedSpace == NULL)
						return NULL;
					soap_default_ns2__Space1DDescription(soap, a->ZoomSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_ns2__Space1DDescription(soap, "ns2:ZoomSpeedSpace", a->ZoomSpeedSpace, "ns2:Space1DDescription"))
				{	a->__sizeZoomSpeedSpace++;
					a->ZoomSpeedSpace = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZSpacesExtension(soap, "ns2:Extension", &a->Extension, "ns2:PTZSpacesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AbsolutePanTiltPositionSpace)
			soap_pop_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		if (a->__sizeAbsolutePanTiltPositionSpace)
			a->AbsolutePanTiltPositionSpace = (struct ns2__Space2DDescription *)soap_save_block(soap, soap_blist_AbsolutePanTiltPositionSpace, NULL, 1);
		else
		{	a->AbsolutePanTiltPositionSpace = NULL;
			if (soap_blist_AbsolutePanTiltPositionSpace)
				soap_end_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		}
		if (a->AbsoluteZoomPositionSpace)
			soap_pop_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		if (a->__sizeAbsoluteZoomPositionSpace)
			a->AbsoluteZoomPositionSpace = (struct ns2__Space1DDescription *)soap_save_block(soap, soap_blist_AbsoluteZoomPositionSpace, NULL, 1);
		else
		{	a->AbsoluteZoomPositionSpace = NULL;
			if (soap_blist_AbsoluteZoomPositionSpace)
				soap_end_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		}
		if (a->RelativePanTiltTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		if (a->__sizeRelativePanTiltTranslationSpace)
			a->RelativePanTiltTranslationSpace = (struct ns2__Space2DDescription *)soap_save_block(soap, soap_blist_RelativePanTiltTranslationSpace, NULL, 1);
		else
		{	a->RelativePanTiltTranslationSpace = NULL;
			if (soap_blist_RelativePanTiltTranslationSpace)
				soap_end_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		}
		if (a->RelativeZoomTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativeZoomTranslationSpace);
		if (a->__sizeRelativeZoomTranslationSpace)
			a->RelativeZoomTranslationSpace = (struct ns2__Space1DDescription *)soap_save_block(soap, soap_blist_RelativeZoomTranslationSpace, NULL, 1);
		else
		{	a->RelativeZoomTranslationSpace = NULL;
			if (soap_blist_RelativeZoomTranslationSpace)
				soap_end_block(soap, soap_blist_RelativeZoomTranslationSpace);
		}
		if (a->ContinuousPanTiltVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		if (a->__sizeContinuousPanTiltVelocitySpace)
			a->ContinuousPanTiltVelocitySpace = (struct ns2__Space2DDescription *)soap_save_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, NULL, 1);
		else
		{	a->ContinuousPanTiltVelocitySpace = NULL;
			if (soap_blist_ContinuousPanTiltVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		}
		if (a->ContinuousZoomVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		if (a->__sizeContinuousZoomVelocitySpace)
			a->ContinuousZoomVelocitySpace = (struct ns2__Space1DDescription *)soap_save_block(soap, soap_blist_ContinuousZoomVelocitySpace, NULL, 1);
		else
		{	a->ContinuousZoomVelocitySpace = NULL;
			if (soap_blist_ContinuousZoomVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		}
		if (a->PanTiltSpeedSpace)
			soap_pop_block(soap, soap_blist_PanTiltSpeedSpace);
		if (a->__sizePanTiltSpeedSpace)
			a->PanTiltSpeedSpace = (struct ns2__Space1DDescription *)soap_save_block(soap, soap_blist_PanTiltSpeedSpace, NULL, 1);
		else
		{	a->PanTiltSpeedSpace = NULL;
			if (soap_blist_PanTiltSpeedSpace)
				soap_end_block(soap, soap_blist_PanTiltSpeedSpace);
		}
		if (a->ZoomSpeedSpace)
			soap_pop_block(soap, soap_blist_ZoomSpeedSpace);
		if (a->__sizeZoomSpeedSpace)
			a->ZoomSpeedSpace = (struct ns2__Space1DDescription *)soap_save_block(soap, soap_blist_ZoomSpeedSpace, NULL, 1);
		else
		{	a->ZoomSpeedSpace = NULL;
			if (soap_blist_ZoomSpeedSpace)
				soap_end_block(soap, soap_blist_ZoomSpeedSpace);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZSpaces, 0, sizeof(struct ns2__PTZSpaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZSpaces(struct soap *soap, const struct ns2__PTZSpaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZSpaces);
	if (soap_out_ns2__PTZSpaces(soap, tag?tag:"ns2:PTZSpaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZSpaces * SOAP_FMAC4 soap_get_ns2__PTZSpaces(struct soap *soap, struct ns2__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZConfigurationOptions(struct soap *soap, struct ns2__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spaces = NULL;
	a->PTZTimeout = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZConfigurationOptions(struct soap *soap, const struct ns2__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PTZSpaces(soap, &a->Spaces);
	soap_serialize_PointerTons2__DurationRange(soap, &a->PTZTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns2__PTZConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZConfigurationOptions), type))
		return soap->error;
	if (a->Spaces)
	{	if (soap_out_PointerTons2__PTZSpaces(soap, "ns2:Spaces", -1, &a->Spaces, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Spaces"))
		return soap->error;
	if (a->PTZTimeout)
	{	if (soap_out_PointerTons2__DurationRange(soap, "ns2:PTZTimeout", -1, &a->PTZTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:PTZTimeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZConfigurationOptions * SOAP_FMAC4 soap_in_ns2__PTZConfigurationOptions(struct soap *soap, const char *tag, struct ns2__PTZConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Spaces = 1;
	size_t soap_flag_PTZTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZConfigurationOptions, sizeof(struct ns2__PTZConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZSpaces(soap, "ns2:Spaces", &a->Spaces, "ns2:PTZSpaces"))
				{	soap_flag_Spaces--;
					continue;
				}
			if (soap_flag_PTZTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DurationRange(soap, "ns2:PTZTimeout", &a->PTZTimeout, "ns2:DurationRange"))
				{	soap_flag_PTZTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZConfigurationOptions, 0, sizeof(struct ns2__PTZConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Spaces > 0 || soap_flag_PTZTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZConfigurationOptions(struct soap *soap, const struct ns2__PTZConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZConfigurationOptions);
	if (soap_out_ns2__PTZConfigurationOptions(soap, tag?tag:"ns2:PTZConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZConfigurationOptions * SOAP_FMAC4 soap_get_ns2__PTZConfigurationOptions(struct soap *soap, struct ns2__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZConfigurationExtension(struct soap *soap, struct ns2__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZConfigurationExtension(struct soap *soap, const struct ns2__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns2__PTZConfigurationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZConfigurationExtension * SOAP_FMAC4 soap_in_ns2__PTZConfigurationExtension(struct soap *soap, const char *tag, struct ns2__PTZConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZConfigurationExtension, sizeof(struct ns2__PTZConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZConfigurationExtension, 0, sizeof(struct ns2__PTZConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZConfigurationExtension(struct soap *soap, const struct ns2__PTZConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZConfigurationExtension);
	if (soap_out_ns2__PTZConfigurationExtension(soap, tag?tag:"ns2:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZConfigurationExtension * SOAP_FMAC4 soap_get_ns2__PTZConfigurationExtension(struct soap *soap, struct ns2__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZNodeExtension(struct soap *soap, struct ns2__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZNodeExtension(struct soap *soap, const struct ns2__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZNodeExtension(struct soap *soap, const char *tag, int id, const struct ns2__PTZNodeExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZNodeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZNodeExtension * SOAP_FMAC4 soap_in_ns2__PTZNodeExtension(struct soap *soap, const char *tag, struct ns2__PTZNodeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZNodeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZNodeExtension, sizeof(struct ns2__PTZNodeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZNodeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZNodeExtension, 0, sizeof(struct ns2__PTZNodeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZNodeExtension(struct soap *soap, const struct ns2__PTZNodeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZNodeExtension);
	if (soap_out_ns2__PTZNodeExtension(soap, tag?tag:"ns2:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZNodeExtension * SOAP_FMAC4 soap_get_ns2__PTZNodeExtension(struct soap *soap, struct ns2__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RelayOutputSettings(struct soap *soap, struct ns2__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__RelayMode(soap, &a->Mode);
	soap_default_xsd__duration(soap, &a->DelayTime);
	soap_default_ns2__RelayIdleState(soap, &a->IdleState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RelayOutputSettings(struct soap *soap, const struct ns2__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DelayTime, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RelayOutputSettings(struct soap *soap, const char *tag, int id, const struct ns2__RelayOutputSettings *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_ns2__RelayMode(soap, "ns2:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:DelayTime", -1, &a->DelayTime, ""))
		return soap->error;
	if (soap_out_ns2__RelayIdleState(soap, "ns2:IdleState", -1, &a->IdleState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RelayOutputSettings * SOAP_FMAC4 soap_in_ns2__RelayOutputSettings(struct soap *soap, const char *tag, struct ns2__RelayOutputSettings *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_DelayTime = 1;
	size_t soap_flag_IdleState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RelayOutputSettings, sizeof(struct ns2__RelayOutputSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__RelayMode(soap, "ns2:Mode", &a->Mode, "ns2:RelayMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_DelayTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:DelayTime", &a->DelayTime, "xsd:duration"))
				{	soap_flag_DelayTime--;
					continue;
				}
			if (soap_flag_IdleState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__RelayIdleState(soap, "ns2:IdleState", &a->IdleState, "ns2:RelayIdleState"))
				{	soap_flag_IdleState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RelayOutputSettings, 0, sizeof(struct ns2__RelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_DelayTime > 0 || soap_flag_IdleState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RelayOutputSettings(struct soap *soap, const struct ns2__RelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RelayOutputSettings);
	if (soap_out_ns2__RelayOutputSettings(soap, tag?tag:"ns2:RelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelayOutputSettings * SOAP_FMAC4 soap_get_ns2__RelayOutputSettings(struct soap *soap, struct ns2__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CertificateStatus(struct soap *soap, struct ns2__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_xsd__boolean(soap, &a->Status);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CertificateStatus(struct soap *soap, const struct ns2__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CertificateStatus(struct soap *soap, const char *tag, int id, const struct ns2__CertificateStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CertificateStatus), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "ns2:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:CertificateID"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Status", -1, &a->Status, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CertificateStatus * SOAP_FMAC4 soap_in_ns2__CertificateStatus(struct soap *soap, const char *tag, struct ns2__CertificateStatus *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Status = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CertificateStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CertificateStatus, sizeof(struct ns2__CertificateStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CertificateStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CertificateStatus, 0, sizeof(struct ns2__CertificateStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0 || soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CertificateStatus(struct soap *soap, const struct ns2__CertificateStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CertificateStatus);
	if (soap_out_ns2__CertificateStatus(soap, tag?tag:"ns2:CertificateStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CertificateStatus * SOAP_FMAC4 soap_get_ns2__CertificateStatus(struct soap *soap, struct ns2__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Certificate(struct soap *soap, struct ns2__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Certificate(struct soap *soap, const struct ns2__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_PointerTons2__BinaryData(soap, &a->Certificate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Certificate(struct soap *soap, const char *tag, int id, const struct ns2__Certificate *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Certificate), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "ns2:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:CertificateID"))
		return soap->error;
	if (a->Certificate)
	{	if (soap_out_PointerTons2__BinaryData(soap, "ns2:Certificate", -1, &a->Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Certificate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Certificate * SOAP_FMAC4 soap_in_ns2__Certificate(struct soap *soap, const char *tag, struct ns2__Certificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Certificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Certificate, sizeof(struct ns2__Certificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Certificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:Certificate", &a->Certificate, "ns2:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Certificate, 0, sizeof(struct ns2__Certificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0 || soap_flag_Certificate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Certificate(struct soap *soap, const struct ns2__Certificate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Certificate);
	if (soap_out_ns2__Certificate(soap, tag?tag:"ns2:Certificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Certificate * SOAP_FMAC4 soap_get_ns2__Certificate(struct soap *soap, struct ns2__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CertificateGenerationParametersExtension(struct soap *soap, struct ns2__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CertificateGenerationParametersExtension(struct soap *soap, const struct ns2__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, const struct ns2__CertificateGenerationParametersExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CertificateGenerationParametersExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_in_ns2__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct ns2__CertificateGenerationParametersExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CertificateGenerationParametersExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CertificateGenerationParametersExtension, sizeof(struct ns2__CertificateGenerationParametersExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CertificateGenerationParametersExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CertificateGenerationParametersExtension, 0, sizeof(struct ns2__CertificateGenerationParametersExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CertificateGenerationParametersExtension(struct soap *soap, const struct ns2__CertificateGenerationParametersExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CertificateGenerationParametersExtension);
	if (soap_out_ns2__CertificateGenerationParametersExtension(soap, tag?tag:"ns2:CertificateGenerationParametersExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_get_ns2__CertificateGenerationParametersExtension(struct soap *soap, struct ns2__CertificateGenerationParametersExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CertificateGenerationParameters(struct soap *soap, struct ns2__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	soap_default_xsd__token(soap, &a->ValidNotBefore);
	soap_default_xsd__token(soap, &a->ValidNotAfter);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CertificateGenerationParameters(struct soap *soap, const struct ns2__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->Subject);
	soap_serialize_xsd__token(soap, &a->ValidNotBefore);
	soap_serialize_xsd__token(soap, &a->ValidNotAfter);
	soap_serialize_PointerTons2__CertificateGenerationParametersExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CertificateGenerationParameters(struct soap *soap, const char *tag, int id, const struct ns2__CertificateGenerationParameters *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CertificateGenerationParameters), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "ns2:CertificateID", -1, &a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Subject", -1, &a->Subject, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "ns2:ValidNotBefore", -1, &a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "ns2:ValidNotAfter", -1, &a->ValidNotAfter, ""))
		return soap->error;
	if (soap_out_PointerTons2__CertificateGenerationParametersExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CertificateGenerationParameters * SOAP_FMAC4 soap_in_ns2__CertificateGenerationParameters(struct soap *soap, const char *tag, struct ns2__CertificateGenerationParameters *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CertificateGenerationParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CertificateGenerationParameters, sizeof(struct ns2__CertificateGenerationParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CertificateGenerationParameters(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Subject", &a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_ValidNotBefore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:ValidNotBefore", &a->ValidNotBefore, "xsd:token"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			if (soap_flag_ValidNotAfter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:ValidNotAfter", &a->ValidNotAfter, "xsd:token"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CertificateGenerationParametersExtension(soap, "ns2:Extension", &a->Extension, "ns2:CertificateGenerationParametersExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CertificateGenerationParameters, 0, sizeof(struct ns2__CertificateGenerationParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CertificateGenerationParameters(struct soap *soap, const struct ns2__CertificateGenerationParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CertificateGenerationParameters);
	if (soap_out_ns2__CertificateGenerationParameters(soap, tag?tag:"ns2:CertificateGenerationParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CertificateGenerationParameters * SOAP_FMAC4 soap_get_ns2__CertificateGenerationParameters(struct soap *soap, struct ns2__CertificateGenerationParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CertificateGenerationParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Date(struct soap *soap, struct ns2__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Year);
	soap_default_int(soap, &a->Month);
	soap_default_int(soap, &a->Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Date(struct soap *soap, const struct ns2__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Year, SOAP_TYPE_int);
	soap_embedded(soap, &a->Month, SOAP_TYPE_int);
	soap_embedded(soap, &a->Day, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Date(struct soap *soap, const char *tag, int id, const struct ns2__Date *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Date), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:Year", -1, &a->Year, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Month", -1, &a->Month, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Day", -1, &a->Day, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Date * SOAP_FMAC4 soap_in_ns2__Date(struct soap *soap, const char *tag, struct ns2__Date *a, const char *type)
{
	size_t soap_flag_Year = 1;
	size_t soap_flag_Month = 1;
	size_t soap_flag_Day = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Date *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Date, sizeof(struct ns2__Date), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Date(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Year", &a->Year, "xsd:int"))
				{	soap_flag_Year--;
					continue;
				}
			if (soap_flag_Month && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Month", &a->Month, "xsd:int"))
				{	soap_flag_Month--;
					continue;
				}
			if (soap_flag_Day && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Day", &a->Day, "xsd:int"))
				{	soap_flag_Day--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Date, 0, sizeof(struct ns2__Date), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year > 0 || soap_flag_Month > 0 || soap_flag_Day > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Date(struct soap *soap, const struct ns2__Date *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Date);
	if (soap_out_ns2__Date(soap, tag?tag:"ns2:Date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Date * SOAP_FMAC4 soap_get_ns2__Date(struct soap *soap, struct ns2__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Time(struct soap *soap, struct ns2__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Hour);
	soap_default_int(soap, &a->Minute);
	soap_default_int(soap, &a->Second);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Time(struct soap *soap, const struct ns2__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Hour, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minute, SOAP_TYPE_int);
	soap_embedded(soap, &a->Second, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Time(struct soap *soap, const char *tag, int id, const struct ns2__Time *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Time), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:Hour", -1, &a->Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Minute", -1, &a->Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Second", -1, &a->Second, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Time * SOAP_FMAC4 soap_in_ns2__Time(struct soap *soap, const char *tag, struct ns2__Time *a, const char *type)
{
	size_t soap_flag_Hour = 1;
	size_t soap_flag_Minute = 1;
	size_t soap_flag_Second = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Time *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Time, sizeof(struct ns2__Time), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Time(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Hour", &a->Hour, "xsd:int"))
				{	soap_flag_Hour--;
					continue;
				}
			if (soap_flag_Minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Minute", &a->Minute, "xsd:int"))
				{	soap_flag_Minute--;
					continue;
				}
			if (soap_flag_Second && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Second", &a->Second, "xsd:int"))
				{	soap_flag_Second--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Time, 0, sizeof(struct ns2__Time), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour > 0 || soap_flag_Minute > 0 || soap_flag_Second > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Time(struct soap *soap, const struct ns2__Time *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Time);
	if (soap_out_ns2__Time(soap, tag?tag:"ns2:Time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Time * SOAP_FMAC4 soap_get_ns2__Time(struct soap *soap, struct ns2__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SystemDateTimeExtension(struct soap *soap, struct ns2__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SystemDateTimeExtension(struct soap *soap, const struct ns2__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const struct ns2__SystemDateTimeExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SystemDateTimeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SystemDateTimeExtension * SOAP_FMAC4 soap_in_ns2__SystemDateTimeExtension(struct soap *soap, const char *tag, struct ns2__SystemDateTimeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SystemDateTimeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SystemDateTimeExtension, sizeof(struct ns2__SystemDateTimeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SystemDateTimeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SystemDateTimeExtension, 0, sizeof(struct ns2__SystemDateTimeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SystemDateTimeExtension(struct soap *soap, const struct ns2__SystemDateTimeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SystemDateTimeExtension);
	if (soap_out_ns2__SystemDateTimeExtension(soap, tag?tag:"ns2:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemDateTimeExtension * SOAP_FMAC4 soap_get_ns2__SystemDateTimeExtension(struct soap *soap, struct ns2__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DateTime(struct soap *soap, struct ns2__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Date = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DateTime(struct soap *soap, const struct ns2__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Time(soap, &a->Time);
	soap_serialize_PointerTons2__Date(soap, &a->Date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DateTime(struct soap *soap, const char *tag, int id, const struct ns2__DateTime *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DateTime), type))
		return soap->error;
	if (a->Time)
	{	if (soap_out_PointerTons2__Time(soap, "ns2:Time", -1, &a->Time, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Time"))
		return soap->error;
	if (a->Date)
	{	if (soap_out_PointerTons2__Date(soap, "ns2:Date", -1, &a->Date, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Date"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DateTime * SOAP_FMAC4 soap_in_ns2__DateTime(struct soap *soap, const char *tag, struct ns2__DateTime *a, const char *type)
{
	size_t soap_flag_Time = 1;
	size_t soap_flag_Date = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DateTime, sizeof(struct ns2__DateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Time(soap, "ns2:Time", &a->Time, "ns2:Time"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Date && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Date(soap, "ns2:Date", &a->Date, "ns2:Date"))
				{	soap_flag_Date--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DateTime, 0, sizeof(struct ns2__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_Date > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DateTime(struct soap *soap, const struct ns2__DateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DateTime);
	if (soap_out_ns2__DateTime(soap, tag?tag:"ns2:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DateTime * SOAP_FMAC4 soap_get_ns2__DateTime(struct soap *soap, struct ns2__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TimeZone(struct soap *soap, struct ns2__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__TimeZone(struct soap *soap, const struct ns2__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TimeZone(struct soap *soap, const char *tag, int id, const struct ns2__TimeZone *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TimeZone), type))
		return soap->error;
	if (a->TZ)
	{	if (soap_out_xsd__token(soap, "ns2:TZ", -1, &a->TZ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:TZ"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__TimeZone * SOAP_FMAC4 soap_in_ns2__TimeZone(struct soap *soap, const char *tag, struct ns2__TimeZone *a, const char *type)
{
	size_t soap_flag_TZ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__TimeZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TimeZone, sizeof(struct ns2__TimeZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__TimeZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:TZ", &a->TZ, "xsd:token"))
				{	soap_flag_TZ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TimeZone, 0, sizeof(struct ns2__TimeZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TimeZone(struct soap *soap, const struct ns2__TimeZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TimeZone);
	if (soap_out_ns2__TimeZone(soap, tag?tag:"ns2:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__TimeZone * SOAP_FMAC4 soap_get_ns2__TimeZone(struct soap *soap, struct ns2__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SystemDateTime(struct soap *soap, struct ns2__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
	a->LocalDateTime = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SystemDateTime(struct soap *soap, const struct ns2__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTons2__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTons2__DateTime(soap, &a->UTCDateTime);
	soap_serialize_PointerTons2__DateTime(soap, &a->LocalDateTime);
	soap_serialize_PointerTons2__SystemDateTimeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SystemDateTime(struct soap *soap, const char *tag, int id, const struct ns2__SystemDateTime *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SystemDateTime), type))
		return soap->error;
	if (soap_out_ns2__SetDateTimeType(soap, "ns2:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTons2__TimeZone(soap, "ns2:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTons2__DateTime(soap, "ns2:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__DateTime(soap, "ns2:LocalDateTime", -1, &a->LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__SystemDateTimeExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SystemDateTime * SOAP_FMAC4 soap_in_ns2__SystemDateTime(struct soap *soap, const char *tag, struct ns2__SystemDateTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	size_t soap_flag_LocalDateTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SystemDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SystemDateTime, sizeof(struct ns2__SystemDateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SystemDateTime(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__SetDateTimeType(soap, "ns2:DateTimeType", &a->DateTimeType, "ns2:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TimeZone(soap, "ns2:TimeZone", &a->TimeZone, "ns2:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DateTime(soap, "ns2:UTCDateTime", &a->UTCDateTime, "ns2:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			if (soap_flag_LocalDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DateTime(soap, "ns2:LocalDateTime", &a->LocalDateTime, "ns2:DateTime"))
				{	soap_flag_LocalDateTime--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SystemDateTimeExtension(soap, "ns2:Extension", &a->Extension, "ns2:SystemDateTimeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SystemDateTime, 0, sizeof(struct ns2__SystemDateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SystemDateTime(struct soap *soap, const struct ns2__SystemDateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SystemDateTime);
	if (soap_out_ns2__SystemDateTime(soap, tag?tag:"ns2:SystemDateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemDateTime * SOAP_FMAC4 soap_get_ns2__SystemDateTime(struct soap *soap, struct ns2__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BackupFile(struct soap *soap, struct ns2__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->Data = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BackupFile(struct soap *soap, const struct ns2__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Name);
	soap_serialize_PointerTons2__AttachmentData(soap, &a->Data);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BackupFile(struct soap *soap, const char *tag, int id, const struct ns2__BackupFile *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BackupFile), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_string(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (a->Data)
	{	if (soap_out_PointerTons2__AttachmentData(soap, "ns2:Data", -1, &a->Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Data"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BackupFile * SOAP_FMAC4 soap_in_ns2__BackupFile(struct soap *soap, const char *tag, struct ns2__BackupFile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BackupFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BackupFile, sizeof(struct ns2__BackupFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BackupFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AttachmentData(soap, "ns2:Data", &a->Data, "ns2:AttachmentData"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BackupFile, 0, sizeof(struct ns2__BackupFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Data > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BackupFile(struct soap *soap, const struct ns2__BackupFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BackupFile);
	if (soap_out_ns2__BackupFile(soap, tag?tag:"ns2:BackupFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BackupFile * SOAP_FMAC4 soap_get_ns2__BackupFile(struct soap *soap, struct ns2__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BinaryData(struct soap *soap, struct ns2__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__base64Binary(soap, &a->Data);
	soap_default_string(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BinaryData(struct soap *soap, const struct ns2__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__base64Binary(soap, &a->Data);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BinaryData(struct soap *soap, const char *tag, int id, const struct ns2__BinaryData *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", a->xmime__contentType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BinaryData), type))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "ns2:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BinaryData * SOAP_FMAC4 soap_in_ns2__BinaryData(struct soap *soap, const char *tag, struct ns2__BinaryData *a, const char *type)
{
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__BinaryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BinaryData, sizeof(struct ns2__BinaryData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BinaryData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &a->xmime__contentType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__base64Binary(soap, "ns2:Data", &a->Data, "xsd:base64Binary"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BinaryData, 0, sizeof(struct ns2__BinaryData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BinaryData(struct soap *soap, const struct ns2__BinaryData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BinaryData);
	if (soap_out_ns2__BinaryData(soap, tag?tag:"ns2:BinaryData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BinaryData * SOAP_FMAC4 soap_get_ns2__BinaryData(struct soap *soap, struct ns2__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SupportInformation(struct soap *soap, struct ns2__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SupportInformation(struct soap *soap, const struct ns2__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, &a->String);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SupportInformation(struct soap *soap, const char *tag, int id, const struct ns2__SupportInformation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTons2__AttachmentData(soap, "ns2:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:String", -1, &a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SupportInformation * SOAP_FMAC4 soap_in_ns2__SupportInformation(struct soap *soap, const char *tag, struct ns2__SupportInformation *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SupportInformation, sizeof(struct ns2__SupportInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SupportInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AttachmentData(soap, "ns2:Binary", &a->Binary, "ns2:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:String", &a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SupportInformation, 0, sizeof(struct ns2__SupportInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SupportInformation(struct soap *soap, const struct ns2__SupportInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SupportInformation);
	if (soap_out_ns2__SupportInformation(soap, tag?tag:"ns2:SupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportInformation * SOAP_FMAC4 soap_get_ns2__SupportInformation(struct soap *soap, struct ns2__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AttachmentData(struct soap *soap, struct ns2__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__xop__Include(soap, &a->xop__Include);
	soap_default_string(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AttachmentData(struct soap *soap, const struct ns2__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__xop__Include(soap, &a->xop__Include);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AttachmentData(struct soap *soap, const char *tag, int id, const struct ns2__AttachmentData *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", a->xmime__contentType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AttachmentData), type))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &a->xop__Include, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AttachmentData * SOAP_FMAC4 soap_in_ns2__AttachmentData(struct soap *soap, const char *tag, struct ns2__AttachmentData *a, const char *type)
{
	size_t soap_flag_xop__Include = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AttachmentData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AttachmentData, sizeof(struct ns2__AttachmentData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AttachmentData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &a->xmime__contentType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__xop__Include(soap, "xop:Include", &a->xop__Include, ""))
				{	soap_flag_xop__Include--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AttachmentData, 0, sizeof(struct ns2__AttachmentData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AttachmentData(struct soap *soap, const struct ns2__AttachmentData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AttachmentData);
	if (soap_out_ns2__AttachmentData(soap, tag?tag:"ns2:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AttachmentData * SOAP_FMAC4 soap_get_ns2__AttachmentData(struct soap *soap, struct ns2__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SystemLog(struct soap *soap, struct ns2__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SystemLog(struct soap *soap, const struct ns2__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, &a->String);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SystemLog(struct soap *soap, const char *tag, int id, const struct ns2__SystemLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTons2__AttachmentData(soap, "ns2:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:String", -1, &a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SystemLog * SOAP_FMAC4 soap_in_ns2__SystemLog(struct soap *soap, const char *tag, struct ns2__SystemLog *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SystemLog, sizeof(struct ns2__SystemLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SystemLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AttachmentData(soap, "ns2:Binary", &a->Binary, "ns2:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:String", &a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SystemLog, 0, sizeof(struct ns2__SystemLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SystemLog(struct soap *soap, const struct ns2__SystemLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SystemLog);
	if (soap_out_ns2__SystemLog(soap, tag?tag:"ns2:SystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemLog * SOAP_FMAC4 soap_get_ns2__SystemLog(struct soap *soap, struct ns2__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SystemCapabilitiesExtension(struct soap *soap, struct ns2__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SystemCapabilitiesExtension(struct soap *soap, const struct ns2__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__SystemCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SystemCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__SystemCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SystemCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SystemCapabilitiesExtension, sizeof(struct ns2__SystemCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SystemCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SystemCapabilitiesExtension, 0, sizeof(struct ns2__SystemCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SystemCapabilitiesExtension(struct soap *soap, const struct ns2__SystemCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SystemCapabilitiesExtension);
	if (soap_out_ns2__SystemCapabilitiesExtension(soap, tag?tag:"ns2:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__SystemCapabilitiesExtension(struct soap *soap, struct ns2__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__OnvifVersion(struct soap *soap, struct ns2__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Major);
	soap_default_int(soap, &a->Minor);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__OnvifVersion(struct soap *soap, const struct ns2__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Major, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minor, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OnvifVersion(struct soap *soap, const char *tag, int id, const struct ns2__OnvifVersion *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:Major", -1, &a->Major, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Minor", -1, &a->Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__OnvifVersion * SOAP_FMAC4 soap_in_ns2__OnvifVersion(struct soap *soap, const char *tag, struct ns2__OnvifVersion *a, const char *type)
{
	size_t soap_flag_Major = 1;
	size_t soap_flag_Minor = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__OnvifVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OnvifVersion, sizeof(struct ns2__OnvifVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__OnvifVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Major", &a->Major, "xsd:int"))
				{	soap_flag_Major--;
					continue;
				}
			if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Minor", &a->Minor, "xsd:int"))
				{	soap_flag_Minor--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OnvifVersion, 0, sizeof(struct ns2__OnvifVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OnvifVersion(struct soap *soap, const struct ns2__OnvifVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__OnvifVersion);
	if (soap_out_ns2__OnvifVersion(soap, tag?tag:"ns2:OnvifVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__OnvifVersion * SOAP_FMAC4 soap_get_ns2__OnvifVersion(struct soap *soap, struct ns2__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StorageCapabilities(struct soap *soap, struct ns2__StorageCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__StorageCapabilities(struct soap *soap, const struct ns2__StorageCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StorageCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__StorageCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StorageCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__StorageCapabilities * SOAP_FMAC4 soap_in_ns2__StorageCapabilities(struct soap *soap, const char *tag, struct ns2__StorageCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__StorageCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StorageCapabilities, sizeof(struct ns2__StorageCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__StorageCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__StorageCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StorageCapabilities, 0, sizeof(struct ns2__StorageCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StorageCapabilities(struct soap *soap, const struct ns2__StorageCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StorageCapabilities);
	if (soap_out_ns2__StorageCapabilities(soap, tag?tag:"ns2:StorageCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__StorageCapabilities * SOAP_FMAC4 soap_get_ns2__StorageCapabilities(struct soap *soap, struct ns2__StorageCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StorageCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SecurityCapabilitiesExtension(struct soap *soap, struct ns2__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TLS1_x002e0);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SecurityCapabilitiesExtension(struct soap *soap, const struct ns2__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TLS1_x002e0, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__SecurityCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:TLS1.0", -1, &a->TLS1_x002e0, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__SecurityCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_TLS1_x002e0 = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SecurityCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SecurityCapabilitiesExtension, sizeof(struct ns2__SecurityCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SecurityCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:TLS1.0", &a->TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SecurityCapabilitiesExtension, 0, sizeof(struct ns2__SecurityCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e0 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SecurityCapabilitiesExtension(struct soap *soap, const struct ns2__SecurityCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SecurityCapabilitiesExtension);
	if (soap_out_ns2__SecurityCapabilitiesExtension(soap, tag?tag:"ns2:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__SecurityCapabilitiesExtension(struct soap *soap, struct ns2__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkCapabilitiesExtension(struct soap *soap, struct ns2__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkCapabilitiesExtension(struct soap *soap, const struct ns2__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__NetworkCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__NetworkCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkCapabilitiesExtension, sizeof(struct ns2__NetworkCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkCapabilitiesExtension, 0, sizeof(struct ns2__NetworkCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkCapabilitiesExtension(struct soap *soap, const struct ns2__NetworkCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkCapabilitiesExtension);
	if (soap_out_ns2__NetworkCapabilitiesExtension(soap, tag?tag:"ns2:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__NetworkCapabilitiesExtension(struct soap *soap, struct ns2__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct ns2__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct ns2__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RealTimeStreamingCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension, sizeof(struct ns2__RealTimeStreamingCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RealTimeStreamingCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension, 0, sizeof(struct ns2__RealTimeStreamingCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct ns2__RealTimeStreamingCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_ns2__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"ns2:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct ns2__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ProfileCapabilities(struct soap *soap, struct ns2__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfProfiles);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ProfileCapabilities(struct soap *soap, const struct ns2__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->MaximumNumberOfProfiles, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__ProfileCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:MaximumNumberOfProfiles", -1, &a->MaximumNumberOfProfiles, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ProfileCapabilities * SOAP_FMAC4 soap_in_ns2__ProfileCapabilities(struct soap *soap, const char *tag, struct ns2__ProfileCapabilities *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfProfiles = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ProfileCapabilities, sizeof(struct ns2__ProfileCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ProfileCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:MaximumNumberOfProfiles", &a->MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ProfileCapabilities, 0, sizeof(struct ns2__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ProfileCapabilities(struct soap *soap, const struct ns2__ProfileCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ProfileCapabilities);
	if (soap_out_ns2__ProfileCapabilities(soap, tag?tag:"ns2:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ProfileCapabilities * SOAP_FMAC4 soap_get_ns2__ProfileCapabilities(struct soap *soap, struct ns2__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MediaCapabilitiesExtension(struct soap *soap, struct ns2__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MediaCapabilitiesExtension(struct soap *soap, const struct ns2__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ProfileCapabilities(soap, &a->ProfileCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__MediaCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MediaCapabilitiesExtension), type))
		return soap->error;
	if (a->ProfileCapabilities)
	{	if (soap_out_PointerTons2__ProfileCapabilities(soap, "ns2:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ProfileCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__MediaCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MediaCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MediaCapabilitiesExtension, sizeof(struct ns2__MediaCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MediaCapabilitiesExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ProfileCapabilities(soap, "ns2:ProfileCapabilities", &a->ProfileCapabilities, "ns2:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MediaCapabilitiesExtension, 0, sizeof(struct ns2__MediaCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MediaCapabilitiesExtension(struct soap *soap, const struct ns2__MediaCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MediaCapabilitiesExtension);
	if (soap_out_ns2__MediaCapabilitiesExtension(soap, tag?tag:"ns2:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__MediaCapabilitiesExtension(struct soap *soap, struct ns2__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RealTimeStreamingCapabilities(struct soap *soap, struct ns2__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__RealTimeStreamingCapabilities(struct soap *soap, const struct ns2__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->RTPMulticast);
	soap_serialize_PointerToxsd__boolean(soap, &a->RTP_USCORETCP);
	soap_serialize_PointerToxsd__boolean(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__RealTimeStreamingCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:RTPMulticast", -1, &a->RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_ns2__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct ns2__RealTimeStreamingCapabilities *a, const char *type)
{
	size_t soap_flag_RTPMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__RealTimeStreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RealTimeStreamingCapabilities, sizeof(struct ns2__RealTimeStreamingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__RealTimeStreamingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:RTPMulticast", &a->RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast--;
					continue;
				}
			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP--;
					continue;
				}
			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RealTimeStreamingCapabilities, 0, sizeof(struct ns2__RealTimeStreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RealTimeStreamingCapabilities(struct soap *soap, const struct ns2__RealTimeStreamingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RealTimeStreamingCapabilities);
	if (soap_out_ns2__RealTimeStreamingCapabilities(soap, tag?tag:"ns2:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_ns2__RealTimeStreamingCapabilities(struct soap *soap, struct ns2__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IOCapabilitiesExtension(struct soap *soap, struct ns2__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IOCapabilitiesExtension(struct soap *soap, const struct ns2__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__IOCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IOCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__IOCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IOCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IOCapabilitiesExtension, sizeof(struct ns2__IOCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IOCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IOCapabilitiesExtension, 0, sizeof(struct ns2__IOCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IOCapabilitiesExtension(struct soap *soap, const struct ns2__IOCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IOCapabilitiesExtension);
	if (soap_out_ns2__IOCapabilitiesExtension(soap, tag?tag:"ns2:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__IOCapabilitiesExtension(struct soap *soap, struct ns2__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DeviceCapabilitiesExtension(struct soap *soap, struct ns2__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DeviceCapabilitiesExtension(struct soap *soap, const struct ns2__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__DeviceCapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeviceCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__DeviceCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DeviceCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeviceCapabilitiesExtension, sizeof(struct ns2__DeviceCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DeviceCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeviceCapabilitiesExtension, 0, sizeof(struct ns2__DeviceCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DeviceCapabilitiesExtension(struct soap *soap, const struct ns2__DeviceCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DeviceCapabilitiesExtension);
	if (soap_out_ns2__DeviceCapabilitiesExtension(soap, tag?tag:"ns2:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__DeviceCapabilitiesExtension(struct soap *soap, struct ns2__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SecurityCapabilities(struct soap *soap, struct ns2__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TLS1_x002e1);
	soap_default_xsd__boolean(soap, &a->TLS1_x002e2);
	soap_default_xsd__boolean(soap, &a->OnboardKeyGeneration);
	soap_default_xsd__boolean(soap, &a->AccessPolicyConfig);
	soap_default_xsd__boolean(soap, &a->X_x002e509Token);
	soap_default_xsd__boolean(soap, &a->SAMLToken);
	soap_default_xsd__boolean(soap, &a->KerberosToken);
	soap_default_xsd__boolean(soap, &a->RELToken);
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SecurityCapabilities(struct soap *soap, const struct ns2__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TLS1_x002e1, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->TLS1_x002e2, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->OnboardKeyGeneration, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->AccessPolicyConfig, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->X_x002e509Token, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SAMLToken, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->KerberosToken, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->RELToken, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTons2__SecurityCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__SecurityCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:TLS1.1", -1, &a->TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:TLS1.2", -1, &a->TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:OnboardKeyGeneration", -1, &a->OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:AccessPolicyConfig", -1, &a->AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:X.509Token", -1, &a->X_x002e509Token, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:SAMLToken", -1, &a->SAMLToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:KerberosToken", -1, &a->KerberosToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:RELToken", -1, &a->RELToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTons2__SecurityCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SecurityCapabilities * SOAP_FMAC4 soap_in_ns2__SecurityCapabilities(struct soap *soap, const char *tag, struct ns2__SecurityCapabilities *a, const char *type)
{
	size_t soap_flag_TLS1_x002e1 = 1;
	size_t soap_flag_TLS1_x002e2 = 1;
	size_t soap_flag_OnboardKeyGeneration = 1;
	size_t soap_flag_AccessPolicyConfig = 1;
	size_t soap_flag_X_x002e509Token = 1;
	size_t soap_flag_SAMLToken = 1;
	size_t soap_flag_KerberosToken = 1;
	size_t soap_flag_RELToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SecurityCapabilities, sizeof(struct ns2__SecurityCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SecurityCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:TLS1.1", &a->TLS1_x002e1, "xsd:boolean"))
				{	soap_flag_TLS1_x002e1--;
					continue;
				}
			if (soap_flag_TLS1_x002e2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:TLS1.2", &a->TLS1_x002e2, "xsd:boolean"))
				{	soap_flag_TLS1_x002e2--;
					continue;
				}
			if (soap_flag_OnboardKeyGeneration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:OnboardKeyGeneration", &a->OnboardKeyGeneration, "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration--;
					continue;
				}
			if (soap_flag_AccessPolicyConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:AccessPolicyConfig", &a->AccessPolicyConfig, "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig--;
					continue;
				}
			if (soap_flag_X_x002e509Token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:X.509Token", &a->X_x002e509Token, "xsd:boolean"))
				{	soap_flag_X_x002e509Token--;
					continue;
				}
			if (soap_flag_SAMLToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:SAMLToken", &a->SAMLToken, "xsd:boolean"))
				{	soap_flag_SAMLToken--;
					continue;
				}
			if (soap_flag_KerberosToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:KerberosToken", &a->KerberosToken, "xsd:boolean"))
				{	soap_flag_KerberosToken--;
					continue;
				}
			if (soap_flag_RELToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:RELToken", &a->RELToken, "xsd:boolean"))
				{	soap_flag_RELToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SecurityCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SecurityCapabilities, 0, sizeof(struct ns2__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e1 > 0 || soap_flag_TLS1_x002e2 > 0 || soap_flag_OnboardKeyGeneration > 0 || soap_flag_AccessPolicyConfig > 0 || soap_flag_X_x002e509Token > 0 || soap_flag_SAMLToken > 0 || soap_flag_KerberosToken > 0 || soap_flag_RELToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SecurityCapabilities(struct soap *soap, const struct ns2__SecurityCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SecurityCapabilities);
	if (soap_out_ns2__SecurityCapabilities(soap, tag?tag:"ns2:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SecurityCapabilities * SOAP_FMAC4 soap_get_ns2__SecurityCapabilities(struct soap *soap, struct ns2__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IOCapabilities(struct soap *soap, struct ns2__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputConnectors = NULL;
	a->RelayOutputs = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IOCapabilities(struct soap *soap, const struct ns2__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->InputConnectors);
	soap_serialize_PointerToint(soap, &a->RelayOutputs);
	soap_serialize_PointerTons2__IOCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IOCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__IOCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:InputConnectors", -1, &a->InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTons2__IOCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IOCapabilities * SOAP_FMAC4 soap_in_ns2__IOCapabilities(struct soap *soap, const char *tag, struct ns2__IOCapabilities *a, const char *type)
{
	size_t soap_flag_InputConnectors = 1;
	size_t soap_flag_RelayOutputs = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IOCapabilities, sizeof(struct ns2__IOCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IOCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:InputConnectors", &a->InputConnectors, "xsd:int"))
				{	soap_flag_InputConnectors--;
					continue;
				}
			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:RelayOutputs", &a->RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IOCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:IOCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IOCapabilities, 0, sizeof(struct ns2__IOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IOCapabilities(struct soap *soap, const struct ns2__IOCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IOCapabilities);
	if (soap_out_ns2__IOCapabilities(soap, tag?tag:"ns2:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IOCapabilities * SOAP_FMAC4 soap_get_ns2__IOCapabilities(struct soap *soap, struct ns2__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SystemCapabilities(struct soap *soap, struct ns2__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->DiscoveryResolve);
	soap_default_xsd__boolean(soap, &a->DiscoveryBye);
	soap_default_xsd__boolean(soap, &a->RemoteDiscovery);
	soap_default_xsd__boolean(soap, &a->SystemBackup);
	soap_default_xsd__boolean(soap, &a->SystemLogging);
	soap_default_xsd__boolean(soap, &a->FirmwareUpgrade);
	a->__sizeSupportedVersions = 0;
	a->SupportedVersions = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__SystemCapabilities(struct soap *soap, const struct ns2__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DiscoveryResolve, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->DiscoveryBye, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->RemoteDiscovery, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SystemBackup, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SystemLogging, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->FirmwareUpgrade, SOAP_TYPE_xsd__boolean);
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < a->__sizeSupportedVersions; i++)
		{
			soap_embedded(soap, a->SupportedVersions + i, SOAP_TYPE_ns2__OnvifVersion);
			soap_serialize_ns2__OnvifVersion(soap, a->SupportedVersions + i);
		}
	}
	soap_serialize_PointerTons2__SystemCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__SystemCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SystemCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:DiscoveryResolve", -1, &a->DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:DiscoveryBye", -1, &a->DiscoveryBye, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:RemoteDiscovery", -1, &a->RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:SystemBackup", -1, &a->SystemBackup, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:SystemLogging", -1, &a->SystemLogging, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:FirmwareUpgrade", -1, &a->FirmwareUpgrade, ""))
		return soap->error;
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < a->__sizeSupportedVersions; i++)
			if (soap_out_ns2__OnvifVersion(soap, "ns2:SupportedVersions", -1, a->SupportedVersions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__SystemCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__SystemCapabilities * SOAP_FMAC4 soap_in_ns2__SystemCapabilities(struct soap *soap, const char *tag, struct ns2__SystemCapabilities *a, const char *type)
{
	size_t soap_flag_DiscoveryResolve = 1;
	size_t soap_flag_DiscoveryBye = 1;
	size_t soap_flag_RemoteDiscovery = 1;
	size_t soap_flag_SystemBackup = 1;
	size_t soap_flag_SystemLogging = 1;
	size_t soap_flag_FirmwareUpgrade = 1;
	struct soap_blist *soap_blist_SupportedVersions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SystemCapabilities, sizeof(struct ns2__SystemCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__SystemCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:DiscoveryResolve", &a->DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve--;
					continue;
				}
			if (soap_flag_DiscoveryBye && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:DiscoveryBye", &a->DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye--;
					continue;
				}
			if (soap_flag_RemoteDiscovery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:RemoteDiscovery", &a->RemoteDiscovery, "xsd:boolean"))
				{	soap_flag_RemoteDiscovery--;
					continue;
				}
			if (soap_flag_SystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:SystemBackup", &a->SystemBackup, "xsd:boolean"))
				{	soap_flag_SystemBackup--;
					continue;
				}
			if (soap_flag_SystemLogging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:SystemLogging", &a->SystemLogging, "xsd:boolean"))
				{	soap_flag_SystemLogging--;
					continue;
				}
			if (soap_flag_FirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:FirmwareUpgrade", &a->FirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:SupportedVersions", 1, NULL))
			{	if (a->SupportedVersions == NULL)
				{	if (soap_blist_SupportedVersions == NULL)
						soap_blist_SupportedVersions = soap_new_block(soap);
					a->SupportedVersions = (struct ns2__OnvifVersion *)soap_push_block(soap, soap_blist_SupportedVersions, sizeof(struct ns2__OnvifVersion));
					if (a->SupportedVersions == NULL)
						return NULL;
					soap_default_ns2__OnvifVersion(soap, a->SupportedVersions);
				}
				soap_revert(soap);
				if (soap_in_ns2__OnvifVersion(soap, "ns2:SupportedVersions", a->SupportedVersions, "ns2:OnvifVersion"))
				{	a->__sizeSupportedVersions++;
					a->SupportedVersions = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SystemCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:SystemCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedVersions)
			soap_pop_block(soap, soap_blist_SupportedVersions);
		if (a->__sizeSupportedVersions)
			a->SupportedVersions = (struct ns2__OnvifVersion *)soap_save_block(soap, soap_blist_SupportedVersions, NULL, 1);
		else
		{	a->SupportedVersions = NULL;
			if (soap_blist_SupportedVersions)
				soap_end_block(soap, soap_blist_SupportedVersions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SystemCapabilities, 0, sizeof(struct ns2__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve > 0 || soap_flag_DiscoveryBye > 0 || soap_flag_RemoteDiscovery > 0 || soap_flag_SystemBackup > 0 || soap_flag_SystemLogging > 0 || soap_flag_FirmwareUpgrade > 0 || a->__sizeSupportedVersions < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SystemCapabilities(struct soap *soap, const struct ns2__SystemCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SystemCapabilities);
	if (soap_out_ns2__SystemCapabilities(soap, tag?tag:"ns2:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemCapabilities * SOAP_FMAC4 soap_get_ns2__SystemCapabilities(struct soap *soap, struct ns2__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkCapabilities(struct soap *soap, struct ns2__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkCapabilities(struct soap *soap, const struct ns2__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->IPFilter);
	soap_serialize_PointerToxsd__boolean(soap, &a->ZeroConfiguration);
	soap_serialize_PointerToxsd__boolean(soap, &a->IPVersion6);
	soap_serialize_PointerToxsd__boolean(soap, &a->DynDNS);
	soap_serialize_PointerTons2__NetworkCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__NetworkCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:IPFilter", -1, &a->IPFilter, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:ZeroConfiguration", -1, &a->ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:IPVersion6", -1, &a->IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:DynDNS", -1, &a->DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkCapabilities * SOAP_FMAC4 soap_in_ns2__NetworkCapabilities(struct soap *soap, const char *tag, struct ns2__NetworkCapabilities *a, const char *type)
{
	size_t soap_flag_IPFilter = 1;
	size_t soap_flag_ZeroConfiguration = 1;
	size_t soap_flag_IPVersion6 = 1;
	size_t soap_flag_DynDNS = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkCapabilities, sizeof(struct ns2__NetworkCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:IPFilter", &a->IPFilter, "xsd:boolean"))
				{	soap_flag_IPFilter--;
					continue;
				}
			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:ZeroConfiguration", &a->ZeroConfiguration, "xsd:boolean"))
				{	soap_flag_ZeroConfiguration--;
					continue;
				}
			if (soap_flag_IPVersion6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:IPVersion6", &a->IPVersion6, "xsd:boolean"))
				{	soap_flag_IPVersion6--;
					continue;
				}
			if (soap_flag_DynDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:DynDNS", &a->DynDNS, "xsd:boolean"))
				{	soap_flag_DynDNS--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkCapabilities, 0, sizeof(struct ns2__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkCapabilities(struct soap *soap, const struct ns2__NetworkCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkCapabilities);
	if (soap_out_ns2__NetworkCapabilities(soap, tag?tag:"ns2:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkCapabilities * SOAP_FMAC4 soap_get_ns2__NetworkCapabilities(struct soap *soap, struct ns2__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CapabilitiesExtension(struct soap *soap, struct ns2__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CapabilitiesExtension(struct soap *soap, const struct ns2__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns2__CapabilitiesExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CapabilitiesExtension * SOAP_FMAC4 soap_in_ns2__CapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__CapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CapabilitiesExtension, sizeof(struct ns2__CapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CapabilitiesExtension, 0, sizeof(struct ns2__CapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CapabilitiesExtension(struct soap *soap, const struct ns2__CapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CapabilitiesExtension);
	if (soap_out_ns2__CapabilitiesExtension(soap, tag?tag:"ns2:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CapabilitiesExtension * SOAP_FMAC4 soap_get_ns2__CapabilitiesExtension(struct soap *soap, struct ns2__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZCapabilities(struct soap *soap, struct ns2__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZCapabilities(struct soap *soap, const struct ns2__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__PTZCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZCapabilities * SOAP_FMAC4 soap_in_ns2__PTZCapabilities(struct soap *soap, const char *tag, struct ns2__PTZCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZCapabilities, sizeof(struct ns2__PTZCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZCapabilities, 0, sizeof(struct ns2__PTZCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZCapabilities(struct soap *soap, const struct ns2__PTZCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZCapabilities);
	if (soap_out_ns2__PTZCapabilities(soap, tag?tag:"ns2:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZCapabilities * SOAP_FMAC4 soap_get_ns2__PTZCapabilities(struct soap *soap, struct ns2__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MediaCapabilities(struct soap *soap, struct ns2__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->StreamingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MediaCapabilities(struct soap *soap, const struct ns2__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
	soap_serialize_PointerTons2__RealTimeStreamingCapabilities(soap, &a->StreamingCapabilities);
	soap_serialize_PointerTons2__MediaCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MediaCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__MediaCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MediaCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	if (a->StreamingCapabilities)
	{	if (soap_out_PointerTons2__RealTimeStreamingCapabilities(soap, "ns2:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:StreamingCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTons2__MediaCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MediaCapabilities * SOAP_FMAC4 soap_in_ns2__MediaCapabilities(struct soap *soap, const char *tag, struct ns2__MediaCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MediaCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MediaCapabilities, sizeof(struct ns2__MediaCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MediaCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RealTimeStreamingCapabilities(soap, "ns2:StreamingCapabilities", &a->StreamingCapabilities, "ns2:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MediaCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:MediaCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MediaCapabilities, 0, sizeof(struct ns2__MediaCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_StreamingCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MediaCapabilities(struct soap *soap, const struct ns2__MediaCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MediaCapabilities);
	if (soap_out_ns2__MediaCapabilities(soap, tag?tag:"ns2:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MediaCapabilities * SOAP_FMAC4 soap_get_ns2__MediaCapabilities(struct soap *soap, struct ns2__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ImagingCapabilities(struct soap *soap, struct ns2__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ImagingCapabilities(struct soap *soap, const struct ns2__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImagingCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__ImagingCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImagingCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ImagingCapabilities * SOAP_FMAC4 soap_in_ns2__ImagingCapabilities(struct soap *soap, const char *tag, struct ns2__ImagingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ImagingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImagingCapabilities, sizeof(struct ns2__ImagingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ImagingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImagingCapabilities, 0, sizeof(struct ns2__ImagingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ImagingCapabilities(struct soap *soap, const struct ns2__ImagingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ImagingCapabilities);
	if (soap_out_ns2__ImagingCapabilities(soap, tag?tag:"ns2:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingCapabilities * SOAP_FMAC4 soap_get_ns2__ImagingCapabilities(struct soap *soap, struct ns2__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EventCapabilities(struct soap *soap, struct ns2__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->WSSubscriptionPolicySupport);
	soap_default_xsd__boolean(soap, &a->WSPullPointSupport);
	soap_default_xsd__boolean(soap, &a->WSPausableSubscriptionManagerInterfaceSupport);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__EventCapabilities(struct soap *soap, const struct ns2__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
	soap_embedded(soap, &a->WSSubscriptionPolicySupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WSPullPointSupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__EventCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:WSSubscriptionPolicySupport", -1, &a->WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:WSPullPointSupport", -1, &a->WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__EventCapabilities * SOAP_FMAC4 soap_in_ns2__EventCapabilities(struct soap *soap, const char *tag, struct ns2__EventCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_WSSubscriptionPolicySupport = 1;
	size_t soap_flag_WSPullPointSupport = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__EventCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventCapabilities, sizeof(struct ns2__EventCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__EventCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_WSSubscriptionPolicySupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:WSSubscriptionPolicySupport", &a->WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport--;
					continue;
				}
			if (soap_flag_WSPullPointSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:WSPullPointSupport", &a->WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport--;
					continue;
				}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:WSPausableSubscriptionManagerInterfaceSupport", &a->WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventCapabilities, 0, sizeof(struct ns2__EventCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_WSSubscriptionPolicySupport > 0 || soap_flag_WSPullPointSupport > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EventCapabilities(struct soap *soap, const struct ns2__EventCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EventCapabilities);
	if (soap_out_ns2__EventCapabilities(soap, tag?tag:"ns2:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventCapabilities * SOAP_FMAC4 soap_get_ns2__EventCapabilities(struct soap *soap, struct ns2__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DeviceCapabilities(struct soap *soap, struct ns2__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->Network = NULL;
	a->System = NULL;
	a->IO = NULL;
	a->Security = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DeviceCapabilities(struct soap *soap, const struct ns2__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
	soap_serialize_PointerTons2__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTons2__SystemCapabilities(soap, &a->System);
	soap_serialize_PointerTons2__IOCapabilities(soap, &a->IO);
	soap_serialize_PointerTons2__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTons2__DeviceCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeviceCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__DeviceCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeviceCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	if (soap_out_PointerTons2__NetworkCapabilities(soap, "ns2:Network", -1, &a->Network, ""))
		return soap->error;
	if (soap_out_PointerTons2__SystemCapabilities(soap, "ns2:System", -1, &a->System, ""))
		return soap->error;
	if (soap_out_PointerTons2__IOCapabilities(soap, "ns2:IO", -1, &a->IO, ""))
		return soap->error;
	if (soap_out_PointerTons2__SecurityCapabilities(soap, "ns2:Security", -1, &a->Security, ""))
		return soap->error;
	if (soap_out_PointerTons2__DeviceCapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DeviceCapabilities * SOAP_FMAC4 soap_in_ns2__DeviceCapabilities(struct soap *soap, const char *tag, struct ns2__DeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Network = 1;
	size_t soap_flag_System = 1;
	size_t soap_flag_IO = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeviceCapabilities, sizeof(struct ns2__DeviceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DeviceCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkCapabilities(soap, "ns2:Network", &a->Network, "ns2:NetworkCapabilities"))
				{	soap_flag_Network--;
					continue;
				}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SystemCapabilities(soap, "ns2:System", &a->System, "ns2:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			if (soap_flag_IO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IOCapabilities(soap, "ns2:IO", &a->IO, "ns2:IOCapabilities"))
				{	soap_flag_IO--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SecurityCapabilities(soap, "ns2:Security", &a->Security, "ns2:SecurityCapabilities"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DeviceCapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeviceCapabilities, 0, sizeof(struct ns2__DeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DeviceCapabilities(struct soap *soap, const struct ns2__DeviceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DeviceCapabilities);
	if (soap_out_ns2__DeviceCapabilities(soap, tag?tag:"ns2:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DeviceCapabilities * SOAP_FMAC4 soap_get_ns2__DeviceCapabilities(struct soap *soap, struct ns2__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AnalyticsCapabilities(struct soap *soap, struct ns2__AnalyticsCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->RuleSupport);
	soap_default_xsd__boolean(soap, &a->AnalyticsModuleSupport);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AnalyticsCapabilities(struct soap *soap, const struct ns2__AnalyticsCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->XAddr);
	soap_embedded(soap, &a->RuleSupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->AnalyticsModuleSupport, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const struct ns2__AnalyticsCapabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnalyticsCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_xsd__anyURI(soap, "ns2:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:RuleSupport", -1, &a->RuleSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:AnalyticsModuleSupport", -1, &a->AnalyticsModuleSupport, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AnalyticsCapabilities * SOAP_FMAC4 soap_in_ns2__AnalyticsCapabilities(struct soap *soap, const char *tag, struct ns2__AnalyticsCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RuleSupport = 1;
	size_t soap_flag_AnalyticsModuleSupport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AnalyticsCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnalyticsCapabilities, sizeof(struct ns2__AnalyticsCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AnalyticsCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:XAddr", &a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:RuleSupport", &a->RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport--;
					continue;
				}
			if (soap_flag_AnalyticsModuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:AnalyticsModuleSupport", &a->AnalyticsModuleSupport, "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnalyticsCapabilities, 0, sizeof(struct ns2__AnalyticsCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_RuleSupport > 0 || soap_flag_AnalyticsModuleSupport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AnalyticsCapabilities(struct soap *soap, const struct ns2__AnalyticsCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AnalyticsCapabilities);
	if (soap_out_ns2__AnalyticsCapabilities(soap, tag?tag:"ns2:AnalyticsCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AnalyticsCapabilities * SOAP_FMAC4 soap_get_ns2__AnalyticsCapabilities(struct soap *soap, struct ns2__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Capabilities(struct soap *soap, struct ns2__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Analytics = NULL;
	a->Device = NULL;
	a->Events = NULL;
	a->Imaging = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Capabilities(struct soap *soap, const struct ns2__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AnalyticsCapabilities(soap, &a->Analytics);
	soap_serialize_PointerTons2__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTons2__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTons2__ImagingCapabilities(soap, &a->Imaging);
	soap_serialize_PointerTons2__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTons2__PTZCapabilities(soap, &a->PTZ);
	soap_serialize_PointerTons2__CapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Capabilities(struct soap *soap, const char *tag, int id, const struct ns2__Capabilities *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTons2__AnalyticsCapabilities(soap, "ns2:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (soap_out_PointerTons2__DeviceCapabilities(soap, "ns2:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTons2__EventCapabilities(soap, "ns2:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTons2__ImagingCapabilities(soap, "ns2:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTons2__MediaCapabilities(soap, "ns2:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZCapabilities(soap, "ns2:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTons2__CapabilitiesExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Capabilities * SOAP_FMAC4 soap_in_ns2__Capabilities(struct soap *soap, const char *tag, struct ns2__Capabilities *a, const char *type)
{
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Capabilities, sizeof(struct ns2__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Capabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AnalyticsCapabilities(soap, "ns2:Analytics", &a->Analytics, "ns2:AnalyticsCapabilities"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DeviceCapabilities(soap, "ns2:Device", &a->Device, "ns2:DeviceCapabilities"))
				{	soap_flag_Device--;
					continue;
				}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EventCapabilities(soap, "ns2:Events", &a->Events, "ns2:EventCapabilities"))
				{	soap_flag_Events--;
					continue;
				}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ImagingCapabilities(soap, "ns2:Imaging", &a->Imaging, "ns2:ImagingCapabilities"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MediaCapabilities(soap, "ns2:Media", &a->Media, "ns2:MediaCapabilities"))
				{	soap_flag_Media--;
					continue;
				}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZCapabilities(soap, "ns2:PTZ", &a->PTZ, "ns2:PTZCapabilities"))
				{	soap_flag_PTZ--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CapabilitiesExtension(soap, "ns2:Extension", &a->Extension, "ns2:CapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Capabilities, 0, sizeof(struct ns2__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Capabilities(struct soap *soap, const struct ns2__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Capabilities);
	if (soap_out_ns2__Capabilities(soap, tag?tag:"ns2:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Capabilities * SOAP_FMAC4 soap_get_ns2__Capabilities(struct soap *soap, struct ns2__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPAddressFilterExtension(struct soap *soap, struct ns2__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPAddressFilterExtension(struct soap *soap, const struct ns2__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const struct ns2__IPAddressFilterExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPAddressFilterExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPAddressFilterExtension * SOAP_FMAC4 soap_in_ns2__IPAddressFilterExtension(struct soap *soap, const char *tag, struct ns2__IPAddressFilterExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPAddressFilterExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPAddressFilterExtension, sizeof(struct ns2__IPAddressFilterExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPAddressFilterExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPAddressFilterExtension, 0, sizeof(struct ns2__IPAddressFilterExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPAddressFilterExtension(struct soap *soap, const struct ns2__IPAddressFilterExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPAddressFilterExtension);
	if (soap_out_ns2__IPAddressFilterExtension(soap, tag?tag:"ns2:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPAddressFilterExtension * SOAP_FMAC4 soap_get_ns2__IPAddressFilterExtension(struct soap *soap, struct ns2__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPAddressFilter(struct soap *soap, struct ns2__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__IPAddressFilterType(soap, &a->Type);
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPAddressFilter(struct soap *soap, const struct ns2__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_embedded(soap, a->IPv4Address + i, SOAP_TYPE_ns2__PrefixedIPv4Address);
			soap_serialize_ns2__PrefixedIPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_embedded(soap, a->IPv6Address + i, SOAP_TYPE_ns2__PrefixedIPv6Address);
			soap_serialize_ns2__PrefixedIPv6Address(soap, a->IPv6Address + i);
		}
	}
	soap_serialize_PointerTons2__IPAddressFilterExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPAddressFilter(struct soap *soap, const char *tag, int id, const struct ns2__IPAddressFilter *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPAddressFilter), type))
		return soap->error;
	if (soap_out_ns2__IPAddressFilterType(soap, "ns2:Type", -1, &a->Type, ""))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_ns2__PrefixedIPv4Address(soap, "ns2:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_ns2__PrefixedIPv6Address(soap, "ns2:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__IPAddressFilterExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPAddressFilter * SOAP_FMAC4 soap_in_ns2__IPAddressFilter(struct soap *soap, const char *tag, struct ns2__IPAddressFilter *a, const char *type)
{
	size_t soap_flag_Type = 1;
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPAddressFilter, sizeof(struct ns2__IPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPAddressFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__IPAddressFilterType(soap, "ns2:Type", &a->Type, "ns2:IPAddressFilterType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (struct ns2__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_IPv4Address, sizeof(struct ns2__PrefixedIPv4Address));
					if (a->IPv4Address == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv4Address(soap, a->IPv4Address);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv4Address(soap, "ns2:IPv4Address", a->IPv4Address, "ns2:PrefixedIPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (struct ns2__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_IPv6Address, sizeof(struct ns2__PrefixedIPv6Address));
					if (a->IPv6Address == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv6Address(soap, a->IPv6Address);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv6Address(soap, "ns2:IPv6Address", a->IPv6Address, "ns2:PrefixedIPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPAddressFilterExtension(soap, "ns2:Extension", &a->Extension, "ns2:IPAddressFilterExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (struct ns2__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (struct ns2__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPAddressFilter, 0, sizeof(struct ns2__IPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPAddressFilter(struct soap *soap, const struct ns2__IPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPAddressFilter);
	if (soap_out_ns2__IPAddressFilter(soap, tag?tag:"ns2:IPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPAddressFilter * SOAP_FMAC4 soap_get_ns2__IPAddressFilter(struct soap *soap, struct ns2__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkZeroConfigurationExtension(struct soap *soap, struct ns2__NetworkZeroConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkZeroConfigurationExtension(struct soap *soap, const struct ns2__NetworkZeroConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns2__NetworkZeroConfigurationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_ns2__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, struct ns2__NetworkZeroConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkZeroConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension, sizeof(struct ns2__NetworkZeroConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkZeroConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension, 0, sizeof(struct ns2__NetworkZeroConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkZeroConfigurationExtension(struct soap *soap, const struct ns2__NetworkZeroConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension);
	if (soap_out_ns2__NetworkZeroConfigurationExtension(soap, tag?tag:"ns2:NetworkZeroConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_ns2__NetworkZeroConfigurationExtension(struct soap *soap, struct ns2__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkZeroConfiguration(struct soap *soap, struct ns2__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->InterfaceToken);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->__sizeAddresses = 0;
	a->Addresses = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkZeroConfiguration(struct soap *soap, const struct ns2__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__ReferenceToken(soap, &a->InterfaceToken);
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	if (a->Addresses)
	{	int i;
		for (i = 0; i < a->__sizeAddresses; i++)
		{
			soap_serialize_ns2__IPv4Address(soap, a->Addresses + i);
		}
	}
	soap_serialize_PointerTons2__NetworkZeroConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__NetworkZeroConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkZeroConfiguration), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_ns2__ReferenceToken(soap, "ns2:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:InterfaceToken"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Addresses)
	{	int i;
		for (i = 0; i < a->__sizeAddresses; i++)
			if (soap_out_ns2__IPv4Address(soap, "ns2:Addresses", -1, a->Addresses + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__NetworkZeroConfigurationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_ns2__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct ns2__NetworkZeroConfiguration *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Addresses = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkZeroConfiguration, sizeof(struct ns2__NetworkZeroConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkZeroConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns2:InterfaceToken", &a->InterfaceToken, "ns2:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Addresses", 1, NULL))
			{	if (a->Addresses == NULL)
				{	if (soap_blist_Addresses == NULL)
						soap_blist_Addresses = soap_new_block(soap);
					a->Addresses = (char **)soap_push_block(soap, soap_blist_Addresses, sizeof(char *));
					if (a->Addresses == NULL)
						return NULL;
					*a->Addresses = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__IPv4Address(soap, "ns2:Addresses", a->Addresses, "ns2:IPv4Address"))
				{	a->__sizeAddresses++;
					a->Addresses = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkZeroConfigurationExtension(soap, "ns2:Extension", &a->Extension, "ns2:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Addresses)
			soap_pop_block(soap, soap_blist_Addresses);
		if (a->__sizeAddresses)
			a->Addresses = (char **)soap_save_block(soap, soap_blist_Addresses, NULL, 1);
		else
		{	a->Addresses = NULL;
			if (soap_blist_Addresses)
				soap_end_block(soap, soap_blist_Addresses);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkZeroConfiguration, 0, sizeof(struct ns2__NetworkZeroConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkZeroConfiguration(struct soap *soap, const struct ns2__NetworkZeroConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkZeroConfiguration);
	if (soap_out_ns2__NetworkZeroConfiguration(soap, tag?tag:"ns2:NetworkZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_ns2__NetworkZeroConfiguration(struct soap *soap, struct ns2__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkGateway(struct soap *soap, struct ns2__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkGateway(struct soap *soap, const struct ns2__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_serialize_ns2__IPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_serialize_ns2__IPv6Address(soap, a->IPv6Address + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkGateway(struct soap *soap, const char *tag, int id, const struct ns2__NetworkGateway *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_ns2__IPv4Address(soap, "ns2:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_ns2__IPv6Address(soap, "ns2:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkGateway * SOAP_FMAC4 soap_in_ns2__NetworkGateway(struct soap *soap, const char *tag, struct ns2__NetworkGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkGateway, sizeof(struct ns2__NetworkGateway), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (char **)soap_push_block(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__IPv4Address(soap, "ns2:IPv4Address", a->IPv4Address, "ns2:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (char **)soap_push_block(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__IPv6Address(soap, "ns2:IPv6Address", a->IPv6Address, "ns2:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkGateway, 0, sizeof(struct ns2__NetworkGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkGateway(struct soap *soap, const struct ns2__NetworkGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkGateway);
	if (soap_out_ns2__NetworkGateway(soap, tag?tag:"ns2:NetworkGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkGateway * SOAP_FMAC4 soap_get_ns2__NetworkGateway(struct soap *soap, struct ns2__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct ns2__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct ns2__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_ns2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterfaceSetConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension, sizeof(struct ns2__NetworkInterfaceSetConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterfaceSetConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension, 0, sizeof(struct ns2__NetworkInterfaceSetConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct ns2__NetworkInterfaceSetConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_ns2__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"ns2:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_ns2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct ns2__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->AcceptRouterAdvert = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct ns2__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean(soap, &a->AcceptRouterAdvert);
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_ns2__PrefixedIPv6Address);
			soap_serialize_ns2__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTons2__IPv6DHCPConfiguration(soap, &a->DHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_ns2__PrefixedIPv6Address(soap, "ns2:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__IPv6DHCPConfiguration(soap, "ns2:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct ns2__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_AcceptRouterAdvert = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv6NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration, sizeof(struct ns2__IPv6NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv6NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct ns2__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct ns2__PrefixedIPv6Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv6Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv6Address(soap, "ns2:Manual", a->Manual, "ns2:PrefixedIPv6Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6DHCPConfiguration(soap, "ns2:DHCP", &a->DHCP, "ns2:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct ns2__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration, 0, sizeof(struct ns2__IPv6NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct ns2__IPv6NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_ns2__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"ns2:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_ns2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct ns2__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_ns2__PrefixedIPv4Address);
			soap_serialize_ns2__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->DHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_ns2__PrefixedIPv4Address(soap, "ns2:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "ns2:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct ns2__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv4NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration, sizeof(struct ns2__IPv4NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv4NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct ns2__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct ns2__PrefixedIPv4Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv4Address(soap, "ns2:Manual", a->Manual, "ns2:PrefixedIPv4Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:DHCP", &a->DHCP, "xsd:boolean"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct ns2__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration, 0, sizeof(struct ns2__IPv4NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct ns2__IPv4NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_ns2__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"ns2:IPv4NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_ns2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->Link = NULL;
	a->MTU = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterfaceSetConfiguration(struct soap *soap, const struct ns2__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerTons2__NetworkInterfaceConnectionSetting(soap, &a->Link);
	soap_serialize_PointerToint(soap, &a->MTU);
	soap_serialize_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, &a->IPv4);
	soap_serialize_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, &a->IPv6);
	soap_serialize_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterfaceSetConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkInterfaceConnectionSetting(soap, "ns2:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:MTU", -1, &a->MTU, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, "ns2:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, "ns2:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_ns2__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_MTU = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration, sizeof(struct ns2__NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterfaceSetConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceConnectionSetting(soap, "ns2:Link", &a->Link, "ns2:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link--;
					continue;
				}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, "ns2:IPv4", &a->IPv4, "ns2:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv4--;
					continue;
				}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, "ns2:IPv6", &a->IPv6, "ns2:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv6--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, "ns2:Extension", &a->Extension, "ns2:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration, 0, sizeof(struct ns2__NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterfaceSetConfiguration(struct soap *soap, const struct ns2__NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration);
	if (soap_out_ns2__NetworkInterfaceSetConfiguration(soap, tag?tag:"ns2:NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_ns2__NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DynamicDNSInformationExtension(struct soap *soap, struct ns2__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DynamicDNSInformationExtension(struct soap *soap, const struct ns2__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const struct ns2__DynamicDNSInformationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DynamicDNSInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_ns2__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct ns2__DynamicDNSInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DynamicDNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DynamicDNSInformationExtension, sizeof(struct ns2__DynamicDNSInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DynamicDNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DynamicDNSInformationExtension, 0, sizeof(struct ns2__DynamicDNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DynamicDNSInformationExtension(struct soap *soap, const struct ns2__DynamicDNSInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DynamicDNSInformationExtension);
	if (soap_out_ns2__DynamicDNSInformationExtension(soap, tag?tag:"ns2:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_ns2__DynamicDNSInformationExtension(struct soap *soap, struct ns2__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DynamicDNSInformation(struct soap *soap, struct ns2__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__DynamicDNSType(soap, &a->Type);
	a->Name = NULL;
	a->TTL = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DynamicDNSInformation(struct soap *soap, const struct ns2__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DNSName(soap, &a->Name);
	soap_serialize_PointerToxsd__duration(soap, &a->TTL);
	soap_serialize_PointerTons2__DynamicDNSInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const struct ns2__DynamicDNSInformation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_ns2__DynamicDNSType(soap, "ns2:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTons2__DNSName(soap, "ns2:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns2:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_PointerTons2__DynamicDNSInformationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DynamicDNSInformation * SOAP_FMAC4 soap_in_ns2__DynamicDNSInformation(struct soap *soap, const char *tag, struct ns2__DynamicDNSInformation *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DynamicDNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DynamicDNSInformation, sizeof(struct ns2__DynamicDNSInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DynamicDNSInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__DynamicDNSType(soap, "ns2:Type", &a->Type, "ns2:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DNSName(soap, "ns2:Name", &a->Name, "ns2:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns2:TTL", &a->TTL, "xsd:duration"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DynamicDNSInformationExtension(soap, "ns2:Extension", &a->Extension, "ns2:DynamicDNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DynamicDNSInformation, 0, sizeof(struct ns2__DynamicDNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DynamicDNSInformation(struct soap *soap, const struct ns2__DynamicDNSInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DynamicDNSInformation);
	if (soap_out_ns2__DynamicDNSInformation(soap, tag?tag:"ns2:DynamicDNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DynamicDNSInformation * SOAP_FMAC4 soap_get_ns2__DynamicDNSInformation(struct soap *soap, struct ns2__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NTPInformationExtension(struct soap *soap, struct ns2__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NTPInformationExtension(struct soap *soap, const struct ns2__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NTPInformationExtension(struct soap *soap, const char *tag, int id, const struct ns2__NTPInformationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NTPInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NTPInformationExtension * SOAP_FMAC4 soap_in_ns2__NTPInformationExtension(struct soap *soap, const char *tag, struct ns2__NTPInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NTPInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NTPInformationExtension, sizeof(struct ns2__NTPInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NTPInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NTPInformationExtension, 0, sizeof(struct ns2__NTPInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NTPInformationExtension(struct soap *soap, const struct ns2__NTPInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NTPInformationExtension);
	if (soap_out_ns2__NTPInformationExtension(soap, tag?tag:"ns2:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NTPInformationExtension * SOAP_FMAC4 soap_get_ns2__NTPInformationExtension(struct soap *soap, struct ns2__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NTPInformation(struct soap *soap, struct ns2__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeNTPFromDHCP = 0;
	a->NTPFromDHCP = NULL;
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NTPInformation(struct soap *soap, const struct ns2__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeNTPFromDHCP; i++)
		{
			soap_embedded(soap, a->NTPFromDHCP + i, SOAP_TYPE_ns2__NetworkHost);
			soap_serialize_ns2__NetworkHost(soap, a->NTPFromDHCP + i);
		}
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_ns2__NetworkHost);
			soap_serialize_ns2__NetworkHost(soap, a->NTPManual + i);
		}
	}
	soap_serialize_PointerTons2__NTPInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NTPInformation(struct soap *soap, const char *tag, int id, const struct ns2__NTPInformation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NTPInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeNTPFromDHCP; i++)
			if (soap_out_ns2__NetworkHost(soap, "ns2:NTPFromDHCP", -1, a->NTPFromDHCP + i, ""))
				return soap->error;
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
			if (soap_out_ns2__NetworkHost(soap, "ns2:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__NTPInformationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NTPInformation * SOAP_FMAC4 soap_in_ns2__NTPInformation(struct soap *soap, const char *tag, struct ns2__NTPInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPFromDHCP = NULL;
	struct soap_blist *soap_blist_NTPManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NTPInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NTPInformation, sizeof(struct ns2__NTPInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NTPInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:NTPFromDHCP", 1, NULL))
			{	if (a->NTPFromDHCP == NULL)
				{	if (soap_blist_NTPFromDHCP == NULL)
						soap_blist_NTPFromDHCP = soap_new_block(soap);
					a->NTPFromDHCP = (struct ns2__NetworkHost *)soap_push_block(soap, soap_blist_NTPFromDHCP, sizeof(struct ns2__NetworkHost));
					if (a->NTPFromDHCP == NULL)
						return NULL;
					soap_default_ns2__NetworkHost(soap, a->NTPFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_ns2__NetworkHost(soap, "ns2:NTPFromDHCP", a->NTPFromDHCP, "ns2:NetworkHost"))
				{	a->__sizeNTPFromDHCP++;
					a->NTPFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_new_block(soap);
					a->NTPManual = (struct ns2__NetworkHost *)soap_push_block(soap, soap_blist_NTPManual, sizeof(struct ns2__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_ns2__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_ns2__NetworkHost(soap, "ns2:NTPManual", a->NTPManual, "ns2:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NTPInformationExtension(soap, "ns2:Extension", &a->Extension, "ns2:NTPInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPFromDHCP)
			soap_pop_block(soap, soap_blist_NTPFromDHCP);
		if (a->__sizeNTPFromDHCP)
			a->NTPFromDHCP = (struct ns2__NetworkHost *)soap_save_block(soap, soap_blist_NTPFromDHCP, NULL, 1);
		else
		{	a->NTPFromDHCP = NULL;
			if (soap_blist_NTPFromDHCP)
				soap_end_block(soap, soap_blist_NTPFromDHCP);
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
			a->NTPManual = (struct ns2__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NTPInformation, 0, sizeof(struct ns2__NTPInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NTPInformation(struct soap *soap, const struct ns2__NTPInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NTPInformation);
	if (soap_out_ns2__NTPInformation(soap, tag?tag:"ns2:NTPInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NTPInformation * SOAP_FMAC4 soap_get_ns2__NTPInformation(struct soap *soap, struct ns2__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DNSInformationExtension(struct soap *soap, struct ns2__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DNSInformationExtension(struct soap *soap, const struct ns2__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DNSInformationExtension(struct soap *soap, const char *tag, int id, const struct ns2__DNSInformationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DNSInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DNSInformationExtension * SOAP_FMAC4 soap_in_ns2__DNSInformationExtension(struct soap *soap, const char *tag, struct ns2__DNSInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DNSInformationExtension, sizeof(struct ns2__DNSInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DNSInformationExtension, 0, sizeof(struct ns2__DNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DNSInformationExtension(struct soap *soap, const struct ns2__DNSInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DNSInformationExtension);
	if (soap_out_ns2__DNSInformationExtension(soap, tag?tag:"ns2:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DNSInformationExtension * SOAP_FMAC4 soap_get_ns2__DNSInformationExtension(struct soap *soap, struct ns2__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DNSInformation(struct soap *soap, struct ns2__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSFromDHCP = 0;
	a->DNSFromDHCP = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DNSInformation(struct soap *soap, const struct ns2__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, a->SearchDomain + i);
		}
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeDNSFromDHCP; i++)
		{
			soap_embedded(soap, a->DNSFromDHCP + i, SOAP_TYPE_ns2__IPAddress);
			soap_serialize_ns2__IPAddress(soap, a->DNSFromDHCP + i);
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_ns2__IPAddress);
			soap_serialize_ns2__IPAddress(soap, a->DNSManual + i);
		}
	}
	soap_serialize_PointerTons2__DNSInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DNSInformation(struct soap *soap, const char *tag, int id, const struct ns2__DNSInformation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DNSInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
			if (soap_out_xsd__token(soap, "ns2:SearchDomain", -1, a->SearchDomain + i, ""))
				return soap->error;
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeDNSFromDHCP; i++)
			if (soap_out_ns2__IPAddress(soap, "ns2:DNSFromDHCP", -1, a->DNSFromDHCP + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
			if (soap_out_ns2__IPAddress(soap, "ns2:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__DNSInformationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DNSInformation * SOAP_FMAC4 soap_in_ns2__DNSInformation(struct soap *soap, const char *tag, struct ns2__DNSInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSFromDHCP = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DNSInformation, sizeof(struct ns2__DNSInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DNSInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_new_block(soap);
					a->SearchDomain = (char **)soap_push_block(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "ns2:SearchDomain", a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:DNSFromDHCP", 1, NULL))
			{	if (a->DNSFromDHCP == NULL)
				{	if (soap_blist_DNSFromDHCP == NULL)
						soap_blist_DNSFromDHCP = soap_new_block(soap);
					a->DNSFromDHCP = (struct ns2__IPAddress *)soap_push_block(soap, soap_blist_DNSFromDHCP, sizeof(struct ns2__IPAddress));
					if (a->DNSFromDHCP == NULL)
						return NULL;
					soap_default_ns2__IPAddress(soap, a->DNSFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_ns2__IPAddress(soap, "ns2:DNSFromDHCP", a->DNSFromDHCP, "ns2:IPAddress"))
				{	a->__sizeDNSFromDHCP++;
					a->DNSFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_new_block(soap);
					a->DNSManual = (struct ns2__IPAddress *)soap_push_block(soap, soap_blist_DNSManual, sizeof(struct ns2__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_ns2__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_ns2__IPAddress(soap, "ns2:DNSManual", a->DNSManual, "ns2:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DNSInformationExtension(soap, "ns2:Extension", &a->Extension, "ns2:DNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
			a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSFromDHCP)
			soap_pop_block(soap, soap_blist_DNSFromDHCP);
		if (a->__sizeDNSFromDHCP)
			a->DNSFromDHCP = (struct ns2__IPAddress *)soap_save_block(soap, soap_blist_DNSFromDHCP, NULL, 1);
		else
		{	a->DNSFromDHCP = NULL;
			if (soap_blist_DNSFromDHCP)
				soap_end_block(soap, soap_blist_DNSFromDHCP);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
			a->DNSManual = (struct ns2__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DNSInformation, 0, sizeof(struct ns2__DNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DNSInformation(struct soap *soap, const struct ns2__DNSInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DNSInformation);
	if (soap_out_ns2__DNSInformation(soap, tag?tag:"ns2:DNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DNSInformation * SOAP_FMAC4 soap_get_ns2__DNSInformation(struct soap *soap, struct ns2__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__HostnameInformationExtension(struct soap *soap, struct ns2__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__HostnameInformationExtension(struct soap *soap, const struct ns2__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const struct ns2__HostnameInformationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HostnameInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__HostnameInformationExtension * SOAP_FMAC4 soap_in_ns2__HostnameInformationExtension(struct soap *soap, const char *tag, struct ns2__HostnameInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__HostnameInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HostnameInformationExtension, sizeof(struct ns2__HostnameInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__HostnameInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HostnameInformationExtension, 0, sizeof(struct ns2__HostnameInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__HostnameInformationExtension(struct soap *soap, const struct ns2__HostnameInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__HostnameInformationExtension);
	if (soap_out_ns2__HostnameInformationExtension(soap, tag?tag:"ns2:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__HostnameInformationExtension * SOAP_FMAC4 soap_get_ns2__HostnameInformationExtension(struct soap *soap, struct ns2__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__HostnameInformation(struct soap *soap, struct ns2__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	soap_default_xsd__token(soap, &a->Name);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__HostnameInformation(struct soap *soap, const struct ns2__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	soap_serialize_xsd__token(soap, &a->Name);
	soap_serialize_PointerTons2__HostnameInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HostnameInformation(struct soap *soap, const char *tag, int id, const struct ns2__HostnameInformation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HostnameInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "ns2:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTons2__HostnameInformationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__HostnameInformation * SOAP_FMAC4 soap_in_ns2__HostnameInformation(struct soap *soap, const char *tag, struct ns2__HostnameInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__HostnameInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HostnameInformation, sizeof(struct ns2__HostnameInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__HostnameInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "ns2:Name", &a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HostnameInformationExtension(soap, "ns2:Extension", &a->Extension, "ns2:HostnameInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HostnameInformation, 0, sizeof(struct ns2__HostnameInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__HostnameInformation(struct soap *soap, const struct ns2__HostnameInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__HostnameInformation);
	if (soap_out_ns2__HostnameInformation(soap, tag?tag:"ns2:HostnameInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__HostnameInformation * SOAP_FMAC4 soap_get_ns2__HostnameInformation(struct soap *soap, struct ns2__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkHostExtension(struct soap *soap, struct ns2__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkHostExtension(struct soap *soap, const struct ns2__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkHostExtension(struct soap *soap, const char *tag, int id, const struct ns2__NetworkHostExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkHostExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkHostExtension * SOAP_FMAC4 soap_in_ns2__NetworkHostExtension(struct soap *soap, const char *tag, struct ns2__NetworkHostExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkHostExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkHostExtension, sizeof(struct ns2__NetworkHostExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkHostExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkHostExtension, 0, sizeof(struct ns2__NetworkHostExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkHostExtension(struct soap *soap, const struct ns2__NetworkHostExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkHostExtension);
	if (soap_out_ns2__NetworkHostExtension(soap, tag?tag:"ns2:NetworkHostExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkHostExtension * SOAP_FMAC4 soap_get_ns2__NetworkHostExtension(struct soap *soap, struct ns2__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkHost(struct soap *soap, struct ns2__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__NetworkHostType(soap, &a->Type);
	a->IPv4Address = NULL;
	a->IPv6Address = NULL;
	a->DNSname = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkHost(struct soap *soap, const struct ns2__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IPv4Address(soap, &a->IPv4Address);
	soap_serialize_PointerTons2__IPv6Address(soap, &a->IPv6Address);
	soap_serialize_PointerTons2__DNSName(soap, &a->DNSname);
	soap_serialize_PointerTons2__NetworkHostExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkHost(struct soap *soap, const char *tag, int id, const struct ns2__NetworkHost *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkHost), type))
		return soap->error;
	if (soap_out_ns2__NetworkHostType(soap, "ns2:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv4Address(soap, "ns2:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv6Address(soap, "ns2:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTons2__DNSName(soap, "ns2:DNSname", -1, &a->DNSname, ""))
		return soap->error;
	if (soap_out_PointerTons2__NetworkHostExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkHost * SOAP_FMAC4 soap_in_ns2__NetworkHost(struct soap *soap, const char *tag, struct ns2__NetworkHost *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_DNSname = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkHost *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkHost, sizeof(struct ns2__NetworkHost), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkHost(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__NetworkHostType(soap, "ns2:Type", &a->Type, "ns2:NetworkHostType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv4Address(soap, "ns2:IPv4Address", &a->IPv4Address, "ns2:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6Address(soap, "ns2:IPv6Address", &a->IPv6Address, "ns2:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap_flag_DNSname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DNSName(soap, "ns2:DNSname", &a->DNSname, "ns2:DNSName"))
				{	soap_flag_DNSname--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkHostExtension(soap, "ns2:Extension", &a->Extension, "ns2:NetworkHostExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkHost, 0, sizeof(struct ns2__NetworkHost), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkHost(struct soap *soap, const struct ns2__NetworkHost *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkHost);
	if (soap_out_ns2__NetworkHost(soap, tag?tag:"ns2:NetworkHost", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkHost * SOAP_FMAC4 soap_get_ns2__NetworkHost(struct soap *soap, struct ns2__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkProtocolExtension(struct soap *soap, struct ns2__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkProtocolExtension(struct soap *soap, const struct ns2__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const struct ns2__NetworkProtocolExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkProtocolExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkProtocolExtension * SOAP_FMAC4 soap_in_ns2__NetworkProtocolExtension(struct soap *soap, const char *tag, struct ns2__NetworkProtocolExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkProtocolExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkProtocolExtension, sizeof(struct ns2__NetworkProtocolExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkProtocolExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkProtocolExtension, 0, sizeof(struct ns2__NetworkProtocolExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkProtocolExtension(struct soap *soap, const struct ns2__NetworkProtocolExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkProtocolExtension);
	if (soap_out_ns2__NetworkProtocolExtension(soap, tag?tag:"ns2:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkProtocolExtension * SOAP_FMAC4 soap_get_ns2__NetworkProtocolExtension(struct soap *soap, struct ns2__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkProtocol(struct soap *soap, struct ns2__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__NetworkProtocolType(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->__sizePort = 0;
	a->Port = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkProtocol(struct soap *soap, const struct ns2__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	if (a->Port)
	{	int i;
		for (i = 0; i < a->__sizePort; i++)
		{
			soap_embedded(soap, a->Port + i, SOAP_TYPE_int);
		}
	}
	soap_serialize_PointerTons2__NetworkProtocolExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkProtocol(struct soap *soap, const char *tag, int id, const struct ns2__NetworkProtocol *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkProtocol), type))
		return soap->error;
	if (soap_out_ns2__NetworkProtocolType(soap, "ns2:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Port)
	{	int i;
		for (i = 0; i < a->__sizePort; i++)
			if (soap_out_int(soap, "ns2:Port", -1, a->Port + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__NetworkProtocolExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkProtocol * SOAP_FMAC4 soap_in_ns2__NetworkProtocol(struct soap *soap, const char *tag, struct ns2__NetworkProtocol *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Port = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkProtocol, sizeof(struct ns2__NetworkProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkProtocol(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__NetworkProtocolType(soap, "ns2:Name", &a->Name, "ns2:NetworkProtocolType"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Port", 1, NULL))
			{	if (a->Port == NULL)
				{	if (soap_blist_Port == NULL)
						soap_blist_Port = soap_new_block(soap);
					a->Port = (int *)soap_push_block(soap, soap_blist_Port, sizeof(int));
					if (a->Port == NULL)
						return NULL;
					soap_default_int(soap, a->Port);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "ns2:Port", a->Port, "xsd:int"))
				{	a->__sizePort++;
					a->Port = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkProtocolExtension(soap, "ns2:Extension", &a->Extension, "ns2:NetworkProtocolExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Port)
			soap_pop_block(soap, soap_blist_Port);
		if (a->__sizePort)
			a->Port = (int *)soap_save_block(soap, soap_blist_Port, NULL, 1);
		else
		{	a->Port = NULL;
			if (soap_blist_Port)
				soap_end_block(soap, soap_blist_Port);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkProtocol, 0, sizeof(struct ns2__NetworkProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Enabled > 0 || a->__sizePort < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkProtocol(struct soap *soap, const struct ns2__NetworkProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkProtocol);
	if (soap_out_ns2__NetworkProtocol(soap, tag?tag:"ns2:NetworkProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkProtocol * SOAP_FMAC4 soap_get_ns2__NetworkProtocol(struct soap *soap, struct ns2__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv6ConfigurationExtension(struct soap *soap, struct ns2__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv6ConfigurationExtension(struct soap *soap, const struct ns2__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns2__IPv6ConfigurationExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv6ConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_ns2__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct ns2__IPv6ConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv6ConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv6ConfigurationExtension, sizeof(struct ns2__IPv6ConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv6ConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv6ConfigurationExtension, 0, sizeof(struct ns2__IPv6ConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv6ConfigurationExtension(struct soap *soap, const struct ns2__IPv6ConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv6ConfigurationExtension);
	if (soap_out_ns2__IPv6ConfigurationExtension(soap, tag?tag:"ns2:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_ns2__IPv6ConfigurationExtension(struct soap *soap, struct ns2__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PrefixedIPv6Address(struct soap *soap, struct ns2__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__IPv6Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PrefixedIPv6Address(struct soap *soap, const struct ns2__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__IPv6Address(soap, &a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const struct ns2__PrefixedIPv6Address *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PrefixedIPv6Address), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_ns2__IPv6Address(soap, "ns2:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Address"))
		return soap->error;
	if (soap_out_int(soap, "ns2:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PrefixedIPv6Address * SOAP_FMAC4 soap_in_ns2__PrefixedIPv6Address(struct soap *soap, const char *tag, struct ns2__PrefixedIPv6Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PrefixedIPv6Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PrefixedIPv6Address, sizeof(struct ns2__PrefixedIPv6Address), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PrefixedIPv6Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__IPv6Address(soap, "ns2:Address", &a->Address, "ns2:IPv6Address"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:PrefixLength", &a->PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PrefixedIPv6Address, 0, sizeof(struct ns2__PrefixedIPv6Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PrefixedIPv6Address(struct soap *soap, const struct ns2__PrefixedIPv6Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PrefixedIPv6Address);
	if (soap_out_ns2__PrefixedIPv6Address(soap, tag?tag:"ns2:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PrefixedIPv6Address * SOAP_FMAC4 soap_get_ns2__PrefixedIPv6Address(struct soap *soap, struct ns2__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PrefixedIPv4Address(struct soap *soap, struct ns2__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__IPv4Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PrefixedIPv4Address(struct soap *soap, const struct ns2__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__IPv4Address(soap, &a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const struct ns2__PrefixedIPv4Address *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PrefixedIPv4Address), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_ns2__IPv4Address(soap, "ns2:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Address"))
		return soap->error;
	if (soap_out_int(soap, "ns2:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PrefixedIPv4Address * SOAP_FMAC4 soap_in_ns2__PrefixedIPv4Address(struct soap *soap, const char *tag, struct ns2__PrefixedIPv4Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PrefixedIPv4Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PrefixedIPv4Address, sizeof(struct ns2__PrefixedIPv4Address), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PrefixedIPv4Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__IPv4Address(soap, "ns2:Address", &a->Address, "ns2:IPv4Address"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:PrefixLength", &a->PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PrefixedIPv4Address, 0, sizeof(struct ns2__PrefixedIPv4Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PrefixedIPv4Address(struct soap *soap, const struct ns2__PrefixedIPv4Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PrefixedIPv4Address);
	if (soap_out_ns2__PrefixedIPv4Address(soap, tag?tag:"ns2:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PrefixedIPv4Address * SOAP_FMAC4 soap_get_ns2__PrefixedIPv4Address(struct soap *soap, struct ns2__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv4Configuration(struct soap *soap, struct ns2__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->LinkLocal = NULL;
	a->FromDHCP = NULL;
	soap_default_xsd__boolean(soap, &a->DHCP);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv4Configuration(struct soap *soap, const struct ns2__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_ns2__PrefixedIPv4Address);
			soap_serialize_ns2__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTons2__PrefixedIPv4Address(soap, &a->LinkLocal);
	soap_serialize_PointerTons2__PrefixedIPv4Address(soap, &a->FromDHCP);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv4Configuration(struct soap *soap, const char *tag, int id, const struct ns2__IPv4Configuration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv4Configuration), type))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_ns2__PrefixedIPv4Address(soap, "ns2:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__PrefixedIPv4Address(soap, "ns2:LinkLocal", -1, &a->LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTons2__PrefixedIPv4Address(soap, "ns2:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv4Configuration * SOAP_FMAC4 soap_in_ns2__IPv4Configuration(struct soap *soap, const char *tag, struct ns2__IPv4Configuration *a, const char *type)
{
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_LinkLocal = 1;
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv4Configuration, sizeof(struct ns2__IPv4Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv4Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct ns2__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct ns2__PrefixedIPv4Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv4Address(soap, "ns2:Manual", a->Manual, "ns2:PrefixedIPv4Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_LinkLocal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PrefixedIPv4Address(soap, "ns2:LinkLocal", &a->LinkLocal, "ns2:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal--;
					continue;
				}
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PrefixedIPv4Address(soap, "ns2:FromDHCP", &a->FromDHCP, "ns2:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:DHCP", &a->DHCP, "xsd:boolean"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct ns2__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv4Configuration, 0, sizeof(struct ns2__IPv4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv4Configuration(struct soap *soap, const struct ns2__IPv4Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv4Configuration);
	if (soap_out_ns2__IPv4Configuration(soap, tag?tag:"ns2:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv4Configuration * SOAP_FMAC4 soap_get_ns2__IPv4Configuration(struct soap *soap, struct ns2__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv4NetworkInterface(struct soap *soap, struct ns2__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv4NetworkInterface(struct soap *soap, const struct ns2__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTons2__IPv4Configuration(soap, &a->Config);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const struct ns2__IPv4NetworkInterface *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Config)
	{	if (soap_out_PointerTons2__IPv4Configuration(soap, "ns2:Config", -1, &a->Config, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Config"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterface * SOAP_FMAC4 soap_in_ns2__IPv4NetworkInterface(struct soap *soap, const char *tag, struct ns2__IPv4NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv4NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv4NetworkInterface, sizeof(struct ns2__IPv4NetworkInterface), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv4NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv4Configuration(soap, "ns2:Config", &a->Config, "ns2:IPv4Configuration"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv4NetworkInterface, 0, sizeof(struct ns2__IPv4NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0 || soap_flag_Config > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv4NetworkInterface(struct soap *soap, const struct ns2__IPv4NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv4NetworkInterface);
	if (soap_out_ns2__IPv4NetworkInterface(soap, tag?tag:"ns2:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterface * SOAP_FMAC4 soap_get_ns2__IPv4NetworkInterface(struct soap *soap, struct ns2__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv6Configuration(struct soap *soap, struct ns2__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AcceptRouterAdvert = NULL;
	soap_default_ns2__IPv6DHCPConfiguration(soap, &a->DHCP);
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->__sizeLinkLocal = 0;
	a->LinkLocal = NULL;
	a->__sizeFromDHCP = 0;
	a->FromDHCP = NULL;
	a->__sizeFromRA = 0;
	a->FromRA = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv6Configuration(struct soap *soap, const struct ns2__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->AcceptRouterAdvert);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_ns2__IPv6DHCPConfiguration);
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_ns2__PrefixedIPv6Address);
			soap_serialize_ns2__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	if (a->LinkLocal)
	{	int i;
		for (i = 0; i < a->__sizeLinkLocal; i++)
		{
			soap_embedded(soap, a->LinkLocal + i, SOAP_TYPE_ns2__PrefixedIPv6Address);
			soap_serialize_ns2__PrefixedIPv6Address(soap, a->LinkLocal + i);
		}
	}
	if (a->FromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeFromDHCP; i++)
		{
			soap_embedded(soap, a->FromDHCP + i, SOAP_TYPE_ns2__PrefixedIPv6Address);
			soap_serialize_ns2__PrefixedIPv6Address(soap, a->FromDHCP + i);
		}
	}
	if (a->FromRA)
	{	int i;
		for (i = 0; i < a->__sizeFromRA; i++)
		{
			soap_embedded(soap, a->FromRA + i, SOAP_TYPE_ns2__PrefixedIPv6Address);
			soap_serialize_ns2__PrefixedIPv6Address(soap, a->FromRA + i);
		}
	}
	soap_serialize_PointerTons2__IPv6ConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv6Configuration(struct soap *soap, const char *tag, int id, const struct ns2__IPv6Configuration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_ns2__IPv6DHCPConfiguration(soap, "ns2:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_ns2__PrefixedIPv6Address(soap, "ns2:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (a->LinkLocal)
	{	int i;
		for (i = 0; i < a->__sizeLinkLocal; i++)
			if (soap_out_ns2__PrefixedIPv6Address(soap, "ns2:LinkLocal", -1, a->LinkLocal + i, ""))
				return soap->error;
	}
	if (a->FromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeFromDHCP; i++)
			if (soap_out_ns2__PrefixedIPv6Address(soap, "ns2:FromDHCP", -1, a->FromDHCP + i, ""))
				return soap->error;
	}
	if (a->FromRA)
	{	int i;
		for (i = 0; i < a->__sizeFromRA; i++)
			if (soap_out_ns2__PrefixedIPv6Address(soap, "ns2:FromRA", -1, a->FromRA + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__IPv6ConfigurationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv6Configuration * SOAP_FMAC4 soap_in_ns2__IPv6Configuration(struct soap *soap, const char *tag, struct ns2__IPv6Configuration *a, const char *type)
{
	size_t soap_flag_AcceptRouterAdvert = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	struct soap_blist *soap_blist_LinkLocal = NULL;
	struct soap_blist *soap_blist_FromDHCP = NULL;
	struct soap_blist *soap_blist_FromRA = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv6Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv6Configuration, sizeof(struct ns2__IPv6Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv6Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert--;
					continue;
				}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__IPv6DHCPConfiguration(soap, "ns2:DHCP", &a->DHCP, "ns2:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct ns2__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct ns2__PrefixedIPv6Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv6Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv6Address(soap, "ns2:Manual", a->Manual, "ns2:PrefixedIPv6Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:LinkLocal", 1, NULL))
			{	if (a->LinkLocal == NULL)
				{	if (soap_blist_LinkLocal == NULL)
						soap_blist_LinkLocal = soap_new_block(soap);
					a->LinkLocal = (struct ns2__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_LinkLocal, sizeof(struct ns2__PrefixedIPv6Address));
					if (a->LinkLocal == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv6Address(soap, a->LinkLocal);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv6Address(soap, "ns2:LinkLocal", a->LinkLocal, "ns2:PrefixedIPv6Address"))
				{	a->__sizeLinkLocal++;
					a->LinkLocal = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:FromDHCP", 1, NULL))
			{	if (a->FromDHCP == NULL)
				{	if (soap_blist_FromDHCP == NULL)
						soap_blist_FromDHCP = soap_new_block(soap);
					a->FromDHCP = (struct ns2__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_FromDHCP, sizeof(struct ns2__PrefixedIPv6Address));
					if (a->FromDHCP == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv6Address(soap, a->FromDHCP);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv6Address(soap, "ns2:FromDHCP", a->FromDHCP, "ns2:PrefixedIPv6Address"))
				{	a->__sizeFromDHCP++;
					a->FromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:FromRA", 1, NULL))
			{	if (a->FromRA == NULL)
				{	if (soap_blist_FromRA == NULL)
						soap_blist_FromRA = soap_new_block(soap);
					a->FromRA = (struct ns2__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_FromRA, sizeof(struct ns2__PrefixedIPv6Address));
					if (a->FromRA == NULL)
						return NULL;
					soap_default_ns2__PrefixedIPv6Address(soap, a->FromRA);
				}
				soap_revert(soap);
				if (soap_in_ns2__PrefixedIPv6Address(soap, "ns2:FromRA", a->FromRA, "ns2:PrefixedIPv6Address"))
				{	a->__sizeFromRA++;
					a->FromRA = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6ConfigurationExtension(soap, "ns2:Extension", &a->Extension, "ns2:IPv6ConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct ns2__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (a->LinkLocal)
			soap_pop_block(soap, soap_blist_LinkLocal);
		if (a->__sizeLinkLocal)
			a->LinkLocal = (struct ns2__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_LinkLocal, NULL, 1);
		else
		{	a->LinkLocal = NULL;
			if (soap_blist_LinkLocal)
				soap_end_block(soap, soap_blist_LinkLocal);
		}
		if (a->FromDHCP)
			soap_pop_block(soap, soap_blist_FromDHCP);
		if (a->__sizeFromDHCP)
			a->FromDHCP = (struct ns2__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromDHCP, NULL, 1);
		else
		{	a->FromDHCP = NULL;
			if (soap_blist_FromDHCP)
				soap_end_block(soap, soap_blist_FromDHCP);
		}
		if (a->FromRA)
			soap_pop_block(soap, soap_blist_FromRA);
		if (a->__sizeFromRA)
			a->FromRA = (struct ns2__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromRA, NULL, 1);
		else
		{	a->FromRA = NULL;
			if (soap_blist_FromRA)
				soap_end_block(soap, soap_blist_FromRA);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv6Configuration, 0, sizeof(struct ns2__IPv6Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv6Configuration(struct soap *soap, const struct ns2__IPv6Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv6Configuration);
	if (soap_out_ns2__IPv6Configuration(soap, tag?tag:"ns2:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6Configuration * SOAP_FMAC4 soap_get_ns2__IPv6Configuration(struct soap *soap, struct ns2__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv6NetworkInterface(struct soap *soap, struct ns2__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv6NetworkInterface(struct soap *soap, const struct ns2__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTons2__IPv6Configuration(soap, &a->Config);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const struct ns2__IPv6NetworkInterface *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv6Configuration(soap, "ns2:Config", -1, &a->Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterface * SOAP_FMAC4 soap_in_ns2__IPv6NetworkInterface(struct soap *soap, const char *tag, struct ns2__IPv6NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPv6NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPv6NetworkInterface, sizeof(struct ns2__IPv6NetworkInterface), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPv6NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6Configuration(soap, "ns2:Config", &a->Config, "ns2:IPv6Configuration"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPv6NetworkInterface, 0, sizeof(struct ns2__IPv6NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv6NetworkInterface(struct soap *soap, const struct ns2__IPv6NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv6NetworkInterface);
	if (soap_out_ns2__IPv6NetworkInterface(soap, tag?tag:"ns2:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterface * SOAP_FMAC4 soap_get_ns2__IPv6NetworkInterface(struct soap *soap, struct ns2__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterfaceInfo(struct soap *soap, struct ns2__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_ns2__HwAddress(soap, &a->HwAddress);
	a->MTU = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterfaceInfo(struct soap *soap, const struct ns2__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Name);
	soap_serialize_ns2__HwAddress(soap, &a->HwAddress);
	soap_serialize_PointerToint(soap, &a->MTU);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterfaceInfo *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:Name", -1, &a->Name, ""))
		return soap->error;
	if (a->HwAddress)
	{	if (soap_out_ns2__HwAddress(soap, "ns2:HwAddress", -1, &a->HwAddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HwAddress"))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:MTU", -1, &a->MTU, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_ns2__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_HwAddress = 1;
	size_t soap_flag_MTU = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterfaceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterfaceInfo, sizeof(struct ns2__NetworkInterfaceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterfaceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_HwAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__HwAddress(soap, "ns2:HwAddress", &a->HwAddress, "ns2:HwAddress"))
				{	soap_flag_HwAddress--;
					continue;
				}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterfaceInfo, 0, sizeof(struct ns2__NetworkInterfaceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterfaceInfo(struct soap *soap, const struct ns2__NetworkInterfaceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterfaceInfo);
	if (soap_out_ns2__NetworkInterfaceInfo(soap, tag?tag:"ns2:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_ns2__NetworkInterfaceInfo(struct soap *soap, struct ns2__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterfaceConnectionSetting(struct soap *soap, struct ns2__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->AutoNegotiation);
	soap_default_int(soap, &a->Speed);
	soap_default_ns2__Duplex(soap, &a->Duplex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterfaceConnectionSetting(struct soap *soap, const struct ns2__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoNegotiation, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->Speed, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterfaceConnectionSetting *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:AutoNegotiation", -1, &a->AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_ns2__Duplex(soap, "ns2:Duplex", -1, &a->Duplex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_ns2__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceConnectionSetting *a, const char *type)
{
	size_t soap_flag_AutoNegotiation = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_Duplex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterfaceConnectionSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting, sizeof(struct ns2__NetworkInterfaceConnectionSetting), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterfaceConnectionSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:AutoNegotiation", &a->AutoNegotiation, "xsd:boolean"))
				{	soap_flag_AutoNegotiation--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Speed", &a->Speed, "xsd:int"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap_flag_Duplex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__Duplex(soap, "ns2:Duplex", &a->Duplex, "ns2:Duplex"))
				{	soap_flag_Duplex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting, 0, sizeof(struct ns2__NetworkInterfaceConnectionSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation > 0 || soap_flag_Speed > 0 || soap_flag_Duplex > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterfaceConnectionSetting(struct soap *soap, const struct ns2__NetworkInterfaceConnectionSetting *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting);
	if (soap_out_ns2__NetworkInterfaceConnectionSetting(soap, tag?tag:"ns2:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_ns2__NetworkInterfaceConnectionSetting(struct soap *soap, struct ns2__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterfaceLink(struct soap *soap, struct ns2__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AdminSettings = NULL;
	a->OperSettings = NULL;
	soap_default_ns2__IANA_IfTypes(soap, &a->InterfaceType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterfaceLink(struct soap *soap, const struct ns2__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__NetworkInterfaceConnectionSetting(soap, &a->AdminSettings);
	soap_serialize_PointerTons2__NetworkInterfaceConnectionSetting(soap, &a->OperSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterfaceLink *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterfaceLink), type))
		return soap->error;
	if (a->AdminSettings)
	{	if (soap_out_PointerTons2__NetworkInterfaceConnectionSetting(soap, "ns2:AdminSettings", -1, &a->AdminSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:AdminSettings"))
		return soap->error;
	if (a->OperSettings)
	{	if (soap_out_PointerTons2__NetworkInterfaceConnectionSetting(soap, "ns2:OperSettings", -1, &a->OperSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:OperSettings"))
		return soap->error;
	if (soap_out_ns2__IANA_IfTypes(soap, "ns2:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceLink * SOAP_FMAC4 soap_in_ns2__NetworkInterfaceLink(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceLink *a, const char *type)
{
	size_t soap_flag_AdminSettings = 1;
	size_t soap_flag_OperSettings = 1;
	size_t soap_flag_InterfaceType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterfaceLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterfaceLink, sizeof(struct ns2__NetworkInterfaceLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterfaceLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceConnectionSetting(soap, "ns2:AdminSettings", &a->AdminSettings, "ns2:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings--;
					continue;
				}
			if (soap_flag_OperSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NetworkInterfaceConnectionSetting(soap, "ns2:OperSettings", &a->OperSettings, "ns2:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings--;
					continue;
				}
			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__IANA_IfTypes(soap, "ns2:InterfaceType", &a->InterfaceType, "ns2:IANA-IfTypes"))
				{	soap_flag_InterfaceType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterfaceLink, 0, sizeof(struct ns2__NetworkInterfaceLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AdminSettings > 0 || soap_flag_OperSettings > 0 || soap_flag_InterfaceType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterfaceLink(struct soap *soap, const struct ns2__NetworkInterfaceLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterfaceLink);
	if (soap_out_ns2__NetworkInterfaceLink(soap, tag?tag:"ns2:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceLink * SOAP_FMAC4 soap_get_ns2__NetworkInterfaceLink(struct soap *soap, struct ns2__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__NetworkInterfaceExtension(struct soap *soap, struct ns2__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__NetworkInterfaceExtension(struct soap *soap, const struct ns2__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const struct ns2__NetworkInterfaceExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NetworkInterfaceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_ns2__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__NetworkInterfaceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NetworkInterfaceExtension, sizeof(struct ns2__NetworkInterfaceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__NetworkInterfaceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NetworkInterfaceExtension, 0, sizeof(struct ns2__NetworkInterfaceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__NetworkInterfaceExtension(struct soap *soap, const struct ns2__NetworkInterfaceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__NetworkInterfaceExtension);
	if (soap_out_ns2__NetworkInterfaceExtension(soap, tag?tag:"ns2:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_ns2__NetworkInterfaceExtension(struct soap *soap, struct ns2__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Scope(struct soap *soap, struct ns2__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ScopeDefinition(soap, &a->ScopeDef);
	soap_default_xsd__anyURI(soap, &a->ScopeItem);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Scope(struct soap *soap, const struct ns2__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->ScopeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Scope(struct soap *soap, const char *tag, int id, const struct ns2__Scope *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Scope), type))
		return soap->error;
	if (soap_out_ns2__ScopeDefinition(soap, "ns2:ScopeDef", -1, &a->ScopeDef, ""))
		return soap->error;
	if (a->ScopeItem)
	{	if (soap_out_xsd__anyURI(soap, "ns2:ScopeItem", -1, &a->ScopeItem, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:ScopeItem"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Scope * SOAP_FMAC4 soap_in_ns2__Scope(struct soap *soap, const char *tag, struct ns2__Scope *a, const char *type)
{
	size_t soap_flag_ScopeDef = 1;
	size_t soap_flag_ScopeItem = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Scope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Scope, sizeof(struct ns2__Scope), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Scope(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ScopeDefinition(soap, "ns2:ScopeDef", &a->ScopeDef, "ns2:ScopeDefinition"))
				{	soap_flag_ScopeDef--;
					continue;
				}
			if (soap_flag_ScopeItem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:ScopeItem", &a->ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Scope, 0, sizeof(struct ns2__Scope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef > 0 || soap_flag_ScopeItem > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Scope(struct soap *soap, const struct ns2__Scope *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Scope);
	if (soap_out_ns2__Scope(soap, tag?tag:"ns2:Scope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Scope * SOAP_FMAC4 soap_get_ns2__Scope(struct soap *soap, struct ns2__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Transport(struct soap *soap, struct ns2__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__TransportProtocol(soap, &a->Protocol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Transport(struct soap *soap, const struct ns2__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Transport(struct soap *soap, const char *tag, int id, const struct ns2__Transport *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Transport), type))
		return soap->error;
	if (soap_out_ns2__TransportProtocol(soap, "ns2:Protocol", -1, &a->Protocol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Transport * SOAP_FMAC4 soap_in_ns2__Transport(struct soap *soap, const char *tag, struct ns2__Transport *a, const char *type)
{
	size_t soap_flag_Protocol = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Transport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Transport, sizeof(struct ns2__Transport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Transport(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__TransportProtocol(soap, "ns2:Protocol", &a->Protocol, "ns2:TransportProtocol"))
				{	soap_flag_Protocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Transport, 0, sizeof(struct ns2__Transport), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Transport(struct soap *soap, const struct ns2__Transport *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Transport);
	if (soap_out_ns2__Transport(soap, tag?tag:"ns2:Transport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Transport * SOAP_FMAC4 soap_get_ns2__Transport(struct soap *soap, struct ns2__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPAddress(struct soap *soap, struct ns2__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__IPType(soap, &a->Type);
	a->IPv4Address = NULL;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPAddress(struct soap *soap, const struct ns2__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IPv4Address(soap, &a->IPv4Address);
	soap_serialize_PointerTons2__IPv6Address(soap, &a->IPv6Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPAddress(struct soap *soap, const char *tag, int id, const struct ns2__IPAddress *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IPAddress), type))
		return soap->error;
	if (soap_out_ns2__IPType(soap, "ns2:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv4Address(soap, "ns2:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTons2__IPv6Address(soap, "ns2:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IPAddress * SOAP_FMAC4 soap_in_ns2__IPAddress(struct soap *soap, const char *tag, struct ns2__IPAddress *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IPAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IPAddress, sizeof(struct ns2__IPAddress), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IPAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__IPType(soap, "ns2:Type", &a->Type, "ns2:IPType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv4Address(soap, "ns2:IPv4Address", &a->IPv4Address, "ns2:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPv6Address(soap, "ns2:IPv6Address", &a->IPv6Address, "ns2:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IPAddress, 0, sizeof(struct ns2__IPAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPAddress(struct soap *soap, const struct ns2__IPAddress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPAddress);
	if (soap_out_ns2__IPAddress(soap, tag?tag:"ns2:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPAddress * SOAP_FMAC4 soap_get_ns2__IPAddress(struct soap *soap, struct ns2__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MulticastConfiguration(struct soap *soap, struct ns2__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	soap_default_int(soap, &a->Port);
	soap_default_int(soap, &a->TTL);
	soap_default_xsd__boolean(soap, &a->AutoStart);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MulticastConfiguration(struct soap *soap, const struct ns2__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IPAddress(soap, &a->Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
	soap_embedded(soap, &a->TTL, SOAP_TYPE_int);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MulticastConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__MulticastConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MulticastConfiguration), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_PointerTons2__IPAddress(soap, "ns2:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Address"))
		return soap->error;
	if (soap_out_int(soap, "ns2:Port", -1, &a->Port, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MulticastConfiguration * SOAP_FMAC4 soap_in_ns2__MulticastConfiguration(struct soap *soap, const char *tag, struct ns2__MulticastConfiguration *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_Port = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_AutoStart = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MulticastConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MulticastConfiguration, sizeof(struct ns2__MulticastConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MulticastConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IPAddress(soap, "ns2:Address", &a->Address, "ns2:IPAddress"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Port", &a->Port, "xsd:int"))
				{	soap_flag_Port--;
					continue;
				}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:TTL", &a->TTL, "xsd:int"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MulticastConfiguration, 0, sizeof(struct ns2__MulticastConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_Port > 0 || soap_flag_TTL > 0 || soap_flag_AutoStart > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MulticastConfiguration(struct soap *soap, const struct ns2__MulticastConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MulticastConfiguration);
	if (soap_out_ns2__MulticastConfiguration(soap, tag?tag:"ns2:MulticastConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MulticastConfiguration * SOAP_FMAC4 soap_get_ns2__MulticastConfiguration(struct soap *soap, struct ns2__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZStatusFilterOptions(struct soap *soap, struct ns2__PTZStatusFilterOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->PanTiltStatusSupported);
	soap_default_xsd__boolean(soap, &a->ZoomStatusSupported);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZStatusFilterOptions(struct soap *soap, const struct ns2__PTZStatusFilterOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PanTiltStatusSupported, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->ZoomStatusSupported, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, const struct ns2__PTZStatusFilterOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZStatusFilterOptions), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:PanTiltStatusSupported", -1, &a->PanTiltStatusSupported, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:ZoomStatusSupported", -1, &a->ZoomStatusSupported, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZStatusFilterOptions * SOAP_FMAC4 soap_in_ns2__PTZStatusFilterOptions(struct soap *soap, const char *tag, struct ns2__PTZStatusFilterOptions *a, const char *type)
{
	size_t soap_flag_PanTiltStatusSupported = 1;
	size_t soap_flag_ZoomStatusSupported = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZStatusFilterOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZStatusFilterOptions, sizeof(struct ns2__PTZStatusFilterOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZStatusFilterOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTiltStatusSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:PanTiltStatusSupported", &a->PanTiltStatusSupported, "xsd:boolean"))
				{	soap_flag_PanTiltStatusSupported--;
					continue;
				}
			if (soap_flag_ZoomStatusSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:ZoomStatusSupported", &a->ZoomStatusSupported, "xsd:boolean"))
				{	soap_flag_ZoomStatusSupported--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZStatusFilterOptions, 0, sizeof(struct ns2__PTZStatusFilterOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PanTiltStatusSupported > 0 || soap_flag_ZoomStatusSupported > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZStatusFilterOptions(struct soap *soap, const struct ns2__PTZStatusFilterOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZStatusFilterOptions);
	if (soap_out_ns2__PTZStatusFilterOptions(soap, tag?tag:"ns2:PTZStatusFilterOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStatusFilterOptions * SOAP_FMAC4 soap_get_ns2__PTZStatusFilterOptions(struct soap *soap, struct ns2__PTZStatusFilterOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MetadataConfigurationOptions(struct soap *soap, struct ns2__MetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatusFilterOptions = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MetadataConfigurationOptions(struct soap *soap, const struct ns2__MetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PTZStatusFilterOptions(soap, &a->PTZStatusFilterOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns2__MetadataConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MetadataConfigurationOptions), type))
		return soap->error;
	if (a->PTZStatusFilterOptions)
	{	if (soap_out_PointerTons2__PTZStatusFilterOptions(soap, "ns2:PTZStatusFilterOptions", -1, &a->PTZStatusFilterOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:PTZStatusFilterOptions"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MetadataConfigurationOptions * SOAP_FMAC4 soap_in_ns2__MetadataConfigurationOptions(struct soap *soap, const char *tag, struct ns2__MetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_PTZStatusFilterOptions = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MetadataConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MetadataConfigurationOptions, sizeof(struct ns2__MetadataConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MetadataConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatusFilterOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZStatusFilterOptions(soap, "ns2:PTZStatusFilterOptions", &a->PTZStatusFilterOptions, "ns2:PTZStatusFilterOptions"))
				{	soap_flag_PTZStatusFilterOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MetadataConfigurationOptions, 0, sizeof(struct ns2__MetadataConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZStatusFilterOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MetadataConfigurationOptions(struct soap *soap, const struct ns2__MetadataConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MetadataConfigurationOptions);
	if (soap_out_ns2__MetadataConfigurationOptions(soap, tag?tag:"ns2:MetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataConfigurationOptions * SOAP_FMAC4 soap_get_ns2__MetadataConfigurationOptions(struct soap *soap, struct ns2__MetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _ns2__EventSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, const struct _ns2__EventSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _ns2__EventSubscription_SubscriptionPolicy *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _ns2__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__EventSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy, sizeof(struct _ns2__EventSubscription_SubscriptionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__EventSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__EventSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy, 0, sizeof(struct _ns2__EventSubscription_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, const struct _ns2__EventSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy);
	if (soap_out__ns2__EventSubscription_SubscriptionPolicy(soap, tag?tag:"ns2:EventSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _ns2__EventSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FilterType(struct soap *soap, struct ns2__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FilterType(struct soap *soap, const struct ns2__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FilterType(struct soap *soap, const char *tag, int id, const struct ns2__FilterType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FilterType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FilterType * SOAP_FMAC4 soap_in_ns2__FilterType(struct soap *soap, const char *tag, struct ns2__FilterType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FilterType, sizeof(struct ns2__FilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FilterType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FilterType, 0, sizeof(struct ns2__FilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FilterType(struct soap *soap, const struct ns2__FilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FilterType);
	if (soap_out_ns2__FilterType(soap, tag?tag:"ns2:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FilterType * SOAP_FMAC4 soap_get_ns2__FilterType(struct soap *soap, struct ns2__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EventSubscription(struct soap *soap, struct ns2__EventSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__EventSubscription(struct soap *soap, const struct ns2__EventSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FilterType(soap, &a->Filter);
	soap_serialize_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventSubscription(struct soap *soap, const char *tag, int id, const struct ns2__EventSubscription *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventSubscription), type))
		return soap->error;
	if (soap_out_PointerTons2__FilterType(soap, "ns2:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, "ns2:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__EventSubscription * SOAP_FMAC4 soap_in_ns2__EventSubscription(struct soap *soap, const char *tag, struct ns2__EventSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__EventSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventSubscription, sizeof(struct ns2__EventSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__EventSubscription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FilterType(soap, "ns2:Filter", &a->Filter, "ns2:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, "ns2:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventSubscription, 0, sizeof(struct ns2__EventSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EventSubscription(struct soap *soap, const struct ns2__EventSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EventSubscription);
	if (soap_out_ns2__EventSubscription(soap, tag?tag:"ns2:EventSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventSubscription * SOAP_FMAC4 soap_get_ns2__EventSubscription(struct soap *soap, struct ns2__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZFilter(struct soap *soap, struct ns2__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Status);
	soap_default_xsd__boolean(soap, &a->Position);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZFilter(struct soap *soap, const struct ns2__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->Position, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZFilter(struct soap *soap, const char *tag, int id, const struct ns2__PTZFilter *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZFilter), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:Position", -1, &a->Position, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZFilter * SOAP_FMAC4 soap_in_ns2__PTZFilter(struct soap *soap, const char *tag, struct ns2__PTZFilter *a, const char *type)
{
	size_t soap_flag_Status = 1;
	size_t soap_flag_Position = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZFilter, sizeof(struct ns2__PTZFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:Position", &a->Position, "xsd:boolean"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZFilter, 0, sizeof(struct ns2__PTZFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZFilter(struct soap *soap, const struct ns2__PTZFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZFilter);
	if (soap_out_ns2__PTZFilter(soap, tag?tag:"ns2:PTZFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZFilter * SOAP_FMAC4 soap_get_ns2__PTZFilter(struct soap *soap, struct ns2__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioEncoderConfigurationOption(struct soap *soap, struct ns2__AudioEncoderConfigurationOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__AudioEncoding(soap, &a->Encoding);
	a->BitrateList = NULL;
	a->SampleRateList = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioEncoderConfigurationOption(struct soap *soap, const struct ns2__AudioEncoderConfigurationOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IntList(soap, &a->BitrateList);
	soap_serialize_PointerTons2__IntList(soap, &a->SampleRateList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const struct ns2__AudioEncoderConfigurationOption *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioEncoderConfigurationOption), type))
		return soap->error;
	if (soap_out_ns2__AudioEncoding(soap, "ns2:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (a->BitrateList)
	{	if (soap_out_PointerTons2__IntList(soap, "ns2:BitrateList", -1, &a->BitrateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:BitrateList"))
		return soap->error;
	if (a->SampleRateList)
	{	if (soap_out_PointerTons2__IntList(soap, "ns2:SampleRateList", -1, &a->SampleRateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:SampleRateList"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_ns2__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, struct ns2__AudioEncoderConfigurationOption *a, const char *type)
{
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_BitrateList = 1;
	size_t soap_flag_SampleRateList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioEncoderConfigurationOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioEncoderConfigurationOption, sizeof(struct ns2__AudioEncoderConfigurationOption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioEncoderConfigurationOption(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AudioEncoding(soap, "ns2:Encoding", &a->Encoding, "ns2:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_BitrateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntList(soap, "ns2:BitrateList", &a->BitrateList, "ns2:IntList"))
				{	soap_flag_BitrateList--;
					continue;
				}
			if (soap_flag_SampleRateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntList(soap, "ns2:SampleRateList", &a->SampleRateList, "ns2:IntList"))
				{	soap_flag_SampleRateList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioEncoderConfigurationOption, 0, sizeof(struct ns2__AudioEncoderConfigurationOption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_BitrateList > 0 || soap_flag_SampleRateList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioEncoderConfigurationOption(struct soap *soap, const struct ns2__AudioEncoderConfigurationOption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioEncoderConfigurationOption);
	if (soap_out_ns2__AudioEncoderConfigurationOption(soap, tag?tag:"ns2:AudioEncoderConfigurationOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_ns2__AudioEncoderConfigurationOption(struct soap *soap, struct ns2__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioEncoderConfigurationOptions(struct soap *soap, struct ns2__AudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioEncoderConfigurationOptions(struct soap *soap, const struct ns2__AudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Options)
	{	int i;
		for (i = 0; i < a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_ns2__AudioEncoderConfigurationOption);
			soap_serialize_ns2__AudioEncoderConfigurationOption(soap, a->Options + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns2__AudioEncoderConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioEncoderConfigurationOptions), type))
		return soap->error;
	if (a->Options)
	{	int i;
		for (i = 0; i < a->__sizeOptions; i++)
			if (soap_out_ns2__AudioEncoderConfigurationOption(soap, "ns2:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_ns2__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct ns2__AudioEncoderConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioEncoderConfigurationOptions, sizeof(struct ns2__AudioEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioEncoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_new_block(soap);
					a->Options = (struct ns2__AudioEncoderConfigurationOption *)soap_push_block(soap, soap_blist_Options, sizeof(struct ns2__AudioEncoderConfigurationOption));
					if (a->Options == NULL)
						return NULL;
					soap_default_ns2__AudioEncoderConfigurationOption(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_ns2__AudioEncoderConfigurationOption(soap, "ns2:Options", a->Options, "ns2:AudioEncoderConfigurationOption"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
			a->Options = (struct ns2__AudioEncoderConfigurationOption *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioEncoderConfigurationOptions, 0, sizeof(struct ns2__AudioEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioEncoderConfigurationOptions(struct soap *soap, const struct ns2__AudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioEncoderConfigurationOptions);
	if (soap_out_ns2__AudioEncoderConfigurationOptions(soap, tag?tag:"ns2:AudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_ns2__AudioEncoderConfigurationOptions(struct soap *soap, struct ns2__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioSourceOptionsExtension(struct soap *soap, struct ns2__AudioSourceOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioSourceOptionsExtension(struct soap *soap, const struct ns2__AudioSourceOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const struct ns2__AudioSourceOptionsExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioSourceOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_ns2__AudioSourceOptionsExtension(struct soap *soap, const char *tag, struct ns2__AudioSourceOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioSourceOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioSourceOptionsExtension, sizeof(struct ns2__AudioSourceOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioSourceOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioSourceOptionsExtension, 0, sizeof(struct ns2__AudioSourceOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioSourceOptionsExtension(struct soap *soap, const struct ns2__AudioSourceOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioSourceOptionsExtension);
	if (soap_out_ns2__AudioSourceOptionsExtension(soap, tag?tag:"ns2:AudioSourceOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_ns2__AudioSourceOptionsExtension(struct soap *soap, struct ns2__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioSourceConfigurationOptions(struct soap *soap, struct ns2__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInputTokensAvailable = 0;
	a->InputTokensAvailable = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioSourceConfigurationOptions(struct soap *soap, const struct ns2__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeInputTokensAvailable; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, a->InputTokensAvailable + i);
		}
	}
	soap_serialize_PointerTons2__AudioSourceOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns2__AudioSourceConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioSourceConfigurationOptions), type))
		return soap->error;
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeInputTokensAvailable; i++)
			if (soap_out_ns2__ReferenceToken(soap, "ns2:InputTokensAvailable", -1, a->InputTokensAvailable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__AudioSourceOptionsExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_ns2__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct ns2__AudioSourceConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_InputTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioSourceConfigurationOptions, sizeof(struct ns2__AudioSourceConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioSourceConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:InputTokensAvailable", 1, NULL))
			{	if (a->InputTokensAvailable == NULL)
				{	if (soap_blist_InputTokensAvailable == NULL)
						soap_blist_InputTokensAvailable = soap_new_block(soap);
					a->InputTokensAvailable = (char **)soap_push_block(soap, soap_blist_InputTokensAvailable, sizeof(char *));
					if (a->InputTokensAvailable == NULL)
						return NULL;
					*a->InputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns2:InputTokensAvailable", a->InputTokensAvailable, "ns2:ReferenceToken"))
				{	a->__sizeInputTokensAvailable++;
					a->InputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AudioSourceOptionsExtension(soap, "ns2:Extension", &a->Extension, "ns2:AudioSourceOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputTokensAvailable)
			soap_pop_block(soap, soap_blist_InputTokensAvailable);
		if (a->__sizeInputTokensAvailable)
			a->InputTokensAvailable = (char **)soap_save_block(soap, soap_blist_InputTokensAvailable, NULL, 1);
		else
		{	a->InputTokensAvailable = NULL;
			if (soap_blist_InputTokensAvailable)
				soap_end_block(soap, soap_blist_InputTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioSourceConfigurationOptions, 0, sizeof(struct ns2__AudioSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeInputTokensAvailable < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioSourceConfigurationOptions(struct soap *soap, const struct ns2__AudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioSourceConfigurationOptions);
	if (soap_out_ns2__AudioSourceConfigurationOptions(soap, tag?tag:"ns2:AudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_ns2__AudioSourceConfigurationOptions(struct soap *soap, struct ns2__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoEncoderOptionsExtension(struct soap *soap, struct ns2__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoEncoderOptionsExtension(struct soap *soap, const struct ns2__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const struct ns2__VideoEncoderOptionsExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoEncoderOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_ns2__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct ns2__VideoEncoderOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoEncoderOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoEncoderOptionsExtension, sizeof(struct ns2__VideoEncoderOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoEncoderOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoEncoderOptionsExtension, 0, sizeof(struct ns2__VideoEncoderOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoEncoderOptionsExtension(struct soap *soap, const struct ns2__VideoEncoderOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoEncoderOptionsExtension);
	if (soap_out_ns2__VideoEncoderOptionsExtension(soap, tag?tag:"ns2:VideoEncoderOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_ns2__VideoEncoderOptionsExtension(struct soap *soap, struct ns2__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__H264Options(struct soap *soap, struct ns2__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__H264Options(struct soap *soap, const struct ns2__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_ns2__VideoResolution);
			soap_serialize_ns2__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTons2__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_ns2__H264Profile);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__H264Options(struct soap *soap, const char *tag, int id, const struct ns2__H264Options *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__H264Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_ns2__VideoResolution(soap, "ns2:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->GovLengthRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:GovLengthRange", -1, &a->GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:GovLengthRange"))
		return soap->error;
	if (a->FrameRateRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:EncodingIntervalRange"))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
			if (soap_out_ns2__H264Profile(soap, "ns2:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__H264Options * SOAP_FMAC4 soap_in_ns2__H264Options(struct soap *soap, const char *tag, struct ns2__H264Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__H264Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__H264Options, sizeof(struct ns2__H264Options), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__H264Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct ns2__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct ns2__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_ns2__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_ns2__VideoResolution(soap, "ns2:ResolutionsAvailable", a->ResolutionsAvailable, "ns2:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:GovLengthRange", &a->GovLengthRange, "ns2:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:FrameRateRange", &a->FrameRateRange, "ns2:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:EncodingIntervalRange", &a->EncodingIntervalRange, "ns2:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_new_block(soap);
					a->H264ProfilesSupported = (enum ns2__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported, sizeof(enum ns2__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_ns2__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_ns2__H264Profile(soap, "ns2:H264ProfilesSupported", a->H264ProfilesSupported, "ns2:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct ns2__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
			a->H264ProfilesSupported = (enum ns2__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__H264Options, 0, sizeof(struct ns2__H264Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__H264Options(struct soap *soap, const struct ns2__H264Options *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__H264Options);
	if (soap_out_ns2__H264Options(soap, tag?tag:"ns2:H264Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__H264Options * SOAP_FMAC4 soap_get_ns2__H264Options(struct soap *soap, struct ns2__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Mpeg4Options(struct soap *soap, struct ns2__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Mpeg4Options(struct soap *soap, const struct ns2__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_ns2__VideoResolution);
			soap_serialize_ns2__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTons2__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_ns2__Mpeg4Profile);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Mpeg4Options(struct soap *soap, const char *tag, int id, const struct ns2__Mpeg4Options *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Mpeg4Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_ns2__VideoResolution(soap, "ns2:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->GovLengthRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:GovLengthRange", -1, &a->GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:GovLengthRange"))
		return soap->error;
	if (a->FrameRateRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:EncodingIntervalRange"))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_ns2__Mpeg4Profile(soap, "ns2:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Mpeg4Options * SOAP_FMAC4 soap_in_ns2__Mpeg4Options(struct soap *soap, const char *tag, struct ns2__Mpeg4Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Mpeg4Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Mpeg4Options, sizeof(struct ns2__Mpeg4Options), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Mpeg4Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct ns2__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct ns2__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_ns2__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_ns2__VideoResolution(soap, "ns2:ResolutionsAvailable", a->ResolutionsAvailable, "ns2:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:GovLengthRange", &a->GovLengthRange, "ns2:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:FrameRateRange", &a->FrameRateRange, "ns2:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:EncodingIntervalRange", &a->EncodingIntervalRange, "ns2:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_new_block(soap);
					a->Mpeg4ProfilesSupported = (enum ns2__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum ns2__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_ns2__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_ns2__Mpeg4Profile(soap, "ns2:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "ns2:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct ns2__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
			a->Mpeg4ProfilesSupported = (enum ns2__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Mpeg4Options, 0, sizeof(struct ns2__Mpeg4Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Mpeg4Options(struct soap *soap, const struct ns2__Mpeg4Options *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Mpeg4Options);
	if (soap_out_ns2__Mpeg4Options(soap, tag?tag:"ns2:Mpeg4Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Mpeg4Options * SOAP_FMAC4 soap_get_ns2__Mpeg4Options(struct soap *soap, struct ns2__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__JpegOptions(struct soap *soap, struct ns2__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__JpegOptions(struct soap *soap, const struct ns2__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_ns2__VideoResolution);
			soap_serialize_ns2__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTons2__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->EncodingIntervalRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__JpegOptions(struct soap *soap, const char *tag, int id, const struct ns2__JpegOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__JpegOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_ns2__VideoResolution(soap, "ns2:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->FrameRateRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:EncodingIntervalRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__JpegOptions * SOAP_FMAC4 soap_in_ns2__JpegOptions(struct soap *soap, const char *tag, struct ns2__JpegOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__JpegOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__JpegOptions, sizeof(struct ns2__JpegOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__JpegOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct ns2__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct ns2__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_ns2__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_ns2__VideoResolution(soap, "ns2:ResolutionsAvailable", a->ResolutionsAvailable, "ns2:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:FrameRateRange", &a->FrameRateRange, "ns2:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:EncodingIntervalRange", &a->EncodingIntervalRange, "ns2:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct ns2__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__JpegOptions, 0, sizeof(struct ns2__JpegOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__JpegOptions(struct soap *soap, const struct ns2__JpegOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__JpegOptions);
	if (soap_out_ns2__JpegOptions(soap, tag?tag:"ns2:JpegOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__JpegOptions * SOAP_FMAC4 soap_get_ns2__JpegOptions(struct soap *soap, struct ns2__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__H264Configuration(struct soap *soap, struct ns2__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_ns2__H264Profile(soap, &a->H264Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__H264Configuration(struct soap *soap, const struct ns2__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->H264Profile, SOAP_TYPE_ns2__H264Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__H264Configuration(struct soap *soap, const char *tag, int id, const struct ns2__H264Configuration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__H264Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_ns2__H264Profile(soap, "ns2:H264Profile", -1, &a->H264Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__H264Configuration * SOAP_FMAC4 soap_in_ns2__H264Configuration(struct soap *soap, const char *tag, struct ns2__H264Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_H264Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__H264Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__H264Configuration, sizeof(struct ns2__H264Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__H264Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			if (soap_flag_H264Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__H264Profile(soap, "ns2:H264Profile", &a->H264Profile, "ns2:H264Profile"))
				{	soap_flag_H264Profile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__H264Configuration, 0, sizeof(struct ns2__H264Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_H264Profile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__H264Configuration(struct soap *soap, const struct ns2__H264Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__H264Configuration);
	if (soap_out_ns2__H264Configuration(soap, tag?tag:"ns2:H264Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__H264Configuration * SOAP_FMAC4 soap_get_ns2__H264Configuration(struct soap *soap, struct ns2__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Mpeg4Configuration(struct soap *soap, struct ns2__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_ns2__Mpeg4Profile(soap, &a->Mpeg4Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Mpeg4Configuration(struct soap *soap, const struct ns2__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->Mpeg4Profile, SOAP_TYPE_ns2__Mpeg4Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const struct ns2__Mpeg4Configuration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Mpeg4Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_ns2__Mpeg4Profile(soap, "ns2:Mpeg4Profile", -1, &a->Mpeg4Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Mpeg4Configuration * SOAP_FMAC4 soap_in_ns2__Mpeg4Configuration(struct soap *soap, const char *tag, struct ns2__Mpeg4Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_Mpeg4Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Mpeg4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Mpeg4Configuration, sizeof(struct ns2__Mpeg4Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Mpeg4Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			if (soap_flag_Mpeg4Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__Mpeg4Profile(soap, "ns2:Mpeg4Profile", &a->Mpeg4Profile, "ns2:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Mpeg4Configuration, 0, sizeof(struct ns2__Mpeg4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_Mpeg4Profile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Mpeg4Configuration(struct soap *soap, const struct ns2__Mpeg4Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Mpeg4Configuration);
	if (soap_out_ns2__Mpeg4Configuration(soap, tag?tag:"ns2:Mpeg4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Mpeg4Configuration * SOAP_FMAC4 soap_get_ns2__Mpeg4Configuration(struct soap *soap, struct ns2__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoRateControl(struct soap *soap, struct ns2__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->FrameRateLimit);
	soap_default_int(soap, &a->EncodingInterval);
	soap_default_int(soap, &a->BitrateLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoRateControl(struct soap *soap, const struct ns2__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &a->EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &a->BitrateLimit, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoRateControl(struct soap *soap, const char *tag, int id, const struct ns2__VideoRateControl *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoRateControl), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:FrameRateLimit", -1, &a->FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:EncodingInterval", -1, &a->EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:BitrateLimit", -1, &a->BitrateLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoRateControl * SOAP_FMAC4 soap_in_ns2__VideoRateControl(struct soap *soap, const char *tag, struct ns2__VideoRateControl *a, const char *type)
{
	size_t soap_flag_FrameRateLimit = 1;
	size_t soap_flag_EncodingInterval = 1;
	size_t soap_flag_BitrateLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoRateControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoRateControl, sizeof(struct ns2__VideoRateControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoRateControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:FrameRateLimit", &a->FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit--;
					continue;
				}
			if (soap_flag_EncodingInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:EncodingInterval", &a->EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval--;
					continue;
				}
			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:BitrateLimit", &a->BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoRateControl, 0, sizeof(struct ns2__VideoRateControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_EncodingInterval > 0 || soap_flag_BitrateLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoRateControl(struct soap *soap, const struct ns2__VideoRateControl *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoRateControl);
	if (soap_out_ns2__VideoRateControl(soap, tag?tag:"ns2:VideoRateControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoRateControl * SOAP_FMAC4 soap_get_ns2__VideoRateControl(struct soap *soap, struct ns2__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoResolution(struct soap *soap, struct ns2__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoResolution(struct soap *soap, const struct ns2__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoResolution(struct soap *soap, const char *tag, int id, const struct ns2__VideoResolution *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoResolution), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Height", -1, &a->Height, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoResolution * SOAP_FMAC4 soap_in_ns2__VideoResolution(struct soap *soap, const char *tag, struct ns2__VideoResolution *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoResolution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoResolution, sizeof(struct ns2__VideoResolution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoResolution(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoResolution, 0, sizeof(struct ns2__VideoResolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoResolution(struct soap *soap, const struct ns2__VideoResolution *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoResolution);
	if (soap_out_ns2__VideoResolution(soap, tag?tag:"ns2:VideoResolution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoResolution * SOAP_FMAC4 soap_get_ns2__VideoResolution(struct soap *soap, struct ns2__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct ns2__VideoSourceConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoSourceConfigurationOptionsExtension(struct soap *soap, const struct ns2__VideoSourceConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct ns2__VideoSourceConfigurationOptionsExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_ns2__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct ns2__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoSourceConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension, sizeof(struct ns2__VideoSourceConfigurationOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoSourceConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension, 0, sizeof(struct ns2__VideoSourceConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoSourceConfigurationOptionsExtension(struct soap *soap, const struct ns2__VideoSourceConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension);
	if (soap_out_ns2__VideoSourceConfigurationOptionsExtension(soap, tag?tag:"ns2:VideoSourceConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_ns2__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct ns2__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoSourceConfigurationOptions(struct soap *soap, struct ns2__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundsRange = NULL;
	a->__sizeVideoSourceTokensAvailable = 0;
	a->VideoSourceTokensAvailable = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoSourceConfigurationOptions(struct soap *soap, const struct ns2__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IntRectangleRange(soap, &a->BoundsRange);
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeVideoSourceTokensAvailable; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, a->VideoSourceTokensAvailable + i);
		}
	}
	soap_serialize_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns2__VideoSourceConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoSourceConfigurationOptions), type))
		return soap->error;
	if (a->BoundsRange)
	{	if (soap_out_PointerTons2__IntRectangleRange(soap, "ns2:BoundsRange", -1, &a->BoundsRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:BoundsRange"))
		return soap->error;
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeVideoSourceTokensAvailable; i++)
			if (soap_out_ns2__ReferenceToken(soap, "ns2:VideoSourceTokensAvailable", -1, a->VideoSourceTokensAvailable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_ns2__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct ns2__VideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_BoundsRange = 1;
	struct soap_blist *soap_blist_VideoSourceTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoSourceConfigurationOptions, sizeof(struct ns2__VideoSourceConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoSourceConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRectangleRange(soap, "ns2:BoundsRange", &a->BoundsRange, "ns2:IntRectangleRange"))
				{	soap_flag_BoundsRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:VideoSourceTokensAvailable", 1, NULL))
			{	if (a->VideoSourceTokensAvailable == NULL)
				{	if (soap_blist_VideoSourceTokensAvailable == NULL)
						soap_blist_VideoSourceTokensAvailable = soap_new_block(soap);
					a->VideoSourceTokensAvailable = (char **)soap_push_block(soap, soap_blist_VideoSourceTokensAvailable, sizeof(char *));
					if (a->VideoSourceTokensAvailable == NULL)
						return NULL;
					*a->VideoSourceTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns2:VideoSourceTokensAvailable", a->VideoSourceTokensAvailable, "ns2:ReferenceToken"))
				{	a->__sizeVideoSourceTokensAvailable++;
					a->VideoSourceTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, "ns2:Extension", &a->Extension, "ns2:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceTokensAvailable)
			soap_pop_block(soap, soap_blist_VideoSourceTokensAvailable);
		if (a->__sizeVideoSourceTokensAvailable)
			a->VideoSourceTokensAvailable = (char **)soap_save_block(soap, soap_blist_VideoSourceTokensAvailable, NULL, 1);
		else
		{	a->VideoSourceTokensAvailable = NULL;
			if (soap_blist_VideoSourceTokensAvailable)
				soap_end_block(soap, soap_blist_VideoSourceTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoSourceConfigurationOptions, 0, sizeof(struct ns2__VideoSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundsRange > 0 || a->__sizeVideoSourceTokensAvailable < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoSourceConfigurationOptions(struct soap *soap, const struct ns2__VideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoSourceConfigurationOptions);
	if (soap_out_ns2__VideoSourceConfigurationOptions(soap, tag?tag:"ns2:VideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_ns2__VideoSourceConfigurationOptions(struct soap *soap, struct ns2__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConfigurationEntity(struct soap *soap, struct ns2__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConfigurationEntity(struct soap *soap, const struct ns2__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConfigurationEntity(struct soap *soap, const char *tag, int id, const struct ns2__ConfigurationEntity *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConfigurationEntity), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConfigurationEntity * SOAP_FMAC4 soap_in_ns2__ConfigurationEntity(struct soap *soap, const char *tag, struct ns2__ConfigurationEntity *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConfigurationEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConfigurationEntity, sizeof(struct ns2__ConfigurationEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConfigurationEntity(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConfigurationEntity, 0, sizeof(struct ns2__ConfigurationEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConfigurationEntity(struct soap *soap, const struct ns2__ConfigurationEntity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConfigurationEntity);
	if (soap_out_ns2__ConfigurationEntity(soap, tag?tag:"ns2:ConfigurationEntity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConfigurationEntity * SOAP_FMAC4 soap_get_ns2__ConfigurationEntity(struct soap *soap, struct ns2__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ProfileExtension(struct soap *soap, struct ns2__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ProfileExtension(struct soap *soap, const struct ns2__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ProfileExtension(struct soap *soap, const char *tag, int id, const struct ns2__ProfileExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ProfileExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ProfileExtension * SOAP_FMAC4 soap_in_ns2__ProfileExtension(struct soap *soap, const char *tag, struct ns2__ProfileExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ProfileExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ProfileExtension, sizeof(struct ns2__ProfileExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ProfileExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ProfileExtension, 0, sizeof(struct ns2__ProfileExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ProfileExtension(struct soap *soap, const struct ns2__ProfileExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ProfileExtension);
	if (soap_out_ns2__ProfileExtension(soap, tag?tag:"ns2:ProfileExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ProfileExtension * SOAP_FMAC4 soap_get_ns2__ProfileExtension(struct soap *soap, struct ns2__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MetadataConfiguration(struct soap *soap, struct ns2__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	a->PTZStatus = NULL;
	a->Events = NULL;
	a->Analytics = NULL;
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MetadataConfiguration(struct soap *soap, const struct ns2__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTons2__PTZFilter(soap, &a->PTZStatus);
	soap_serialize_PointerTons2__EventSubscription(soap, &a->Events);
	soap_serialize_PointerToxsd__boolean(soap, &a->Analytics);
	soap_serialize_PointerTons2__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MetadataConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__MetadataConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MetadataConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZFilter(soap, "ns2:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTons2__EventSubscription(soap, "ns2:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (a->Multicast)
	{	if (soap_out_PointerTons2__MulticastConfiguration(soap, "ns2:Multicast", -1, &a->Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MetadataConfiguration * SOAP_FMAC4 soap_in_ns2__MetadataConfiguration(struct soap *soap, const char *tag, struct ns2__MetadataConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MetadataConfiguration, sizeof(struct ns2__MetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MetadataConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZFilter(soap, "ns2:PTZStatus", &a->PTZStatus, "ns2:PTZFilter"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EventSubscription(soap, "ns2:Events", &a->Events, "ns2:EventSubscription"))
				{	soap_flag_Events--;
					continue;
				}
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns2:Analytics", &a->Analytics, "xsd:boolean"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MulticastConfiguration(soap, "ns2:Multicast", &a->Multicast, "ns2:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MetadataConfiguration, 0, sizeof(struct ns2__MetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MetadataConfiguration(struct soap *soap, const struct ns2__MetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MetadataConfiguration);
	if (soap_out_ns2__MetadataConfiguration(soap, tag?tag:"ns2:MetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataConfiguration * SOAP_FMAC4 soap_get_ns2__MetadataConfiguration(struct soap *soap, struct ns2__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PTZConfiguration(struct soap *soap, struct ns2__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__ReferenceToken(soap, &a->NodeToken);
	soap_default_xsd__anyURI(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_default_xsd__anyURI(soap, &a->DefaultContinuousZoomVelocitySpace);
	a->DefaultPTZSpeed = NULL;
	a->DefaultPTZTimeout = NULL;
	a->PanTiltLimits = NULL;
	a->ZoomLimits = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__PTZConfiguration(struct soap *soap, const struct ns2__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_ns2__ReferenceToken(soap, &a->NodeToken);
	soap_serialize_xsd__anyURI(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_xsd__anyURI(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_serialize_xsd__anyURI(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_serialize_xsd__anyURI(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_serialize_xsd__anyURI(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_xsd__anyURI(soap, &a->DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTons2__PTZSpeed(soap, &a->DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &a->DefaultPTZTimeout);
	soap_serialize_PointerTons2__PanTiltLimits(soap, &a->PanTiltLimits);
	soap_serialize_PointerTons2__ZoomLimits(soap, &a->ZoomLimits);
	soap_serialize_PointerTons2__PTZConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PTZConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__PTZConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PTZConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->NodeToken)
	{	if (soap_out_ns2__ReferenceToken(soap, "ns2:NodeToken", -1, &a->NodeToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:NodeToken"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:DefaultAbsolutePantTiltPositionSpace", -1, &a->DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:DefaultAbsoluteZoomPositionSpace", -1, &a->DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:DefaultRelativePanTiltTranslationSpace", -1, &a->DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:DefaultRelativeZoomTranslationSpace", -1, &a->DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:DefaultContinuousPanTiltVelocitySpace", -1, &a->DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:DefaultContinuousZoomVelocitySpace", -1, &a->DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZSpeed(soap, "ns2:DefaultPTZSpeed", -1, &a->DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns2:DefaultPTZTimeout", -1, &a->DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTons2__PanTiltLimits(soap, "ns2:PanTiltLimits", -1, &a->PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTons2__ZoomLimits(soap, "ns2:ZoomLimits", -1, &a->ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZConfigurationExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__PTZConfiguration * SOAP_FMAC4 soap_in_ns2__PTZConfiguration(struct soap *soap, const char *tag, struct ns2__PTZConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_NodeToken = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace = 1;
	size_t soap_flag_DefaultPTZSpeed = 1;
	size_t soap_flag_DefaultPTZTimeout = 1;
	size_t soap_flag_PanTiltLimits = 1;
	size_t soap_flag_ZoomLimits = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__PTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PTZConfiguration, sizeof(struct ns2__PTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__PTZConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns2:NodeToken", &a->NodeToken, "ns2:ReferenceToken"))
				{	soap_flag_NodeToken--;
					continue;
				}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:DefaultAbsolutePantTiltPositionSpace", &a->DefaultAbsolutePantTiltPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace--;
					continue;
				}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:DefaultAbsoluteZoomPositionSpace", &a->DefaultAbsoluteZoomPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace--;
					continue;
				}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:DefaultRelativePanTiltTranslationSpace", &a->DefaultRelativePanTiltTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace--;
					continue;
				}
			if (soap_flag_DefaultRelativeZoomTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:DefaultRelativeZoomTranslationSpace", &a->DefaultRelativeZoomTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace--;
					continue;
				}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:DefaultContinuousPanTiltVelocitySpace", &a->DefaultContinuousPanTiltVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace--;
					continue;
				}
			if (soap_flag_DefaultContinuousZoomVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:DefaultContinuousZoomVelocitySpace", &a->DefaultContinuousZoomVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace--;
					continue;
				}
			if (soap_flag_DefaultPTZSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZSpeed(soap, "ns2:DefaultPTZSpeed", &a->DefaultPTZSpeed, "ns2:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed--;
					continue;
				}
			if (soap_flag_DefaultPTZTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns2:DefaultPTZTimeout", &a->DefaultPTZTimeout, "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout--;
					continue;
				}
			if (soap_flag_PanTiltLimits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PanTiltLimits(soap, "ns2:PanTiltLimits", &a->PanTiltLimits, "ns2:PanTiltLimits"))
				{	soap_flag_PanTiltLimits--;
					continue;
				}
			if (soap_flag_ZoomLimits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ZoomLimits(soap, "ns2:ZoomLimits", &a->ZoomLimits, "ns2:ZoomLimits"))
				{	soap_flag_ZoomLimits--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZConfigurationExtension(soap, "ns2:Extension", &a->Extension, "ns2:PTZConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PTZConfiguration, 0, sizeof(struct ns2__PTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_NodeToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PTZConfiguration(struct soap *soap, const struct ns2__PTZConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PTZConfiguration);
	if (soap_out_ns2__PTZConfiguration(soap, tag?tag:"ns2:PTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZConfiguration * SOAP_FMAC4 soap_get_ns2__PTZConfiguration(struct soap *soap, struct ns2__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoAnalyticsConfiguration(struct soap *soap, struct ns2__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
	a->RuleEngineConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoAnalyticsConfiguration(struct soap *soap, const struct ns2__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTons2__AnalyticsEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	soap_serialize_PointerTons2__RuleEngineConfiguration(soap, &a->RuleEngineConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__VideoAnalyticsConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoAnalyticsConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->AnalyticsEngineConfiguration)
	{	if (soap_out_PointerTons2__AnalyticsEngineConfiguration(soap, "ns2:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:AnalyticsEngineConfiguration"))
		return soap->error;
	if (a->RuleEngineConfiguration)
	{	if (soap_out_PointerTons2__RuleEngineConfiguration(soap, "ns2:RuleEngineConfiguration", -1, &a->RuleEngineConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:RuleEngineConfiguration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_ns2__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct ns2__VideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	size_t soap_flag_RuleEngineConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoAnalyticsConfiguration, sizeof(struct ns2__VideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoAnalyticsConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AnalyticsEngineConfiguration(soap, "ns2:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "ns2:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			if (soap_flag_RuleEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RuleEngineConfiguration(soap, "ns2:RuleEngineConfiguration", &a->RuleEngineConfiguration, "ns2:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoAnalyticsConfiguration, 0, sizeof(struct ns2__VideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_AnalyticsEngineConfiguration > 0 || soap_flag_RuleEngineConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoAnalyticsConfiguration(struct soap *soap, const struct ns2__VideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoAnalyticsConfiguration);
	if (soap_out_ns2__VideoAnalyticsConfiguration(soap, tag?tag:"ns2:VideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_ns2__VideoAnalyticsConfiguration(struct soap *soap, struct ns2__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioEncoderConfiguration(struct soap *soap, struct ns2__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__AudioEncoding(soap, &a->Encoding);
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioEncoderConfiguration(struct soap *soap, const struct ns2__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTons2__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__AudioEncoderConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioEncoderConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_ns2__AudioEncoding(soap, "ns2:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:SampleRate", -1, &a->SampleRate, ""))
		return soap->error;
	if (a->Multicast)
	{	if (soap_out_PointerTons2__MulticastConfiguration(soap, "ns2:Multicast", -1, &a->Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_ns2__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct ns2__AudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioEncoderConfiguration, sizeof(struct ns2__AudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioEncoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__AudioEncoding(soap, "ns2:Encoding", &a->Encoding, "ns2:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:SampleRate", &a->SampleRate, "xsd:int"))
				{	soap_flag_SampleRate--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MulticastConfiguration(soap, "ns2:Multicast", &a->Multicast, "ns2:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioEncoderConfiguration, 0, sizeof(struct ns2__AudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioEncoderConfiguration(struct soap *soap, const struct ns2__AudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioEncoderConfiguration);
	if (soap_out_ns2__AudioEncoderConfiguration(soap, tag?tag:"ns2:AudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_ns2__AudioEncoderConfiguration(struct soap *soap, struct ns2__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AudioSourceConfiguration(struct soap *soap, struct ns2__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__ReferenceToken(soap, &a->SourceToken);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AudioSourceConfiguration(struct soap *soap, const struct ns2__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_ns2__ReferenceToken(soap, &a->SourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__AudioSourceConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AudioSourceConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->SourceToken)
	{	if (soap_out_ns2__ReferenceToken(soap, "ns2:SourceToken", -1, &a->SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:SourceToken"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AudioSourceConfiguration * SOAP_FMAC4 soap_in_ns2__AudioSourceConfiguration(struct soap *soap, const char *tag, struct ns2__AudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AudioSourceConfiguration, sizeof(struct ns2__AudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AudioSourceConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns2:SourceToken", &a->SourceToken, "ns2:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AudioSourceConfiguration, 0, sizeof(struct ns2__AudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AudioSourceConfiguration(struct soap *soap, const struct ns2__AudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AudioSourceConfiguration);
	if (soap_out_ns2__AudioSourceConfiguration(soap, tag?tag:"ns2:AudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioSourceConfiguration * SOAP_FMAC4 soap_get_ns2__AudioSourceConfiguration(struct soap *soap, struct ns2__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoSourceConfiguration(struct soap *soap, struct ns2__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__ReferenceToken(soap, &a->SourceToken);
	a->Bounds = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoSourceConfiguration(struct soap *soap, const struct ns2__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_ns2__ReferenceToken(soap, &a->SourceToken);
	soap_serialize_PointerTons2__IntRectangle(soap, &a->Bounds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__VideoSourceConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoSourceConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->SourceToken)
	{	if (soap_out_ns2__ReferenceToken(soap, "ns2:SourceToken", -1, &a->SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:SourceToken"))
		return soap->error;
	if (a->Bounds)
	{	if (soap_out_PointerTons2__IntRectangle(soap, "ns2:Bounds", -1, &a->Bounds, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Bounds"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoSourceConfiguration * SOAP_FMAC4 soap_in_ns2__VideoSourceConfiguration(struct soap *soap, const char *tag, struct ns2__VideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_Bounds = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoSourceConfiguration, sizeof(struct ns2__VideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoSourceConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns2:SourceToken", &a->SourceToken, "ns2:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_Bounds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRectangle(soap, "ns2:Bounds", &a->Bounds, "ns2:IntRectangle"))
				{	soap_flag_Bounds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoSourceConfiguration, 0, sizeof(struct ns2__VideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0 || soap_flag_Bounds > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoSourceConfiguration(struct soap *soap, const struct ns2__VideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoSourceConfiguration);
	if (soap_out_ns2__VideoSourceConfiguration(soap, tag?tag:"ns2:VideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceConfiguration * SOAP_FMAC4 soap_get_ns2__VideoSourceConfiguration(struct soap *soap, struct ns2__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoSourceExtension(struct soap *soap, struct ns2__VideoSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoSourceExtension(struct soap *soap, const struct ns2__VideoSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoSourceExtension(struct soap *soap, const char *tag, int id, const struct ns2__VideoSourceExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoSourceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoSourceExtension * SOAP_FMAC4 soap_in_ns2__VideoSourceExtension(struct soap *soap, const char *tag, struct ns2__VideoSourceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoSourceExtension, sizeof(struct ns2__VideoSourceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoSourceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoSourceExtension, 0, sizeof(struct ns2__VideoSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoSourceExtension(struct soap *soap, const struct ns2__VideoSourceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoSourceExtension);
	if (soap_out_ns2__VideoSourceExtension(soap, tag?tag:"ns2:VideoSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceExtension * SOAP_FMAC4 soap_get_ns2__VideoSourceExtension(struct soap *soap, struct ns2__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IntList(struct soap *soap, struct ns2__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IntList(struct soap *soap, const struct ns2__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Items)
	{	int i;
		for (i = 0; i < a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_int);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IntList(struct soap *soap, const char *tag, int id, const struct ns2__IntList *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IntList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < a->__sizeItems; i++)
			if (soap_out_int(soap, "ns2:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IntList * SOAP_FMAC4 soap_in_ns2__IntList(struct soap *soap, const char *tag, struct ns2__IntList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IntList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IntList, sizeof(struct ns2__IntList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IntList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_new_block(soap);
					a->Items = (int *)soap_push_block(soap, soap_blist_Items, sizeof(int));
					if (a->Items == NULL)
						return NULL;
					soap_default_int(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "ns2:Items", a->Items, "xsd:int"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
			a->Items = (int *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IntList, 0, sizeof(struct ns2__IntList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IntList(struct soap *soap, const struct ns2__IntList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IntList);
	if (soap_out_ns2__IntList(soap, tag?tag:"ns2:IntList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntList * SOAP_FMAC4 soap_get_ns2__IntList(struct soap *soap, struct ns2__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DurationRange(struct soap *soap, struct ns2__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Min);
	soap_default_xsd__duration(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DurationRange(struct soap *soap, const struct ns2__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->Max, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DurationRange(struct soap *soap, const char *tag, int id, const struct ns2__DurationRange *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DurationRange), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DurationRange * SOAP_FMAC4 soap_in_ns2__DurationRange(struct soap *soap, const char *tag, struct ns2__DurationRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DurationRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DurationRange, sizeof(struct ns2__DurationRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DurationRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:Min", &a->Min, "xsd:duration"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:Max", &a->Max, "xsd:duration"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DurationRange, 0, sizeof(struct ns2__DurationRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DurationRange(struct soap *soap, const struct ns2__DurationRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DurationRange);
	if (soap_out_ns2__DurationRange(soap, tag?tag:"ns2:DurationRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DurationRange * SOAP_FMAC4 soap_get_ns2__DurationRange(struct soap *soap, struct ns2__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FloatRange(struct soap *soap, struct ns2__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Min);
	soap_default_float(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FloatRange(struct soap *soap, const struct ns2__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_float);
	soap_embedded(soap, &a->Max, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FloatRange(struct soap *soap, const char *tag, int id, const struct ns2__FloatRange *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "ns2:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_float(soap, "ns2:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FloatRange * SOAP_FMAC4 soap_in_ns2__FloatRange(struct soap *soap, const char *tag, struct ns2__FloatRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FloatRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FloatRange, sizeof(struct ns2__FloatRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FloatRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Min", &a->Min, "xsd:float"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Max", &a->Max, "xsd:float"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FloatRange, 0, sizeof(struct ns2__FloatRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FloatRange(struct soap *soap, const struct ns2__FloatRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FloatRange);
	if (soap_out_ns2__FloatRange(soap, tag?tag:"ns2:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FloatRange * SOAP_FMAC4 soap_get_ns2__FloatRange(struct soap *soap, struct ns2__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IntRange(struct soap *soap, struct ns2__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Min);
	soap_default_int(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IntRange(struct soap *soap, const struct ns2__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_int);
	soap_embedded(soap, &a->Max, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IntRange(struct soap *soap, const char *tag, int id, const struct ns2__IntRange *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IntRange * SOAP_FMAC4 soap_in_ns2__IntRange(struct soap *soap, const char *tag, struct ns2__IntRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IntRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IntRange, sizeof(struct ns2__IntRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IntRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Min", &a->Min, "xsd:int"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Max", &a->Max, "xsd:int"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IntRange, 0, sizeof(struct ns2__IntRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IntRange(struct soap *soap, const struct ns2__IntRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IntRange);
	if (soap_out_ns2__IntRange(soap, tag?tag:"ns2:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntRange * SOAP_FMAC4 soap_get_ns2__IntRange(struct soap *soap, struct ns2__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IntRectangleRange(struct soap *soap, struct ns2__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->XRange = NULL;
	a->YRange = NULL;
	a->WidthRange = NULL;
	a->HeightRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IntRectangleRange(struct soap *soap, const struct ns2__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IntRange(soap, &a->XRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->YRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->WidthRange);
	soap_serialize_PointerTons2__IntRange(soap, &a->HeightRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IntRectangleRange(struct soap *soap, const char *tag, int id, const struct ns2__IntRectangleRange *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IntRectangleRange), type))
		return soap->error;
	if (a->XRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:XRange", -1, &a->XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:XRange"))
		return soap->error;
	if (a->YRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:YRange", -1, &a->YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:YRange"))
		return soap->error;
	if (a->WidthRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:WidthRange", -1, &a->WidthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:WidthRange"))
		return soap->error;
	if (a->HeightRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:HeightRange", -1, &a->HeightRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:HeightRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IntRectangleRange * SOAP_FMAC4 soap_in_ns2__IntRectangleRange(struct soap *soap, const char *tag, struct ns2__IntRectangleRange *a, const char *type)
{
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	size_t soap_flag_WidthRange = 1;
	size_t soap_flag_HeightRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IntRectangleRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IntRectangleRange, sizeof(struct ns2__IntRectangleRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IntRectangleRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:XRange", &a->XRange, "ns2:IntRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:YRange", &a->YRange, "ns2:IntRange"))
				{	soap_flag_YRange--;
					continue;
				}
			if (soap_flag_WidthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:WidthRange", &a->WidthRange, "ns2:IntRange"))
				{	soap_flag_WidthRange--;
					continue;
				}
			if (soap_flag_HeightRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:HeightRange", &a->HeightRange, "ns2:IntRange"))
				{	soap_flag_HeightRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IntRectangleRange, 0, sizeof(struct ns2__IntRectangleRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XRange > 0 || soap_flag_YRange > 0 || soap_flag_WidthRange > 0 || soap_flag_HeightRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IntRectangleRange(struct soap *soap, const struct ns2__IntRectangleRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IntRectangleRange);
	if (soap_out_ns2__IntRectangleRange(soap, tag?tag:"ns2:IntRectangleRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntRectangleRange * SOAP_FMAC4 soap_get_ns2__IntRectangleRange(struct soap *soap, struct ns2__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IntRectangle(struct soap *soap, struct ns2__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->x);
	soap_default_int(soap, &a->y);
	soap_default_int(soap, &a->width);
	soap_default_int(soap, &a->height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IntRectangle(struct soap *soap, const struct ns2__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IntRectangle(struct soap *soap, const char *tag, int id, const struct ns2__IntRectangle *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	soap_set_attr(soap, "x", soap_int2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, a->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, a->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, a->height), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IntRectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IntRectangle * SOAP_FMAC4 soap_in_ns2__IntRectangle(struct soap *soap, const char *tag, struct ns2__IntRectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IntRectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IntRectangle, sizeof(struct ns2__IntRectangle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IntRectangle(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &a->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 1), &a->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 1), &a->height))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IntRectangle, 0, sizeof(struct ns2__IntRectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IntRectangle(struct soap *soap, const struct ns2__IntRectangle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IntRectangle);
	if (soap_out_ns2__IntRectangle(soap, tag?tag:"ns2:IntRectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntRectangle * SOAP_FMAC4 soap_get_ns2__IntRectangle(struct soap *soap, struct ns2__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DeviceEntity(struct soap *soap, struct ns2__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DeviceEntity(struct soap *soap, const struct ns2__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeviceEntity(struct soap *soap, const char *tag, int id, const struct ns2__DeviceEntity *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeviceEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DeviceEntity * SOAP_FMAC4 soap_in_ns2__DeviceEntity(struct soap *soap, const char *tag, struct ns2__DeviceEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DeviceEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeviceEntity, sizeof(struct ns2__DeviceEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DeviceEntity(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeviceEntity, 0, sizeof(struct ns2__DeviceEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DeviceEntity(struct soap *soap, const struct ns2__DeviceEntity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DeviceEntity);
	if (soap_out_ns2__DeviceEntity(soap, tag?tag:"ns2:DeviceEntity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DeviceEntity * SOAP_FMAC4 soap_get_ns2__DeviceEntity(struct soap *soap, struct ns2__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UserExtension(struct soap *soap, struct ns2__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__UserExtension(struct soap *soap, const struct ns2__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UserExtension(struct soap *soap, const char *tag, int id, const struct ns2__UserExtension *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UserExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__UserExtension * SOAP_FMAC4 soap_in_ns2__UserExtension(struct soap *soap, const char *tag, struct ns2__UserExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__UserExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UserExtension, sizeof(struct ns2__UserExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__UserExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UserExtension, 0, sizeof(struct ns2__UserExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UserExtension(struct soap *soap, const struct ns2__UserExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UserExtension);
	if (soap_out_ns2__UserExtension(soap, tag?tag:"ns2:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__UserExtension * SOAP_FMAC4 soap_get_ns2__UserExtension(struct soap *soap, struct ns2__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__User(struct soap *soap, struct ns2__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_ns2__UserLevel(soap, &a->UserLevel);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__User(struct soap *soap, const struct ns2__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_PointerTons2__UserExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__User(struct soap *soap, const char *tag, int id, const struct ns2__User *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__User), type))
		return soap->error;
	if (a->Username)
	{	if (soap_out_string(soap, "ns2:Username", -1, &a->Username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Username"))
		return soap->error;
	if (a->Password)
	{	if (soap_out_string(soap, "ns2:Password", -1, &a->Password, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Password"))
		return soap->error;
	if (soap_out_ns2__UserLevel(soap, "ns2:UserLevel", -1, &a->UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTons2__UserExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__User * SOAP_FMAC4 soap_in_ns2__User(struct soap *soap, const char *tag, struct ns2__User *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UserLevel = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__User, sizeof(struct ns2__User), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__User(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__UserLevel(soap, "ns2:UserLevel", &a->UserLevel, "ns2:UserLevel"))
				{	soap_flag_UserLevel--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UserExtension(soap, "ns2:Extension", &a->Extension, "ns2:UserExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__User, 0, sizeof(struct ns2__User), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_Password > 0 || soap_flag_UserLevel > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__User(struct soap *soap, const struct ns2__User *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__User);
	if (soap_out_ns2__User(soap, tag?tag:"ns2:User", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__User * SOAP_FMAC4 soap_get_ns2__User(struct soap *soap, struct ns2__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetSnapshotUriResponse(struct soap *soap, struct _ns1__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetSnapshotUriResponse(struct soap *soap, const struct _ns1__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MediaUri(soap, &a->MediaUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetSnapshotUriResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSnapshotUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "ns1:MediaUri");
	if (a->MediaUri)
	{	if (soap_out_PointerTons2__MediaUri(soap, "ns1:MediaUri", -1, &a->MediaUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:MediaUri"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUriResponse * SOAP_FMAC4 soap_in__ns1__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _ns1__GetSnapshotUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetSnapshotUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSnapshotUriResponse, sizeof(struct _ns1__GetSnapshotUriResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetSnapshotUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MediaUri(soap, "ns1:MediaUri", &a->MediaUri, "ns2:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			soap_check_result(soap, "ns1:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSnapshotUriResponse, 0, sizeof(struct _ns1__GetSnapshotUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MediaUri > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetSnapshotUriResponse(struct soap *soap, const struct _ns1__GetSnapshotUriResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetSnapshotUriResponse);
	if (soap_out__ns1__GetSnapshotUriResponse(soap, tag?tag:"ns1:GetSnapshotUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUriResponse * SOAP_FMAC4 soap_get__ns1__GetSnapshotUriResponse(struct soap *soap, struct _ns1__GetSnapshotUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetSnapshotUri(struct soap *soap, struct _ns1__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetSnapshotUri(struct soap *soap, const struct _ns1__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct _ns1__GetSnapshotUri *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSnapshotUri), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_ns2__ReferenceToken(soap, "ns1:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUri * SOAP_FMAC4 soap_in__ns1__GetSnapshotUri(struct soap *soap, const char *tag, struct _ns1__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetSnapshotUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSnapshotUri, sizeof(struct _ns1__GetSnapshotUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetSnapshotUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:ProfileToken", &a->ProfileToken, "ns2:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSnapshotUri, 0, sizeof(struct _ns1__GetSnapshotUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetSnapshotUri(struct soap *soap, const struct _ns1__GetSnapshotUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetSnapshotUri);
	if (soap_out__ns1__GetSnapshotUri(soap, tag?tag:"ns1:GetSnapshotUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUri * SOAP_FMAC4 soap_get__ns1__GetSnapshotUri(struct soap *soap, struct _ns1__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _ns1__SetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, const struct _ns1__SetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _ns1__SetVideoEncoderConfigurationResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _ns1__SetVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__SetVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse, sizeof(struct _ns1__SetVideoEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__SetVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__SetVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse, 0, sizeof(struct _ns1__SetVideoEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, const struct _ns1__SetVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse);
	if (soap_out__ns1__SetVideoEncoderConfigurationResponse(soap, tag?tag:"ns1:SetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _ns1__SetVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoEncoderConfiguration(struct soap *soap, struct ns2__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__VideoEncoding(soap, &a->Encoding);
	a->Resolution = NULL;
	soap_default_float(soap, &a->Quality);
	a->RateControl = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoEncoderConfiguration(struct soap *soap, const struct ns2__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTons2__VideoResolution(soap, &a->Resolution);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
	soap_serialize_PointerTons2__VideoRateControl(soap, &a->RateControl);
	soap_serialize_PointerTons2__Mpeg4Configuration(soap, &a->MPEG4);
	soap_serialize_PointerTons2__H264Configuration(soap, &a->H264);
	soap_serialize_PointerTons2__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct ns2__VideoEncoderConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoEncoderConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_int(soap, "ns2:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_ns2__VideoEncoding(soap, "ns2:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (a->Resolution)
	{	if (soap_out_PointerTons2__VideoResolution(soap, "ns2:Resolution", -1, &a->Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Resolution"))
		return soap->error;
	if (soap_out_float(soap, "ns2:Quality", -1, &a->Quality, ""))
		return soap->error;
	if (soap_out_PointerTons2__VideoRateControl(soap, "ns2:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTons2__Mpeg4Configuration(soap, "ns2:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTons2__H264Configuration(soap, "ns2:H264", -1, &a->H264, ""))
		return soap->error;
	if (a->Multicast)
	{	if (soap_out_PointerTons2__MulticastConfiguration(soap, "ns2:Multicast", -1, &a->Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_ns2__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct ns2__VideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Quality = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoEncoderConfiguration, sizeof(struct ns2__VideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoEncoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__VideoEncoding(soap, "ns2:Encoding", &a->Encoding, "ns2:VideoEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoResolution(soap, "ns2:Resolution", &a->Resolution, "ns2:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoRateControl(soap, "ns2:RateControl", &a->RateControl, "ns2:VideoRateControl"))
				{	soap_flag_RateControl--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Mpeg4Configuration(soap, "ns2:MPEG4", &a->MPEG4, "ns2:Mpeg4Configuration"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__H264Configuration(soap, "ns2:H264", &a->H264, "ns2:H264Configuration"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MulticastConfiguration(soap, "ns2:Multicast", &a->Multicast, "ns2:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoEncoderConfiguration, 0, sizeof(struct ns2__VideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Resolution > 0 || soap_flag_Quality > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoEncoderConfiguration(struct soap *soap, const struct ns2__VideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoEncoderConfiguration);
	if (soap_out_ns2__VideoEncoderConfiguration(soap, tag?tag:"ns2:VideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_ns2__VideoEncoderConfiguration(struct soap *soap, struct ns2__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__SetVideoEncoderConfiguration(struct soap *soap, struct _ns1__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__SetVideoEncoderConfiguration(struct soap *soap, const struct _ns1__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__VideoEncoderConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _ns1__SetVideoEncoderConfiguration *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetVideoEncoderConfiguration), type))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTons2__VideoEncoderConfiguration(soap, "ns1:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Configuration"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in__ns1__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _ns1__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__SetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetVideoEncoderConfiguration, sizeof(struct _ns1__SetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__SetVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoEncoderConfiguration(soap, "ns1:Configuration", &a->Configuration, "ns2:VideoEncoderConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__SetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetVideoEncoderConfiguration, 0, sizeof(struct _ns1__SetVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0 || soap_flag_ForcePersistence > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__SetVideoEncoderConfiguration(struct soap *soap, const struct _ns1__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__SetVideoEncoderConfiguration);
	if (soap_out__ns1__SetVideoEncoderConfiguration(soap, tag?tag:"ns1:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get__ns1__SetVideoEncoderConfiguration(struct soap *soap, struct _ns1__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__VideoEncoderConfigurationOptions(struct soap *soap, struct ns2__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->QualityRange = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__VideoEncoderConfigurationOptions(struct soap *soap, const struct ns2__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__IntRange(soap, &a->QualityRange);
	soap_serialize_PointerTons2__JpegOptions(soap, &a->JPEG);
	soap_serialize_PointerTons2__Mpeg4Options(soap, &a->MPEG4);
	soap_serialize_PointerTons2__H264Options(soap, &a->H264);
	soap_serialize_PointerTons2__VideoEncoderOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns2__VideoEncoderConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions), type))
		return soap->error;
	if (a->QualityRange)
	{	if (soap_out_PointerTons2__IntRange(soap, "ns2:QualityRange", -1, &a->QualityRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:QualityRange"))
		return soap->error;
	if (soap_out_PointerTons2__JpegOptions(soap, "ns2:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTons2__Mpeg4Options(soap, "ns2:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTons2__H264Options(soap, "ns2:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTons2__VideoEncoderOptionsExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_ns2__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct ns2__VideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_QualityRange = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__VideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions, sizeof(struct ns2__VideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__VideoEncoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IntRange(soap, "ns2:QualityRange", &a->QualityRange, "ns2:IntRange"))
				{	soap_flag_QualityRange--;
					continue;
				}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__JpegOptions(soap, "ns2:JPEG", &a->JPEG, "ns2:JpegOptions"))
				{	soap_flag_JPEG--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Mpeg4Options(soap, "ns2:MPEG4", &a->MPEG4, "ns2:Mpeg4Options"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__H264Options(soap, "ns2:H264", &a->H264, "ns2:H264Options"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoEncoderOptionsExtension(soap, "ns2:Extension", &a->Extension, "ns2:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions, 0, sizeof(struct ns2__VideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QualityRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__VideoEncoderConfigurationOptions(struct soap *soap, const struct ns2__VideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions);
	if (soap_out_ns2__VideoEncoderConfigurationOptions(soap, tag?tag:"ns2:VideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_ns2__VideoEncoderConfigurationOptions(struct soap *soap, struct ns2__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _ns1__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__VideoEncoderConfigurationOptions(soap, &a->Options);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "ns1:Options");
	if (a->Options)
	{	if (soap_out_PointerTons2__VideoEncoderConfigurationOptions(soap, "ns1:Options", -1, &a->Options, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Options"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns1__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetVideoEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _ns1__GetVideoEncoderConfigurationOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoEncoderConfigurationOptions(soap, "ns1:Options", &a->Options, "ns2:VideoEncoderConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "ns1:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVideoEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse, 0, sizeof(struct _ns1__GetVideoEncoderConfigurationOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _ns1__GetVideoEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"ns1:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_ns2__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct _ns1__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__ReferenceToken(soap, &a->ConfigurationToken);
	soap_serialize_ns2__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _ns1__GetVideoEncoderConfigurationOptions *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:ConfigurationToken", -1, &a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:ProfileToken", -1, &a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in__ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _ns1__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions, sizeof(struct _ns1__GetVideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetVideoEncoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:ConfigurationToken", &a->ConfigurationToken, "ns2:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:ProfileToken", &a->ProfileToken, "ns2:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions, 0, sizeof(struct _ns1__GetVideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct _ns1__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions);
	if (soap_out__ns1__GetVideoEncoderConfigurationOptions(soap, tag?tag:"ns1:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get__ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MediaUri(struct soap *soap, struct ns2__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
	soap_default_xsd__boolean(soap, &a->InvalidAfterConnect);
	soap_default_xsd__boolean(soap, &a->InvalidAfterReboot);
	soap_default_xsd__duration(soap, &a->Timeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MediaUri(struct soap *soap, const struct ns2__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->Uri);
	soap_embedded(soap, &a->InvalidAfterConnect, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->InvalidAfterReboot, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->Timeout, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MediaUri(struct soap *soap, const char *tag, int id, const struct ns2__MediaUri *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MediaUri), type))
		return soap->error;
	if (a->Uri)
	{	if (soap_out_xsd__anyURI(soap, "ns2:Uri", -1, &a->Uri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Uri"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:InvalidAfterConnect", -1, &a->InvalidAfterConnect, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns2:InvalidAfterReboot", -1, &a->InvalidAfterReboot, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns2:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MediaUri * SOAP_FMAC4 soap_in_ns2__MediaUri(struct soap *soap, const char *tag, struct ns2__MediaUri *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	size_t soap_flag_InvalidAfterConnect = 1;
	size_t soap_flag_InvalidAfterReboot = 1;
	size_t soap_flag_Timeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MediaUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MediaUri, sizeof(struct ns2__MediaUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MediaUri(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:Uri", &a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			if (soap_flag_InvalidAfterConnect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:InvalidAfterConnect", &a->InvalidAfterConnect, "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect--;
					continue;
				}
			if (soap_flag_InvalidAfterReboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns2:InvalidAfterReboot", &a->InvalidAfterReboot, "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot--;
					continue;
				}
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns2:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MediaUri, 0, sizeof(struct ns2__MediaUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0 || soap_flag_InvalidAfterConnect > 0 || soap_flag_InvalidAfterReboot > 0 || soap_flag_Timeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MediaUri(struct soap *soap, const struct ns2__MediaUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MediaUri);
	if (soap_out_ns2__MediaUri(soap, tag?tag:"ns2:MediaUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MediaUri * SOAP_FMAC4 soap_get_ns2__MediaUri(struct soap *soap, struct ns2__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetStreamUriResponse(struct soap *soap, struct _ns1__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetStreamUriResponse(struct soap *soap, const struct _ns1__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__MediaUri(soap, &a->MediaUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetStreamUriResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStreamUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "ns1:MediaUri");
	if (a->MediaUri)
	{	if (soap_out_PointerTons2__MediaUri(soap, "ns1:MediaUri", -1, &a->MediaUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:MediaUri"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetStreamUriResponse * SOAP_FMAC4 soap_in__ns1__GetStreamUriResponse(struct soap *soap, const char *tag, struct _ns1__GetStreamUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStreamUriResponse, sizeof(struct _ns1__GetStreamUriResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetStreamUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MediaUri(soap, "ns1:MediaUri", &a->MediaUri, "ns2:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			soap_check_result(soap, "ns1:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStreamUriResponse, 0, sizeof(struct _ns1__GetStreamUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MediaUri > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetStreamUriResponse(struct soap *soap, const struct _ns1__GetStreamUriResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetStreamUriResponse);
	if (soap_out__ns1__GetStreamUriResponse(soap, tag?tag:"ns1:GetStreamUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetStreamUriResponse * SOAP_FMAC4 soap_get__ns1__GetStreamUriResponse(struct soap *soap, struct _ns1__GetStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StreamSetup(struct soap *soap, struct ns2__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__StreamType(soap, &a->Stream);
	a->Transport = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__StreamSetup(struct soap *soap, const struct ns2__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Transport(soap, &a->Transport);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StreamSetup(struct soap *soap, const char *tag, int id, const struct ns2__StreamSetup *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StreamSetup), type))
		return soap->error;
	if (soap_out_ns2__StreamType(soap, "ns2:Stream", -1, &a->Stream, ""))
		return soap->error;
	if (a->Transport)
	{	if (soap_out_PointerTons2__Transport(soap, "ns2:Transport", -1, &a->Transport, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Transport"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__StreamSetup * SOAP_FMAC4 soap_in_ns2__StreamSetup(struct soap *soap, const char *tag, struct ns2__StreamSetup *a, const char *type)
{
	size_t soap_flag_Stream = 1;
	size_t soap_flag_Transport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__StreamSetup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StreamSetup, sizeof(struct ns2__StreamSetup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__StreamSetup(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__StreamType(soap, "ns2:Stream", &a->Stream, "ns2:StreamType"))
				{	soap_flag_Stream--;
					continue;
				}
			if (soap_flag_Transport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Transport(soap, "ns2:Transport", &a->Transport, "ns2:Transport"))
				{	soap_flag_Transport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StreamSetup, 0, sizeof(struct ns2__StreamSetup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream > 0 || soap_flag_Transport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StreamSetup(struct soap *soap, const struct ns2__StreamSetup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StreamSetup);
	if (soap_out_ns2__StreamSetup(soap, tag?tag:"ns2:StreamSetup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__StreamSetup * SOAP_FMAC4 soap_get_ns2__StreamSetup(struct soap *soap, struct ns2__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetStreamUri(struct soap *soap, struct _ns1__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_ns2__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetStreamUri(struct soap *soap, const struct _ns1__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_ns2__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStreamUri(struct soap *soap, const char *tag, int id, const struct _ns1__GetStreamUri *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStreamUri), type))
		return soap->error;
	if (a->StreamSetup)
	{	if (soap_out_PointerTons2__StreamSetup(soap, "ns1:StreamSetup", -1, &a->StreamSetup, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:StreamSetup"))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_ns2__ReferenceToken(soap, "ns1:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetStreamUri * SOAP_FMAC4 soap_in__ns1__GetStreamUri(struct soap *soap, const char *tag, struct _ns1__GetStreamUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStreamUri, sizeof(struct _ns1__GetStreamUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetStreamUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__StreamSetup(soap, "ns1:StreamSetup", &a->StreamSetup, "ns2:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:ProfileToken", &a->ProfileToken, "ns2:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStreamUri, 0, sizeof(struct _ns1__GetStreamUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StreamSetup > 0 || soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetStreamUri(struct soap *soap, const struct _ns1__GetStreamUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetStreamUri);
	if (soap_out__ns1__GetStreamUri(soap, tag?tag:"ns1:GetStreamUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetStreamUri * SOAP_FMAC4 soap_get__ns1__GetStreamUri(struct soap *soap, struct _ns1__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Profile(struct soap *soap, struct ns2__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__Name(soap, &a->Name);
	a->VideoSourceConfiguration = NULL;
	a->AudioSourceConfiguration = NULL;
	a->VideoEncoderConfiguration = NULL;
	a->AudioEncoderConfiguration = NULL;
	a->VideoAnalyticsConfiguration = NULL;
	a->PTZConfiguration = NULL;
	a->MetadataConfiguration = NULL;
	a->Extension = NULL;
	soap_default_ns2__ReferenceToken(soap, &a->token);
	a->fixed = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Profile(struct soap *soap, const struct ns2__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ns2__Name(soap, &a->Name);
	soap_serialize_PointerTons2__VideoSourceConfiguration(soap, &a->VideoSourceConfiguration);
	soap_serialize_PointerTons2__AudioSourceConfiguration(soap, &a->AudioSourceConfiguration);
	soap_serialize_PointerTons2__VideoEncoderConfiguration(soap, &a->VideoEncoderConfiguration);
	soap_serialize_PointerTons2__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_PointerTons2__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTons2__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_serialize_PointerTons2__MetadataConfiguration(soap, &a->MetadataConfiguration);
	soap_serialize_PointerTons2__ProfileExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Profile(struct soap *soap, const char *tag, int id, const struct ns2__Profile *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__boolean2s(soap, *a->fixed), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Profile), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_ns2__Name(soap, "ns2:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:Name"))
		return soap->error;
	if (soap_out_PointerTons2__VideoSourceConfiguration(soap, "ns2:VideoSourceConfiguration", -1, &a->VideoSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__AudioSourceConfiguration(soap, "ns2:AudioSourceConfiguration", -1, &a->AudioSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__VideoEncoderConfiguration(soap, "ns2:VideoEncoderConfiguration", -1, &a->VideoEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__AudioEncoderConfiguration(soap, "ns2:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__VideoAnalyticsConfiguration(soap, "ns2:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__PTZConfiguration(soap, "ns2:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__MetadataConfiguration(soap, "ns2:MetadataConfiguration", -1, &a->MetadataConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTons2__ProfileExtension(soap, "ns2:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Profile * SOAP_FMAC4 soap_in_ns2__Profile(struct soap *soap, const char *tag, struct ns2__Profile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_VideoSourceConfiguration = 1;
	size_t soap_flag_AudioSourceConfiguration = 1;
	size_t soap_flag_VideoEncoderConfiguration = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_MetadataConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Profile, sizeof(struct ns2__Profile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Profile(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			if (!(a->fixed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->fixed))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns2:Name", &a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoSourceConfiguration(soap, "ns2:VideoSourceConfiguration", &a->VideoSourceConfiguration, "ns2:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration--;
					continue;
				}
			if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AudioSourceConfiguration(soap, "ns2:AudioSourceConfiguration", &a->AudioSourceConfiguration, "ns2:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration--;
					continue;
				}
			if (soap_flag_VideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoEncoderConfiguration(soap, "ns2:VideoEncoderConfiguration", &a->VideoEncoderConfiguration, "ns2:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AudioEncoderConfiguration(soap, "ns2:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "ns2:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration--;
					continue;
				}
			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VideoAnalyticsConfiguration(soap, "ns2:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "ns2:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration--;
					continue;
				}
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PTZConfiguration(soap, "ns2:PTZConfiguration", &a->PTZConfiguration, "ns2:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			if (soap_flag_MetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MetadataConfiguration(soap, "ns2:MetadataConfiguration", &a->MetadataConfiguration, "ns2:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ProfileExtension(soap, "ns2:Extension", &a->Extension, "ns2:ProfileExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Profile, 0, sizeof(struct ns2__Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Profile(struct soap *soap, const struct ns2__Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Profile);
	if (soap_out_ns2__Profile(soap, tag?tag:"ns2:Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Profile * SOAP_FMAC4 soap_get_ns2__Profile(struct soap *soap, struct ns2__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetProfilesResponse(struct soap *soap, struct _ns1__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetProfilesResponse(struct soap *soap, const struct _ns1__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Profiles)
	{	int i;
		for (i = 0; i < a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_ns2__Profile);
			soap_serialize_ns2__Profile(soap, a->Profiles + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetProfilesResponse *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles)
	{	int i;
		for (i = 0; i < a->__sizeProfiles; i++)
			if (soap_out_ns2__Profile(soap, "ns1:Profiles", -1, a->Profiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetProfilesResponse * SOAP_FMAC4 soap_in__ns1__GetProfilesResponse(struct soap *soap, const char *tag, struct _ns1__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProfilesResponse, sizeof(struct _ns1__GetProfilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Profiles", 1, NULL))
			{	if (a->Profiles == NULL)
				{	if (soap_blist_Profiles == NULL)
						soap_blist_Profiles = soap_new_block(soap);
					a->Profiles = (struct ns2__Profile *)soap_push_block(soap, soap_blist_Profiles, sizeof(struct ns2__Profile));
					if (a->Profiles == NULL)
						return NULL;
					soap_default_ns2__Profile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_ns2__Profile(soap, "ns1:Profiles", a->Profiles, "ns2:Profile"))
				{	a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Profiles)
			soap_pop_block(soap, soap_blist_Profiles);
		if (a->__sizeProfiles)
			a->Profiles = (struct ns2__Profile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		else
		{	a->Profiles = NULL;
			if (soap_blist_Profiles)
				soap_end_block(soap, soap_blist_Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProfilesResponse, 0, sizeof(struct _ns1__GetProfilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetProfilesResponse(struct soap *soap, const struct _ns1__GetProfilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetProfilesResponse);
	if (soap_out__ns1__GetProfilesResponse(soap, tag?tag:"ns1:GetProfilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetProfilesResponse * SOAP_FMAC4 soap_get__ns1__GetProfilesResponse(struct soap *soap, struct _ns1__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetProfiles(struct soap *soap, struct _ns1__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetProfiles(struct soap *soap, const struct _ns1__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProfiles(struct soap *soap, const char *tag, int id, const struct _ns1__GetProfiles *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProfiles), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetProfiles * SOAP_FMAC4 soap_in__ns1__GetProfiles(struct soap *soap, const char *tag, struct _ns1__GetProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProfiles, sizeof(struct _ns1__GetProfiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProfiles, 0, sizeof(struct _ns1__GetProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetProfiles(struct soap *soap, const struct _ns1__GetProfiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetProfiles);
	if (soap_out__ns1__GetProfiles(soap, tag?tag:"ns1:GetProfiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetProfiles * SOAP_FMAC4 soap_get__ns1__GetProfiles(struct soap *soap, struct _ns1__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE__xop__Include))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__xop__Include);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE__xop__Include);
	if (soap_out__xop__Include(soap, tag?tag:"xop:Include", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_new_block(soap);
					a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
			a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, 0, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xenc__ReferenceList);
	if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Target)
		soap_set_attr(soap, "Target", a->Target, 1);
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, 0, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_new_block(soap);
					a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
			a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, 0, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, 0, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__ReferenceType);
	if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, &a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:KA-Nonce", &a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, 0, sizeof(struct xenc__AgreementMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__AgreementMethodType);
	if (soap_out_xenc__AgreementMethodType(soap, tag?tag:"xenc:AgreementMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, &a->CarriedKeyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", a->Recipient, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, &a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CarriedKeyName", &a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, 0, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedKeyType);
	if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, 0, sizeof(struct xenc__EncryptedDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedDataType);
	if (soap_out_xenc__EncryptedDataType(soap, tag?tag:"xenc:EncryptedDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, 0, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__TransformsType);
	if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, 0, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherReferenceType);
	if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, &a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CipherValue", &a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, 0, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherDataType);
	if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, &a->OAEPparams);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, &a->OAEPparams, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:OAEPparams", &a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, 0, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionMethodType);
	if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, 0, sizeof(struct xenc__EncryptedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedType);
	if (soap_out_xenc__EncryptedType(soap, tag?tag:"xenc:EncryptedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (a->Modulus)
	{	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Modulus"))
		return soap->error;
	if (a->Exponent)
	{	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Exponent"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (a->Y)
	{	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Y"))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (a->P)
	{	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:P"))
		return soap->error;
	if (a->Q)
	{	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Q"))
		return soap->error;
	if (a->Seed)
	{	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Seed"))
		return soap->error;
	if (a->PgenCounter)
	{	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:PgenCounter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (a->X509IssuerName)
	{	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerName"))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (a->X509IssuerSerial)
	{	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerSerial"))
		return soap->error;
	if (a->X509SKI)
	{	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SKI"))
		return soap->error;
	if (a->X509SubjectName)
	{	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SubjectName"))
		return soap->error;
	if (a->X509Certificate)
	{	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509Certificate"))
		return soap->error;
	if (a->X509CRL)
	{	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509CRL"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (a->DSAKeyValue)
	{	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DSAKeyValue"))
		return soap->error;
	if (a->RSAKeyValue)
	{	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:RSAKeyValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (a->DigestMethod)
	{	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestMethod"))
		return soap->error;
	if (a->DigestValue)
	{	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (a->CanonicalizationMethod)
	{	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
		return soap->error;
	if (a->SignatureMethod)
	{	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:SignatureMethod"))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_EventStream(struct soap *soap, int choice, const union _ns2__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_EventStream_NotificationMessage:
		soap_serialize_PointerTons2__NotificationMessageHolderType(soap, &a->NotificationMessage);
		break;
	case SOAP_UNION__ns2__union_EventStream_Extension:
		soap_serialize_PointerTons2__EventStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_EventStream(struct soap *soap, int choice, const union _ns2__union_EventStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_EventStream_NotificationMessage:
		return soap_out_PointerTons2__NotificationMessageHolderType(soap, "ns2:NotificationMessage", -1, &a->NotificationMessage, "");
	case SOAP_UNION__ns2__union_EventStream_Extension:
		return soap_out_PointerTons2__EventStreamExtension(soap, "ns2:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_EventStream * SOAP_FMAC4 soap_in__ns2__union_EventStream(struct soap *soap, int *choice, union _ns2__union_EventStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__NotificationMessageHolderType(soap, "ns2:NotificationMessage", &a->NotificationMessage, "ns2:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__ns2__union_EventStream_NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__EventStreamExtension(soap, "ns2:Extension", &a->Extension, "ns2:EventStreamExtension"))
	{	*choice = SOAP_UNION__ns2__union_EventStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_PTZStream(struct soap *soap, int choice, const union _ns2__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_PTZStream_PTZStatus:
		soap_serialize_PointerTons2__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__ns2__union_PTZStream_Extension:
		soap_serialize_PointerTons2__PTZStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_PTZStream(struct soap *soap, int choice, const union _ns2__union_PTZStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_PTZStream_PTZStatus:
		return soap_out_PointerTons2__PTZStatus(soap, "ns2:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__ns2__union_PTZStream_Extension:
		return soap_out_PointerTons2__PTZStreamExtension(soap, "ns2:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_PTZStream * SOAP_FMAC4 soap_in__ns2__union_PTZStream(struct soap *soap, int *choice, union _ns2__union_PTZStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PTZStatus(soap, "ns2:PTZStatus", &a->PTZStatus, "ns2:PTZStatus"))
	{	*choice = SOAP_UNION__ns2__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PTZStreamExtension(soap, "ns2:Extension", &a->Extension, "ns2:PTZStreamExtension"))
	{	*choice = SOAP_UNION__ns2__union_PTZStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _ns2__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTons2__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__ns2__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTons2__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _ns2__union_VideoAnalyticsStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTons2__Frame(soap, "ns2:Frame", -1, &a->Frame, "");
	case SOAP_UNION__ns2__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTons2__VideoAnalyticsStreamExtension(soap, "ns2:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__ns2__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _ns2__union_VideoAnalyticsStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__Frame(soap, "ns2:Frame", &a->Frame, "ns2:Frame"))
	{	*choice = SOAP_UNION__ns2__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__VideoAnalyticsStreamExtension(soap, "ns2:Extension", &a->Extension, "ns2:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__ns2__union_VideoAnalyticsStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_MetadataStream(struct soap *soap, int choice, const union _ns2__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTons2__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__ns2__union_MetadataStream_PTZ:
		soap_serialize_PointerTons2__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__ns2__union_MetadataStream_Event:
		soap_serialize_PointerTons2__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__ns2__union_MetadataStream_Extension:
		soap_serialize_PointerTons2__MetadataStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_MetadataStream(struct soap *soap, int choice, const union _ns2__union_MetadataStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTons2__VideoAnalyticsStream(soap, "ns2:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__ns2__union_MetadataStream_PTZ:
		return soap_out_PointerTons2__PTZStream(soap, "ns2:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__ns2__union_MetadataStream_Event:
		return soap_out_PointerTons2__EventStream(soap, "ns2:Event", -1, &a->Event, "");
	case SOAP_UNION__ns2__union_MetadataStream_Extension:
		return soap_out_PointerTons2__MetadataStreamExtension(soap, "ns2:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_MetadataStream * SOAP_FMAC4 soap_in__ns2__union_MetadataStream(struct soap *soap, int *choice, union _ns2__union_MetadataStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__VideoAnalyticsStream(soap, "ns2:VideoAnalytics", &a->VideoAnalytics, "ns2:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__ns2__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PTZStream(soap, "ns2:PTZ", &a->PTZ, "ns2:PTZStream"))
	{	*choice = SOAP_UNION__ns2__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__EventStream(soap, "ns2:Event", &a->Event, "ns2:EventStream"))
	{	*choice = SOAP_UNION__ns2__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__MetadataStreamExtension(soap, "ns2:Extension", &a->Extension, "ns2:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__ns2__union_MetadataStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSnapshotUriResponse(struct soap *soap, struct _ns1__GetSnapshotUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSnapshotUriResponse))
		soap_serialize__ns1__GetSnapshotUriResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSnapshotUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetSnapshotUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _ns1__GetSnapshotUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(struct _ns1__GetSnapshotUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetSnapshotUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSnapshotUriResponse, sizeof(struct _ns1__GetSnapshotUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSnapshotUriResponse(struct soap *soap, struct _ns1__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSnapshotUriResponse);
	if (soap_out_PointerTo_ns1__GetSnapshotUriResponse(soap, tag?tag:"ns1:GetSnapshotUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSnapshotUriResponse(struct soap *soap, struct _ns1__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSnapshotUri(struct soap *soap, struct _ns1__GetSnapshotUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSnapshotUri))
		soap_serialize__ns1__GetSnapshotUri(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSnapshotUri(struct soap *soap, const char *tag, int id, struct _ns1__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSnapshotUri);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetSnapshotUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSnapshotUri(struct soap *soap, const char *tag, struct _ns1__GetSnapshotUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetSnapshotUri **)soap_malloc(soap, sizeof(struct _ns1__GetSnapshotUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetSnapshotUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSnapshotUri, sizeof(struct _ns1__GetSnapshotUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSnapshotUri(struct soap *soap, struct _ns1__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSnapshotUri);
	if (soap_out_PointerTo_ns1__GetSnapshotUri(soap, tag?tag:"ns1:GetSnapshotUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSnapshotUri(struct soap *soap, struct _ns1__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _ns1__SetVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse))
		soap_serialize__ns1__SetVideoEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _ns1__SetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__SetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _ns1__SetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__SetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _ns1__SetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__SetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__SetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse, sizeof(struct _ns1__SetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _ns1__SetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_ns1__SetVideoEncoderConfigurationResponse(soap, tag?tag:"ns1:SetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _ns1__SetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetVideoEncoderConfiguration(struct soap *soap, struct _ns1__SetVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetVideoEncoderConfiguration))
		soap_serialize__ns1__SetVideoEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _ns1__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__SetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _ns1__SetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _ns1__SetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__SetVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetVideoEncoderConfiguration, sizeof(struct _ns1__SetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetVideoEncoderConfiguration(struct soap *soap, struct _ns1__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetVideoEncoderConfiguration);
	if (soap_out_PointerTo_ns1__SetVideoEncoderConfiguration(soap, tag?tag:"ns1:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetVideoEncoderConfiguration(struct soap *soap, struct _ns1__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse))
		soap_serialize__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns1__GetVideoEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetVideoEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _ns1__GetVideoEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVideoEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _ns1__GetVideoEncoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"ns1:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions))
		soap_serialize__ns1__GetVideoEncoderConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _ns1__GetVideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetVideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _ns1__GetVideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _ns1__GetVideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetVideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions, sizeof(struct _ns1__GetVideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVideoEncoderConfigurationOptions);
	if (soap_out_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, tag?tag:"ns1:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _ns1__GetVideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStreamUriResponse(struct soap *soap, struct _ns1__GetStreamUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStreamUriResponse))
		soap_serialize__ns1__GetStreamUriResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStreamUriResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStreamUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetStreamUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStreamUriResponse(struct soap *soap, const char *tag, struct _ns1__GetStreamUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetStreamUriResponse **)soap_malloc(soap, sizeof(struct _ns1__GetStreamUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetStreamUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStreamUriResponse, sizeof(struct _ns1__GetStreamUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStreamUriResponse(struct soap *soap, struct _ns1__GetStreamUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStreamUriResponse);
	if (soap_out_PointerTo_ns1__GetStreamUriResponse(soap, tag?tag:"ns1:GetStreamUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStreamUriResponse(struct soap *soap, struct _ns1__GetStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStreamUri(struct soap *soap, struct _ns1__GetStreamUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStreamUri))
		soap_serialize__ns1__GetStreamUri(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStreamUri(struct soap *soap, const char *tag, int id, struct _ns1__GetStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStreamUri);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetStreamUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetStreamUri ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStreamUri(struct soap *soap, const char *tag, struct _ns1__GetStreamUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetStreamUri **)soap_malloc(soap, sizeof(struct _ns1__GetStreamUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetStreamUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStreamUri, sizeof(struct _ns1__GetStreamUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStreamUri(struct soap *soap, struct _ns1__GetStreamUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStreamUri);
	if (soap_out_PointerTo_ns1__GetStreamUri(soap, tag?tag:"ns1:GetStreamUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetStreamUri ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStreamUri(struct soap *soap, struct _ns1__GetStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProfilesResponse(struct soap *soap, struct _ns1__GetProfilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProfilesResponse))
		soap_serialize__ns1__GetProfilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProfilesResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProfilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProfilesResponse(struct soap *soap, const char *tag, struct _ns1__GetProfilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetProfilesResponse **)soap_malloc(soap, sizeof(struct _ns1__GetProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetProfilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProfilesResponse, sizeof(struct _ns1__GetProfilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProfilesResponse(struct soap *soap, struct _ns1__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProfilesResponse);
	if (soap_out_PointerTo_ns1__GetProfilesResponse(soap, tag?tag:"ns1:GetProfilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProfilesResponse(struct soap *soap, struct _ns1__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProfiles(struct soap *soap, struct _ns1__GetProfiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProfiles))
		soap_serialize__ns1__GetProfiles(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProfiles(struct soap *soap, const char *tag, int id, struct _ns1__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProfiles);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProfiles(struct soap *soap, const char *tag, struct _ns1__GetProfiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetProfiles **)soap_malloc(soap, sizeof(struct _ns1__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetProfiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProfiles, sizeof(struct _ns1__GetProfiles), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProfiles(struct soap *soap, struct _ns1__GetProfiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProfiles);
	if (soap_out_PointerTo_ns1__GetProfiles(soap, tag?tag:"ns1:GetProfiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProfiles(struct soap *soap, struct _ns1__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ObjectExtension(struct soap *soap, struct ns2__ObjectExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ObjectExtension))
		soap_serialize_ns2__ObjectExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ObjectExtension(struct soap *soap, const char *tag, int id, struct ns2__ObjectExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ObjectExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ObjectExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ObjectExtension ** SOAP_FMAC4 soap_in_PointerTons2__ObjectExtension(struct soap *soap, const char *tag, struct ns2__ObjectExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ObjectExtension **)soap_malloc(soap, sizeof(struct ns2__ObjectExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ObjectExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ObjectExtension, sizeof(struct ns2__ObjectExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ObjectExtension(struct soap *soap, struct ns2__ObjectExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ObjectExtension);
	if (soap_out_PointerTons2__ObjectExtension(soap, tag?tag:"ns2:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectExtension ** SOAP_FMAC4 soap_get_PointerTons2__ObjectExtension(struct soap *soap, struct ns2__ObjectExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Behaviour(struct soap *soap, struct ns2__Behaviour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Behaviour))
		soap_serialize_ns2__Behaviour(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Behaviour(struct soap *soap, const char *tag, int id, struct ns2__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Behaviour);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Behaviour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Behaviour ** SOAP_FMAC4 soap_in_PointerTons2__Behaviour(struct soap *soap, const char *tag, struct ns2__Behaviour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Behaviour **)soap_malloc(soap, sizeof(struct ns2__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Behaviour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Behaviour, sizeof(struct ns2__Behaviour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Behaviour(struct soap *soap, struct ns2__Behaviour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Behaviour);
	if (soap_out_PointerTons2__Behaviour(soap, tag?tag:"ns2:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Behaviour ** SOAP_FMAC4 soap_get_PointerTons2__Behaviour(struct soap *soap, struct ns2__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Appearance(struct soap *soap, struct ns2__Appearance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Appearance))
		soap_serialize_ns2__Appearance(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Appearance(struct soap *soap, const char *tag, int id, struct ns2__Appearance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Appearance);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Appearance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Appearance ** SOAP_FMAC4 soap_in_PointerTons2__Appearance(struct soap *soap, const char *tag, struct ns2__Appearance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Appearance **)soap_malloc(soap, sizeof(struct ns2__Appearance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Appearance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Appearance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Appearance, sizeof(struct ns2__Appearance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Appearance(struct soap *soap, struct ns2__Appearance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Appearance);
	if (soap_out_PointerTons2__Appearance(soap, tag?tag:"ns2:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Appearance ** SOAP_FMAC4 soap_get_PointerTons2__Appearance(struct soap *soap, struct ns2__Appearance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZConfigurationExtension(struct soap *soap, struct ns2__PTZConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZConfigurationExtension))
		soap_serialize_ns2__PTZConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns2__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons2__PTZConfigurationExtension(struct soap *soap, const char *tag, struct ns2__PTZConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZConfigurationExtension **)soap_malloc(soap, sizeof(struct ns2__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZConfigurationExtension, sizeof(struct ns2__PTZConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZConfigurationExtension(struct soap *soap, struct ns2__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZConfigurationExtension);
	if (soap_out_PointerTons2__PTZConfigurationExtension(soap, tag?tag:"ns2:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons2__PTZConfigurationExtension(struct soap *soap, struct ns2__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ZoomLimits(struct soap *soap, struct ns2__ZoomLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ZoomLimits))
		soap_serialize_ns2__ZoomLimits(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ZoomLimits(struct soap *soap, const char *tag, int id, struct ns2__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ZoomLimits);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ZoomLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTons2__ZoomLimits(struct soap *soap, const char *tag, struct ns2__ZoomLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ZoomLimits **)soap_malloc(soap, sizeof(struct ns2__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ZoomLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoomLimits, sizeof(struct ns2__ZoomLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ZoomLimits(struct soap *soap, struct ns2__ZoomLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ZoomLimits);
	if (soap_out_PointerTons2__ZoomLimits(soap, tag?tag:"ns2:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTons2__ZoomLimits(struct soap *soap, struct ns2__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PanTiltLimits(struct soap *soap, struct ns2__PanTiltLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PanTiltLimits))
		soap_serialize_ns2__PanTiltLimits(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PanTiltLimits(struct soap *soap, const char *tag, int id, struct ns2__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PanTiltLimits);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PanTiltLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTons2__PanTiltLimits(struct soap *soap, const char *tag, struct ns2__PanTiltLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PanTiltLimits **)soap_malloc(soap, sizeof(struct ns2__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PanTiltLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PanTiltLimits, sizeof(struct ns2__PanTiltLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PanTiltLimits(struct soap *soap, struct ns2__PanTiltLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PanTiltLimits);
	if (soap_out_PointerTons2__PanTiltLimits(soap, tag?tag:"ns2:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTons2__PanTiltLimits(struct soap *soap, struct ns2__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZSpeed(struct soap *soap, struct ns2__PTZSpeed *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZSpeed))
		soap_serialize_ns2__PTZSpeed(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZSpeed(struct soap *soap, const char *tag, int id, struct ns2__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZSpeed);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZSpeed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTons2__PTZSpeed(struct soap *soap, const char *tag, struct ns2__PTZSpeed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZSpeed **)soap_malloc(soap, sizeof(struct ns2__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZSpeed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZSpeed, sizeof(struct ns2__PTZSpeed), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZSpeed(struct soap *soap, struct ns2__PTZSpeed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZSpeed);
	if (soap_out_PointerTons2__PTZSpeed(soap, tag?tag:"ns2:PTZSpeed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTons2__PTZSpeed(struct soap *soap, struct ns2__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZNodeExtension(struct soap *soap, struct ns2__PTZNodeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZNodeExtension))
		soap_serialize_ns2__PTZNodeExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZNodeExtension(struct soap *soap, const char *tag, int id, struct ns2__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZNodeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZNodeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTons2__PTZNodeExtension(struct soap *soap, const char *tag, struct ns2__PTZNodeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZNodeExtension **)soap_malloc(soap, sizeof(struct ns2__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZNodeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZNodeExtension, sizeof(struct ns2__PTZNodeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZNodeExtension(struct soap *soap, struct ns2__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZNodeExtension);
	if (soap_out_PointerTons2__PTZNodeExtension(soap, tag?tag:"ns2:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTons2__PTZNodeExtension(struct soap *soap, struct ns2__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AuxiliaryData(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AuxiliaryData))
		soap_serialize_ns2__AuxiliaryData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AuxiliaryData(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AuxiliaryData);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AuxiliaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons2__AuxiliaryData(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AuxiliaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AuxiliaryData, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AuxiliaryData(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AuxiliaryData);
	if (soap_out_PointerTons2__AuxiliaryData(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons2__AuxiliaryData(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RelayOutputSettings(struct soap *soap, struct ns2__RelayOutputSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RelayOutputSettings))
		soap_serialize_ns2__RelayOutputSettings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RelayOutputSettings(struct soap *soap, const char *tag, int id, struct ns2__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RelayOutputSettings);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTons2__RelayOutputSettings(struct soap *soap, const char *tag, struct ns2__RelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RelayOutputSettings **)soap_malloc(soap, sizeof(struct ns2__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RelayOutputSettings, sizeof(struct ns2__RelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RelayOutputSettings(struct soap *soap, struct ns2__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RelayOutputSettings);
	if (soap_out_PointerTons2__RelayOutputSettings(soap, tag?tag:"ns2:RelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTons2__RelayOutputSettings(struct soap *soap, struct ns2__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkInterfaceExtension(struct soap *soap, struct ns2__NetworkInterfaceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkInterfaceExtension))
		soap_serialize_ns2__NetworkInterfaceExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, struct ns2__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkInterfaceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkInterfaceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTons2__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(struct ns2__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkInterfaceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkInterfaceExtension, sizeof(struct ns2__NetworkInterfaceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkInterfaceExtension(struct soap *soap, struct ns2__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkInterfaceExtension);
	if (soap_out_PointerTons2__NetworkInterfaceExtension(soap, tag?tag:"ns2:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTons2__NetworkInterfaceExtension(struct soap *soap, struct ns2__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv6NetworkInterface(struct soap *soap, struct ns2__IPv6NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6NetworkInterface))
		soap_serialize_ns2__IPv6NetworkInterface(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, struct ns2__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv6NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv6NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTons2__IPv6NetworkInterface(struct soap *soap, const char *tag, struct ns2__IPv6NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv6NetworkInterface **)soap_malloc(soap, sizeof(struct ns2__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv6NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv6NetworkInterface, sizeof(struct ns2__IPv6NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv6NetworkInterface(struct soap *soap, struct ns2__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv6NetworkInterface);
	if (soap_out_PointerTons2__IPv6NetworkInterface(soap, tag?tag:"ns2:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTons2__IPv6NetworkInterface(struct soap *soap, struct ns2__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv4NetworkInterface(struct soap *soap, struct ns2__IPv4NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv4NetworkInterface))
		soap_serialize_ns2__IPv4NetworkInterface(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, struct ns2__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv4NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv4NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTons2__IPv4NetworkInterface(struct soap *soap, const char *tag, struct ns2__IPv4NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv4NetworkInterface **)soap_malloc(soap, sizeof(struct ns2__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv4NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv4NetworkInterface, sizeof(struct ns2__IPv4NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv4NetworkInterface(struct soap *soap, struct ns2__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv4NetworkInterface);
	if (soap_out_PointerTons2__IPv4NetworkInterface(soap, tag?tag:"ns2:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTons2__IPv4NetworkInterface(struct soap *soap, struct ns2__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkInterfaceLink(struct soap *soap, struct ns2__NetworkInterfaceLink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkInterfaceLink))
		soap_serialize_ns2__NetworkInterfaceLink(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, struct ns2__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkInterfaceLink);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkInterfaceLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTons2__NetworkInterfaceLink(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkInterfaceLink **)soap_malloc(soap, sizeof(struct ns2__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkInterfaceLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkInterfaceLink, sizeof(struct ns2__NetworkInterfaceLink), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkInterfaceLink(struct soap *soap, struct ns2__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkInterfaceLink);
	if (soap_out_PointerTons2__NetworkInterfaceLink(soap, tag?tag:"ns2:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTons2__NetworkInterfaceLink(struct soap *soap, struct ns2__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkInterfaceInfo(struct soap *soap, struct ns2__NetworkInterfaceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkInterfaceInfo))
		soap_serialize_ns2__NetworkInterfaceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, struct ns2__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkInterfaceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkInterfaceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTons2__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(struct ns2__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkInterfaceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkInterfaceInfo, sizeof(struct ns2__NetworkInterfaceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkInterfaceInfo(struct soap *soap, struct ns2__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkInterfaceInfo);
	if (soap_out_PointerTons2__NetworkInterfaceInfo(soap, tag?tag:"ns2:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTons2__NetworkInterfaceInfo(struct soap *soap, struct ns2__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventSubscription(struct soap *soap, struct ns2__EventSubscription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventSubscription))
		soap_serialize_ns2__EventSubscription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventSubscription(struct soap *soap, const char *tag, int id, struct ns2__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventSubscription);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EventSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__EventSubscription ** SOAP_FMAC4 soap_in_PointerTons2__EventSubscription(struct soap *soap, const char *tag, struct ns2__EventSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__EventSubscription **)soap_malloc(soap, sizeof(struct ns2__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EventSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventSubscription, sizeof(struct ns2__EventSubscription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventSubscription(struct soap *soap, struct ns2__EventSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventSubscription);
	if (soap_out_PointerTons2__EventSubscription(soap, tag?tag:"ns2:EventSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventSubscription ** SOAP_FMAC4 soap_get_PointerTons2__EventSubscription(struct soap *soap, struct ns2__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZFilter(struct soap *soap, struct ns2__PTZFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZFilter))
		soap_serialize_ns2__PTZFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZFilter(struct soap *soap, const char *tag, int id, struct ns2__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZFilter);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZFilter ** SOAP_FMAC4 soap_in_PointerTons2__PTZFilter(struct soap *soap, const char *tag, struct ns2__PTZFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZFilter **)soap_malloc(soap, sizeof(struct ns2__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZFilter, sizeof(struct ns2__PTZFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZFilter(struct soap *soap, struct ns2__PTZFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZFilter);
	if (soap_out_PointerTons2__PTZFilter(soap, tag?tag:"ns2:PTZFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZFilter ** SOAP_FMAC4 soap_get_PointerTons2__PTZFilter(struct soap *soap, struct ns2__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RuleEngineConfiguration(struct soap *soap, struct ns2__RuleEngineConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RuleEngineConfiguration))
		soap_serialize_ns2__RuleEngineConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, struct ns2__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RuleEngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RuleEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__RuleEngineConfiguration(struct soap *soap, const char *tag, struct ns2__RuleEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RuleEngineConfiguration **)soap_malloc(soap, sizeof(struct ns2__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RuleEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RuleEngineConfiguration, sizeof(struct ns2__RuleEngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RuleEngineConfiguration(struct soap *soap, struct ns2__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RuleEngineConfiguration);
	if (soap_out_PointerTons2__RuleEngineConfiguration(soap, tag?tag:"ns2:RuleEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__RuleEngineConfiguration(struct soap *soap, struct ns2__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AnalyticsEngineConfiguration(struct soap *soap, struct ns2__AnalyticsEngineConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AnalyticsEngineConfiguration))
		soap_serialize_ns2__AnalyticsEngineConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, struct ns2__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AnalyticsEngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AnalyticsEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct ns2__AnalyticsEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(struct ns2__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AnalyticsEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AnalyticsEngineConfiguration, sizeof(struct ns2__AnalyticsEngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AnalyticsEngineConfiguration(struct soap *soap, struct ns2__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AnalyticsEngineConfiguration);
	if (soap_out_PointerTons2__AnalyticsEngineConfiguration(soap, tag?tag:"ns2:AnalyticsEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__AnalyticsEngineConfiguration(struct soap *soap, struct ns2__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MulticastConfiguration(struct soap *soap, struct ns2__MulticastConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MulticastConfiguration))
		soap_serialize_ns2__MulticastConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MulticastConfiguration(struct soap *soap, const char *tag, int id, struct ns2__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MulticastConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MulticastConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__MulticastConfiguration(struct soap *soap, const char *tag, struct ns2__MulticastConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MulticastConfiguration **)soap_malloc(soap, sizeof(struct ns2__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MulticastConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MulticastConfiguration, sizeof(struct ns2__MulticastConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MulticastConfiguration(struct soap *soap, struct ns2__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MulticastConfiguration);
	if (soap_out_PointerTons2__MulticastConfiguration(soap, tag?tag:"ns2:MulticastConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__MulticastConfiguration(struct soap *soap, struct ns2__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__H264Configuration(struct soap *soap, struct ns2__H264Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__H264Configuration))
		soap_serialize_ns2__H264Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__H264Configuration(struct soap *soap, const char *tag, int id, struct ns2__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__H264Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__H264Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__H264Configuration ** SOAP_FMAC4 soap_in_PointerTons2__H264Configuration(struct soap *soap, const char *tag, struct ns2__H264Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__H264Configuration **)soap_malloc(soap, sizeof(struct ns2__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__H264Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__H264Configuration, sizeof(struct ns2__H264Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__H264Configuration(struct soap *soap, struct ns2__H264Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__H264Configuration);
	if (soap_out_PointerTons2__H264Configuration(soap, tag?tag:"ns2:H264Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__H264Configuration ** SOAP_FMAC4 soap_get_PointerTons2__H264Configuration(struct soap *soap, struct ns2__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Mpeg4Configuration(struct soap *soap, struct ns2__Mpeg4Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Mpeg4Configuration))
		soap_serialize_ns2__Mpeg4Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Mpeg4Configuration(struct soap *soap, const char *tag, int id, struct ns2__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Mpeg4Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Mpeg4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTons2__Mpeg4Configuration(struct soap *soap, const char *tag, struct ns2__Mpeg4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Mpeg4Configuration **)soap_malloc(soap, sizeof(struct ns2__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Mpeg4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Mpeg4Configuration, sizeof(struct ns2__Mpeg4Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Mpeg4Configuration(struct soap *soap, struct ns2__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Mpeg4Configuration);
	if (soap_out_PointerTons2__Mpeg4Configuration(soap, tag?tag:"ns2:Mpeg4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTons2__Mpeg4Configuration(struct soap *soap, struct ns2__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoRateControl(struct soap *soap, struct ns2__VideoRateControl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoRateControl))
		soap_serialize_ns2__VideoRateControl(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoRateControl(struct soap *soap, const char *tag, int id, struct ns2__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoRateControl);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoRateControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTons2__VideoRateControl(struct soap *soap, const char *tag, struct ns2__VideoRateControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoRateControl **)soap_malloc(soap, sizeof(struct ns2__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoRateControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoRateControl, sizeof(struct ns2__VideoRateControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoRateControl(struct soap *soap, struct ns2__VideoRateControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoRateControl);
	if (soap_out_PointerTons2__VideoRateControl(soap, tag?tag:"ns2:VideoRateControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTons2__VideoRateControl(struct soap *soap, struct ns2__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IntRectangle(struct soap *soap, struct ns2__IntRectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IntRectangle))
		soap_serialize_ns2__IntRectangle(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IntRectangle(struct soap *soap, const char *tag, int id, struct ns2__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IntRectangle);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IntRectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IntRectangle ** SOAP_FMAC4 soap_in_PointerTons2__IntRectangle(struct soap *soap, const char *tag, struct ns2__IntRectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IntRectangle **)soap_malloc(soap, sizeof(struct ns2__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IntRectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IntRectangle, sizeof(struct ns2__IntRectangle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IntRectangle(struct soap *soap, struct ns2__IntRectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IntRectangle);
	if (soap_out_PointerTons2__IntRectangle(soap, tag?tag:"ns2:IntRectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntRectangle ** SOAP_FMAC4 soap_get_PointerTons2__IntRectangle(struct soap *soap, struct ns2__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoSourceExtension(struct soap *soap, struct ns2__VideoSourceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoSourceExtension))
		soap_serialize_ns2__VideoSourceExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoSourceExtension(struct soap *soap, const char *tag, int id, struct ns2__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoSourceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTons2__VideoSourceExtension(struct soap *soap, const char *tag, struct ns2__VideoSourceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoSourceExtension **)soap_malloc(soap, sizeof(struct ns2__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoSourceExtension, sizeof(struct ns2__VideoSourceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoSourceExtension(struct soap *soap, struct ns2__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoSourceExtension);
	if (soap_out_PointerTons2__VideoSourceExtension(soap, tag?tag:"ns2:VideoSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTons2__VideoSourceExtension(struct soap *soap, struct ns2__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImagingSettings(struct soap *soap, struct ns2__ImagingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImagingSettings))
		soap_serialize_ns2__ImagingSettings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImagingSettings(struct soap *soap, const char *tag, int id, struct ns2__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImagingSettings);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTons2__ImagingSettings(struct soap *soap, const char *tag, struct ns2__ImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ImagingSettings **)soap_malloc(soap, sizeof(struct ns2__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImagingSettings, sizeof(struct ns2__ImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImagingSettings(struct soap *soap, struct ns2__ImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImagingSettings);
	if (soap_out_PointerTons2__ImagingSettings(soap, tag?tag:"ns2:ImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTons2__ImagingSettings(struct soap *soap, struct ns2__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PropertyOperation(struct soap *soap, enum ns2__PropertyOperation *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__PropertyOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PropertyOperation(struct soap *soap, const char *tag, int id, enum ns2__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PropertyOperation);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTons2__PropertyOperation(struct soap *soap, const char *tag, enum ns2__PropertyOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__PropertyOperation **)soap_malloc(soap, sizeof(enum ns2__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PropertyOperation, sizeof(enum ns2__PropertyOperation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PropertyOperation(struct soap *soap, enum ns2__PropertyOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PropertyOperation);
	if (soap_out_PointerTons2__PropertyOperation(soap, tag?tag:"ns2:PropertyOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTons2__PropertyOperation(struct soap *soap, enum ns2__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MessageExtension(struct soap *soap, struct ns2__MessageExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MessageExtension))
		soap_serialize_ns2__MessageExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MessageExtension(struct soap *soap, const char *tag, int id, struct ns2__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MessageExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MessageExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MessageExtension ** SOAP_FMAC4 soap_in_PointerTons2__MessageExtension(struct soap *soap, const char *tag, struct ns2__MessageExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MessageExtension **)soap_malloc(soap, sizeof(struct ns2__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MessageExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MessageExtension, sizeof(struct ns2__MessageExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MessageExtension(struct soap *soap, struct ns2__MessageExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MessageExtension);
	if (soap_out_PointerTons2__MessageExtension(soap, tag?tag:"ns2:MessageExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MessageExtension ** SOAP_FMAC4 soap_get_PointerTons2__MessageExtension(struct soap *soap, struct ns2__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MetadataType(struct soap *soap, struct ns2__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MetadataType))
		soap_serialize_ns2__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MetadataType(struct soap *soap, const char *tag, int id, struct ns2__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MetadataType ** SOAP_FMAC4 soap_in_PointerTons2__MetadataType(struct soap *soap, const char *tag, struct ns2__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MetadataType **)soap_malloc(soap, sizeof(struct ns2__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MetadataType, sizeof(struct ns2__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MetadataType(struct soap *soap, struct ns2__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MetadataType);
	if (soap_out_PointerTons2__MetadataType(soap, tag?tag:"ns2:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataType ** SOAP_FMAC4 soap_get_PointerTons2__MetadataType(struct soap *soap, struct ns2__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReferenceParametersType(struct soap *soap, struct ns2__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReferenceParametersType))
		soap_serialize_ns2__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct ns2__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTons2__ReferenceParametersType(struct soap *soap, const char *tag, struct ns2__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ReferenceParametersType **)soap_malloc(soap, sizeof(struct ns2__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReferenceParametersType, sizeof(struct ns2__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReferenceParametersType(struct soap *soap, struct ns2__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReferenceParametersType);
	if (soap_out_PointerTons2__ReferenceParametersType(soap, tag?tag:"ns2:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTons2__ReferenceParametersType(struct soap *soap, struct ns2__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AttributedURIType(struct soap *soap, struct ns2__AttributedURIType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AttributedURIType))
		soap_serialize_ns2__AttributedURIType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AttributedURIType(struct soap *soap, const char *tag, int id, struct ns2__AttributedURIType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AttributedURIType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AttributedURIType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AttributedURIType ** SOAP_FMAC4 soap_in_PointerTons2__AttributedURIType(struct soap *soap, const char *tag, struct ns2__AttributedURIType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AttributedURIType **)soap_malloc(soap, sizeof(struct ns2__AttributedURIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AttributedURIType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AttributedURIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AttributedURIType, sizeof(struct ns2__AttributedURIType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AttributedURIType(struct soap *soap, struct ns2__AttributedURIType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AttributedURIType);
	if (soap_out_PointerTons2__AttributedURIType(soap, tag?tag:"ns2:AttributedURIType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AttributedURIType ** SOAP_FMAC4 soap_get_PointerTons2__AttributedURIType(struct soap *soap, struct ns2__AttributedURIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TopicExpressionType(struct soap *soap, struct ns2__TopicExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TopicExpressionType))
		soap_serialize_ns2__TopicExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TopicExpressionType(struct soap *soap, const char *tag, int id, struct ns2__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTons2__TopicExpressionType(struct soap *soap, const char *tag, struct ns2__TopicExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__TopicExpressionType **)soap_malloc(soap, sizeof(struct ns2__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TopicExpressionType, sizeof(struct ns2__TopicExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TopicExpressionType(struct soap *soap, struct ns2__TopicExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TopicExpressionType);
	if (soap_out_PointerTons2__TopicExpressionType(soap, tag?tag:"ns2:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTons2__TopicExpressionType(struct soap *soap, struct ns2__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EndpointReferenceType(struct soap *soap, struct ns2__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EndpointReferenceType))
		soap_serialize_ns2__EndpointReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct ns2__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTons2__EndpointReferenceType(struct soap *soap, const char *tag, struct ns2__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__EndpointReferenceType **)soap_malloc(soap, sizeof(struct ns2__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EndpointReferenceType, sizeof(struct ns2__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EndpointReferenceType(struct soap *soap, struct ns2__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EndpointReferenceType);
	if (soap_out_PointerTons2__EndpointReferenceType(soap, tag?tag:"ns2:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTons2__EndpointReferenceType(struct soap *soap, struct ns2__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_EventStream(struct soap *soap, struct __ns2__union_EventStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_EventStream))
		soap_serialize___ns2__union_EventStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_EventStream(struct soap *soap, const char *tag, int id, struct __ns2__union_EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_EventStream);
	if (id < 0)
		return soap->error;
	return soap_out___ns2__union_EventStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns2__union_EventStream ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_EventStream(struct soap *soap, const char *tag, struct __ns2__union_EventStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns2__union_EventStream **)soap_malloc(soap, sizeof(struct __ns2__union_EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns2__union_EventStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns2__union_EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_EventStream, sizeof(struct __ns2__union_EventStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_EventStream(struct soap *soap, struct __ns2__union_EventStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_EventStream);
	if (soap_out_PointerTo__ns2__union_EventStream(soap, tag?tag:"-ns2:union-EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns2__union_EventStream ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_EventStream(struct soap *soap, struct __ns2__union_EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventStreamExtension(struct soap *soap, struct ns2__EventStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventStreamExtension))
		soap_serialize_ns2__EventStreamExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventStreamExtension(struct soap *soap, const char *tag, int id, struct ns2__EventStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EventStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__EventStreamExtension ** SOAP_FMAC4 soap_in_PointerTons2__EventStreamExtension(struct soap *soap, const char *tag, struct ns2__EventStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__EventStreamExtension **)soap_malloc(soap, sizeof(struct ns2__EventStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EventStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__EventStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventStreamExtension, sizeof(struct ns2__EventStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventStreamExtension(struct soap *soap, struct ns2__EventStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventStreamExtension);
	if (soap_out_PointerTons2__EventStreamExtension(soap, tag?tag:"ns2:EventStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventStreamExtension ** SOAP_FMAC4 soap_get_PointerTons2__EventStreamExtension(struct soap *soap, struct ns2__EventStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NotificationMessageHolderType(struct soap *soap, struct ns2__NotificationMessageHolderType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NotificationMessageHolderType))
		soap_serialize_ns2__NotificationMessageHolderType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct ns2__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NotificationMessageHolderType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTons2__NotificationMessageHolderType(struct soap *soap, const char *tag, struct ns2__NotificationMessageHolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct ns2__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NotificationMessageHolderType, sizeof(struct ns2__NotificationMessageHolderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NotificationMessageHolderType(struct soap *soap, struct ns2__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NotificationMessageHolderType);
	if (soap_out_PointerTons2__NotificationMessageHolderType(soap, tag?tag:"ns2:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTons2__NotificationMessageHolderType(struct soap *soap, struct ns2__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_PTZStream(struct soap *soap, struct __ns2__union_PTZStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_PTZStream))
		soap_serialize___ns2__union_PTZStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_PTZStream(struct soap *soap, const char *tag, int id, struct __ns2__union_PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_PTZStream);
	if (id < 0)
		return soap->error;
	return soap_out___ns2__union_PTZStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns2__union_PTZStream ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_PTZStream(struct soap *soap, const char *tag, struct __ns2__union_PTZStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns2__union_PTZStream **)soap_malloc(soap, sizeof(struct __ns2__union_PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns2__union_PTZStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns2__union_PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_PTZStream, sizeof(struct __ns2__union_PTZStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_PTZStream(struct soap *soap, struct __ns2__union_PTZStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_PTZStream);
	if (soap_out_PointerTo__ns2__union_PTZStream(soap, tag?tag:"-ns2:union-PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns2__union_PTZStream ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_PTZStream(struct soap *soap, struct __ns2__union_PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZStreamExtension(struct soap *soap, struct ns2__PTZStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZStreamExtension))
		soap_serialize_ns2__PTZStreamExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZStreamExtension(struct soap *soap, const char *tag, int id, struct ns2__PTZStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZStreamExtension ** SOAP_FMAC4 soap_in_PointerTons2__PTZStreamExtension(struct soap *soap, const char *tag, struct ns2__PTZStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZStreamExtension **)soap_malloc(soap, sizeof(struct ns2__PTZStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZStreamExtension, sizeof(struct ns2__PTZStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZStreamExtension(struct soap *soap, struct ns2__PTZStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZStreamExtension);
	if (soap_out_PointerTons2__PTZStreamExtension(soap, tag?tag:"ns2:PTZStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStreamExtension ** SOAP_FMAC4 soap_get_PointerTons2__PTZStreamExtension(struct soap *soap, struct ns2__PTZStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_VideoAnalyticsStream(struct soap *soap, struct __ns2__union_VideoAnalyticsStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_VideoAnalyticsStream))
		soap_serialize___ns2__union_VideoAnalyticsStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, struct __ns2__union_VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_VideoAnalyticsStream);
	if (id < 0)
		return soap->error;
	return soap_out___ns2__union_VideoAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns2__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __ns2__union_VideoAnalyticsStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns2__union_VideoAnalyticsStream **)soap_malloc(soap, sizeof(struct __ns2__union_VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns2__union_VideoAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns2__union_VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_VideoAnalyticsStream, sizeof(struct __ns2__union_VideoAnalyticsStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_VideoAnalyticsStream(struct soap *soap, struct __ns2__union_VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_VideoAnalyticsStream);
	if (soap_out_PointerTo__ns2__union_VideoAnalyticsStream(soap, tag?tag:"-ns2:union-VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns2__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_VideoAnalyticsStream(struct soap *soap, struct __ns2__union_VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoAnalyticsStreamExtension(struct soap *soap, struct ns2__VideoAnalyticsStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension))
		soap_serialize_ns2__VideoAnalyticsStreamExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, struct ns2__VideoAnalyticsStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoAnalyticsStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_in_PointerTons2__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct ns2__VideoAnalyticsStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoAnalyticsStreamExtension **)soap_malloc(soap, sizeof(struct ns2__VideoAnalyticsStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoAnalyticsStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoAnalyticsStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoAnalyticsStreamExtension, sizeof(struct ns2__VideoAnalyticsStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoAnalyticsStreamExtension(struct soap *soap, struct ns2__VideoAnalyticsStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoAnalyticsStreamExtension);
	if (soap_out_PointerTons2__VideoAnalyticsStreamExtension(soap, tag?tag:"ns2:VideoAnalyticsStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_get_PointerTons2__VideoAnalyticsStreamExtension(struct soap *soap, struct ns2__VideoAnalyticsStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Frame(struct soap *soap, struct ns2__Frame *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Frame))
		soap_serialize_ns2__Frame(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Frame(struct soap *soap, const char *tag, int id, struct ns2__Frame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Frame);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Frame(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Frame ** SOAP_FMAC4 soap_in_PointerTons2__Frame(struct soap *soap, const char *tag, struct ns2__Frame **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Frame **)soap_malloc(soap, sizeof(struct ns2__Frame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Frame(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Frame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Frame, sizeof(struct ns2__Frame), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Frame(struct soap *soap, struct ns2__Frame *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Frame);
	if (soap_out_PointerTons2__Frame(soap, tag?tag:"ns2:Frame", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Frame ** SOAP_FMAC4 soap_get_PointerTons2__Frame(struct soap *soap, struct ns2__Frame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_MetadataStream(struct soap *soap, struct __ns2__union_MetadataStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_MetadataStream))
		soap_serialize___ns2__union_MetadataStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_MetadataStream(struct soap *soap, const char *tag, int id, struct __ns2__union_MetadataStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_MetadataStream);
	if (id < 0)
		return soap->error;
	return soap_out___ns2__union_MetadataStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __ns2__union_MetadataStream ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_MetadataStream(struct soap *soap, const char *tag, struct __ns2__union_MetadataStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __ns2__union_MetadataStream **)soap_malloc(soap, sizeof(struct __ns2__union_MetadataStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___ns2__union_MetadataStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __ns2__union_MetadataStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_MetadataStream, sizeof(struct __ns2__union_MetadataStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_MetadataStream(struct soap *soap, struct __ns2__union_MetadataStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_MetadataStream);
	if (soap_out_PointerTo__ns2__union_MetadataStream(soap, tag?tag:"-ns2:union-MetadataStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __ns2__union_MetadataStream ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_MetadataStream(struct soap *soap, struct __ns2__union_MetadataStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MetadataStreamExtension(struct soap *soap, struct ns2__MetadataStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MetadataStreamExtension))
		soap_serialize_ns2__MetadataStreamExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MetadataStreamExtension(struct soap *soap, const char *tag, int id, struct ns2__MetadataStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MetadataStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MetadataStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MetadataStreamExtension ** SOAP_FMAC4 soap_in_PointerTons2__MetadataStreamExtension(struct soap *soap, const char *tag, struct ns2__MetadataStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MetadataStreamExtension **)soap_malloc(soap, sizeof(struct ns2__MetadataStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MetadataStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MetadataStreamExtension, sizeof(struct ns2__MetadataStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MetadataStreamExtension(struct soap *soap, struct ns2__MetadataStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MetadataStreamExtension);
	if (soap_out_PointerTons2__MetadataStreamExtension(soap, tag?tag:"ns2:MetadataStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataStreamExtension ** SOAP_FMAC4 soap_get_PointerTons2__MetadataStreamExtension(struct soap *soap, struct ns2__MetadataStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventStream(struct soap *soap, struct ns2__EventStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventStream))
		soap_serialize_ns2__EventStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventStream(struct soap *soap, const char *tag, int id, struct ns2__EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventStream);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EventStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__EventStream ** SOAP_FMAC4 soap_in_PointerTons2__EventStream(struct soap *soap, const char *tag, struct ns2__EventStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__EventStream **)soap_malloc(soap, sizeof(struct ns2__EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EventStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventStream, sizeof(struct ns2__EventStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventStream(struct soap *soap, struct ns2__EventStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventStream);
	if (soap_out_PointerTons2__EventStream(soap, tag?tag:"ns2:EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventStream ** SOAP_FMAC4 soap_get_PointerTons2__EventStream(struct soap *soap, struct ns2__EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZStream(struct soap *soap, struct ns2__PTZStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZStream))
		soap_serialize_ns2__PTZStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZStream(struct soap *soap, const char *tag, int id, struct ns2__PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZStream);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZStream ** SOAP_FMAC4 soap_in_PointerTons2__PTZStream(struct soap *soap, const char *tag, struct ns2__PTZStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZStream **)soap_malloc(soap, sizeof(struct ns2__PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZStream, sizeof(struct ns2__PTZStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZStream(struct soap *soap, struct ns2__PTZStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZStream);
	if (soap_out_PointerTons2__PTZStream(soap, tag?tag:"ns2:PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStream ** SOAP_FMAC4 soap_get_PointerTons2__PTZStream(struct soap *soap, struct ns2__PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoAnalyticsStream(struct soap *soap, struct ns2__VideoAnalyticsStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoAnalyticsStream))
		soap_serialize_ns2__VideoAnalyticsStream(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, struct ns2__VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoAnalyticsStream);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTons2__VideoAnalyticsStream(struct soap *soap, const char *tag, struct ns2__VideoAnalyticsStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoAnalyticsStream **)soap_malloc(soap, sizeof(struct ns2__VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoAnalyticsStream, sizeof(struct ns2__VideoAnalyticsStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoAnalyticsStream(struct soap *soap, struct ns2__VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoAnalyticsStream);
	if (soap_out_PointerTons2__VideoAnalyticsStream(soap, tag?tag:"ns2:VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTons2__VideoAnalyticsStream(struct soap *soap, struct ns2__VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SupportedAnalyticsModulesExtension(struct soap *soap, struct ns2__SupportedAnalyticsModulesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension))
		soap_serialize_ns2__SupportedAnalyticsModulesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, struct ns2__SupportedAnalyticsModulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SupportedAnalyticsModulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_in_PointerTons2__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct ns2__SupportedAnalyticsModulesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SupportedAnalyticsModulesExtension **)soap_malloc(soap, sizeof(struct ns2__SupportedAnalyticsModulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SupportedAnalyticsModulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension, sizeof(struct ns2__SupportedAnalyticsModulesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SupportedAnalyticsModulesExtension(struct soap *soap, struct ns2__SupportedAnalyticsModulesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SupportedAnalyticsModulesExtension);
	if (soap_out_PointerTons2__SupportedAnalyticsModulesExtension(soap, tag?tag:"ns2:SupportedAnalyticsModulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_get_PointerTons2__SupportedAnalyticsModulesExtension(struct soap *soap, struct ns2__SupportedAnalyticsModulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SupportedRulesExtension(struct soap *soap, struct ns2__SupportedRulesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SupportedRulesExtension))
		soap_serialize_ns2__SupportedRulesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SupportedRulesExtension(struct soap *soap, const char *tag, int id, struct ns2__SupportedRulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SupportedRulesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SupportedRulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SupportedRulesExtension ** SOAP_FMAC4 soap_in_PointerTons2__SupportedRulesExtension(struct soap *soap, const char *tag, struct ns2__SupportedRulesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SupportedRulesExtension **)soap_malloc(soap, sizeof(struct ns2__SupportedRulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SupportedRulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SupportedRulesExtension, sizeof(struct ns2__SupportedRulesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SupportedRulesExtension(struct soap *soap, struct ns2__SupportedRulesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SupportedRulesExtension);
	if (soap_out_PointerTons2__SupportedRulesExtension(soap, tag?tag:"ns2:SupportedRulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SupportedRulesExtension ** SOAP_FMAC4 soap_get_PointerTons2__SupportedRulesExtension(struct soap *soap, struct ns2__SupportedRulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConfigDescription(struct soap *soap, struct ns2__ConfigDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConfigDescription))
		soap_serialize_ns2__ConfigDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConfigDescription(struct soap *soap, const char *tag, int id, struct ns2__ConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConfigDescription);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ConfigDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ConfigDescription ** SOAP_FMAC4 soap_in_PointerTons2__ConfigDescription(struct soap *soap, const char *tag, struct ns2__ConfigDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ConfigDescription **)soap_malloc(soap, sizeof(struct ns2__ConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ConfigDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConfigDescription, sizeof(struct ns2__ConfigDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConfigDescription(struct soap *soap, struct ns2__ConfigDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConfigDescription);
	if (soap_out_PointerTons2__ConfigDescription(soap, tag?tag:"ns2:ConfigDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConfigDescription ** SOAP_FMAC4 soap_get_PointerTons2__ConfigDescription(struct soap *soap, struct ns2__ConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConfigDescriptionExtension(struct soap *soap, struct ns2__ConfigDescriptionExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConfigDescriptionExtension))
		soap_serialize_ns2__ConfigDescriptionExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, struct ns2__ConfigDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConfigDescriptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ConfigDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ConfigDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTons2__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct ns2__ConfigDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ConfigDescriptionExtension **)soap_malloc(soap, sizeof(struct ns2__ConfigDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ConfigDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConfigDescriptionExtension, sizeof(struct ns2__ConfigDescriptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConfigDescriptionExtension(struct soap *soap, struct ns2__ConfigDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConfigDescriptionExtension);
	if (soap_out_PointerTons2__ConfigDescriptionExtension(soap, tag?tag:"ns2:ConfigDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConfigDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTons2__ConfigDescriptionExtension(struct soap *soap, struct ns2__ConfigDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ConfigDescription_Messages(struct soap *soap, struct _ns2__ConfigDescription_Messages *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ConfigDescription_Messages))
		soap_serialize__ns2__ConfigDescription_Messages(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, struct _ns2__ConfigDescription_Messages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ConfigDescription_Messages);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ConfigDescription_Messages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ConfigDescription_Messages ** SOAP_FMAC4 soap_in_PointerTo_ns2__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _ns2__ConfigDescription_Messages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ConfigDescription_Messages **)soap_malloc(soap, sizeof(struct _ns2__ConfigDescription_Messages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ConfigDescription_Messages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ConfigDescription_Messages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ConfigDescription_Messages, sizeof(struct _ns2__ConfigDescription_Messages), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ConfigDescription_Messages(struct soap *soap, struct _ns2__ConfigDescription_Messages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ConfigDescription_Messages);
	if (soap_out_PointerTo_ns2__ConfigDescription_Messages(soap, tag?tag:"ns2:ConfigDescription-Messages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ConfigDescription_Messages ** SOAP_FMAC4 soap_get_PointerTo_ns2__ConfigDescription_Messages(struct soap *soap, struct _ns2__ConfigDescription_Messages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ItemList(struct soap *soap, struct ns2__ItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ItemList))
		soap_serialize_ns2__ItemList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ItemList(struct soap *soap, const char *tag, int id, struct ns2__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ItemList);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ItemList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ItemList ** SOAP_FMAC4 soap_in_PointerTons2__ItemList(struct soap *soap, const char *tag, struct ns2__ItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ItemList **)soap_malloc(soap, sizeof(struct ns2__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ItemList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ItemList, sizeof(struct ns2__ItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ItemList(struct soap *soap, struct ns2__ItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ItemList);
	if (soap_out_PointerTons2__ItemList(soap, tag?tag:"ns2:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemList ** SOAP_FMAC4 soap_get_PointerTons2__ItemList(struct soap *soap, struct ns2__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RuleEngineConfigurationExtension(struct soap *soap, struct ns2__RuleEngineConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RuleEngineConfigurationExtension))
		soap_serialize_ns2__RuleEngineConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns2__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RuleEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RuleEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons2__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct ns2__RuleEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct ns2__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RuleEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RuleEngineConfigurationExtension, sizeof(struct ns2__RuleEngineConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RuleEngineConfigurationExtension(struct soap *soap, struct ns2__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RuleEngineConfigurationExtension);
	if (soap_out_PointerTons2__RuleEngineConfigurationExtension(soap, tag?tag:"ns2:RuleEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons2__RuleEngineConfigurationExtension(struct soap *soap, struct ns2__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AnalyticsEngineConfigurationExtension(struct soap *soap, struct ns2__AnalyticsEngineConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension))
		soap_serialize_ns2__AnalyticsEngineConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns2__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AnalyticsEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons2__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct ns2__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct ns2__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AnalyticsEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension, sizeof(struct ns2__AnalyticsEngineConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AnalyticsEngineConfigurationExtension(struct soap *soap, struct ns2__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AnalyticsEngineConfigurationExtension);
	if (soap_out_PointerTons2__AnalyticsEngineConfigurationExtension(soap, tag?tag:"ns2:AnalyticsEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons2__AnalyticsEngineConfigurationExtension(struct soap *soap, struct ns2__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Config(struct soap *soap, struct ns2__Config *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Config))
		soap_serialize_ns2__Config(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Config(struct soap *soap, const char *tag, int id, struct ns2__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Config);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Config(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Config ** SOAP_FMAC4 soap_in_PointerTons2__Config(struct soap *soap, const char *tag, struct ns2__Config **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Config **)soap_malloc(soap, sizeof(struct ns2__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Config(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Config, sizeof(struct ns2__Config), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Config(struct soap *soap, struct ns2__Config *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Config);
	if (soap_out_PointerTons2__Config(soap, tag?tag:"ns2:Config", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Config ** SOAP_FMAC4 soap_get_PointerTons2__Config(struct soap *soap, struct ns2__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ObjectTreeExtension(struct soap *soap, struct ns2__ObjectTreeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ObjectTreeExtension))
		soap_serialize_ns2__ObjectTreeExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ObjectTreeExtension(struct soap *soap, const char *tag, int id, struct ns2__ObjectTreeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ObjectTreeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ObjectTreeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ObjectTreeExtension ** SOAP_FMAC4 soap_in_PointerTons2__ObjectTreeExtension(struct soap *soap, const char *tag, struct ns2__ObjectTreeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ObjectTreeExtension **)soap_malloc(soap, sizeof(struct ns2__ObjectTreeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ObjectTreeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectTreeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ObjectTreeExtension, sizeof(struct ns2__ObjectTreeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ObjectTreeExtension(struct soap *soap, struct ns2__ObjectTreeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ObjectTreeExtension);
	if (soap_out_PointerTons2__ObjectTreeExtension(soap, tag?tag:"ns2:ObjectTreeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectTreeExtension ** SOAP_FMAC4 soap_get_PointerTons2__ObjectTreeExtension(struct soap *soap, struct ns2__ObjectTreeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Merge(struct soap *soap, struct ns2__Merge *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Merge))
		soap_serialize_ns2__Merge(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Merge(struct soap *soap, const char *tag, int id, struct ns2__Merge *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Merge);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Merge(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Merge ** SOAP_FMAC4 soap_in_PointerTons2__Merge(struct soap *soap, const char *tag, struct ns2__Merge **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Merge **)soap_malloc(soap, sizeof(struct ns2__Merge *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Merge(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Merge **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Merge, sizeof(struct ns2__Merge), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Merge(struct soap *soap, struct ns2__Merge *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Merge);
	if (soap_out_PointerTons2__Merge(soap, tag?tag:"ns2:Merge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Merge ** SOAP_FMAC4 soap_get_PointerTons2__Merge(struct soap *soap, struct ns2__Merge **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Split(struct soap *soap, struct ns2__Split *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Split))
		soap_serialize_ns2__Split(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Split(struct soap *soap, const char *tag, int id, struct ns2__Split *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Split);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Split(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Split ** SOAP_FMAC4 soap_in_PointerTons2__Split(struct soap *soap, const char *tag, struct ns2__Split **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Split **)soap_malloc(soap, sizeof(struct ns2__Split *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Split(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Split **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Split, sizeof(struct ns2__Split), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Split(struct soap *soap, struct ns2__Split *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Split);
	if (soap_out_PointerTons2__Split(soap, tag?tag:"ns2:Split", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Split ** SOAP_FMAC4 soap_get_PointerTons2__Split(struct soap *soap, struct ns2__Split **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Rename(struct soap *soap, struct ns2__Rename *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Rename))
		soap_serialize_ns2__Rename(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Rename(struct soap *soap, const char *tag, int id, struct ns2__Rename *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Rename);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Rename(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Rename ** SOAP_FMAC4 soap_in_PointerTons2__Rename(struct soap *soap, const char *tag, struct ns2__Rename **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Rename **)soap_malloc(soap, sizeof(struct ns2__Rename *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Rename(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Rename **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Rename, sizeof(struct ns2__Rename), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Rename(struct soap *soap, struct ns2__Rename *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Rename);
	if (soap_out_PointerTons2__Rename(soap, tag?tag:"ns2:Rename", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Rename ** SOAP_FMAC4 soap_get_PointerTons2__Rename(struct soap *soap, struct ns2__Rename **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BehaviourExtension(struct soap *soap, struct ns2__BehaviourExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BehaviourExtension))
		soap_serialize_ns2__BehaviourExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BehaviourExtension(struct soap *soap, const char *tag, int id, struct ns2__BehaviourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BehaviourExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BehaviourExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BehaviourExtension ** SOAP_FMAC4 soap_in_PointerTons2__BehaviourExtension(struct soap *soap, const char *tag, struct ns2__BehaviourExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BehaviourExtension **)soap_malloc(soap, sizeof(struct ns2__BehaviourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BehaviourExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BehaviourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BehaviourExtension, sizeof(struct ns2__BehaviourExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BehaviourExtension(struct soap *soap, struct ns2__BehaviourExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BehaviourExtension);
	if (soap_out_PointerTons2__BehaviourExtension(soap, tag?tag:"ns2:BehaviourExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BehaviourExtension ** SOAP_FMAC4 soap_get_PointerTons2__BehaviourExtension(struct soap *soap, struct ns2__BehaviourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__Behaviour_Idle(struct soap *soap, struct _ns2__Behaviour_Idle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__Behaviour_Idle))
		soap_serialize__ns2__Behaviour_Idle(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__Behaviour_Idle(struct soap *soap, const char *tag, int id, struct _ns2__Behaviour_Idle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__Behaviour_Idle);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__Behaviour_Idle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__Behaviour_Idle ** SOAP_FMAC4 soap_in_PointerTo_ns2__Behaviour_Idle(struct soap *soap, const char *tag, struct _ns2__Behaviour_Idle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__Behaviour_Idle **)soap_malloc(soap, sizeof(struct _ns2__Behaviour_Idle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__Behaviour_Idle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__Behaviour_Idle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__Behaviour_Idle, sizeof(struct _ns2__Behaviour_Idle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__Behaviour_Idle(struct soap *soap, struct _ns2__Behaviour_Idle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__Behaviour_Idle);
	if (soap_out_PointerTo_ns2__Behaviour_Idle(soap, tag?tag:"ns2:Behaviour-Idle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__Behaviour_Idle ** SOAP_FMAC4 soap_get_PointerTo_ns2__Behaviour_Idle(struct soap *soap, struct _ns2__Behaviour_Idle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__Behaviour_Removed(struct soap *soap, struct _ns2__Behaviour_Removed *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__Behaviour_Removed))
		soap_serialize__ns2__Behaviour_Removed(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__Behaviour_Removed(struct soap *soap, const char *tag, int id, struct _ns2__Behaviour_Removed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__Behaviour_Removed);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__Behaviour_Removed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__Behaviour_Removed ** SOAP_FMAC4 soap_in_PointerTo_ns2__Behaviour_Removed(struct soap *soap, const char *tag, struct _ns2__Behaviour_Removed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__Behaviour_Removed **)soap_malloc(soap, sizeof(struct _ns2__Behaviour_Removed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__Behaviour_Removed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__Behaviour_Removed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__Behaviour_Removed, sizeof(struct _ns2__Behaviour_Removed), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__Behaviour_Removed(struct soap *soap, struct _ns2__Behaviour_Removed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__Behaviour_Removed);
	if (soap_out_PointerTo_ns2__Behaviour_Removed(soap, tag?tag:"ns2:Behaviour-Removed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__Behaviour_Removed ** SOAP_FMAC4 soap_get_PointerTo_ns2__Behaviour_Removed(struct soap *soap, struct _ns2__Behaviour_Removed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ObjectId(struct soap *soap, struct ns2__ObjectId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ObjectId))
		soap_serialize_ns2__ObjectId(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ObjectId(struct soap *soap, const char *tag, int id, struct ns2__ObjectId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ObjectId);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ObjectId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ObjectId ** SOAP_FMAC4 soap_in_PointerTons2__ObjectId(struct soap *soap, const char *tag, struct ns2__ObjectId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ObjectId **)soap_malloc(soap, sizeof(struct ns2__ObjectId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ObjectId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ObjectId, sizeof(struct ns2__ObjectId), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ObjectId(struct soap *soap, struct ns2__ObjectId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ObjectId);
	if (soap_out_PointerTons2__ObjectId(soap, tag?tag:"ns2:ObjectId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectId ** SOAP_FMAC4 soap_get_PointerTons2__ObjectId(struct soap *soap, struct ns2__ObjectId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FrameExtension(struct soap *soap, struct ns2__FrameExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FrameExtension))
		soap_serialize_ns2__FrameExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FrameExtension(struct soap *soap, const char *tag, int id, struct ns2__FrameExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FrameExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FrameExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FrameExtension ** SOAP_FMAC4 soap_in_PointerTons2__FrameExtension(struct soap *soap, const char *tag, struct ns2__FrameExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FrameExtension **)soap_malloc(soap, sizeof(struct ns2__FrameExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FrameExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FrameExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FrameExtension, sizeof(struct ns2__FrameExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FrameExtension(struct soap *soap, struct ns2__FrameExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FrameExtension);
	if (soap_out_PointerTons2__FrameExtension(soap, tag?tag:"ns2:FrameExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FrameExtension ** SOAP_FMAC4 soap_get_PointerTons2__FrameExtension(struct soap *soap, struct ns2__FrameExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ObjectTree(struct soap *soap, struct ns2__ObjectTree *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ObjectTree))
		soap_serialize_ns2__ObjectTree(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ObjectTree(struct soap *soap, const char *tag, int id, struct ns2__ObjectTree *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ObjectTree);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ObjectTree(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ObjectTree ** SOAP_FMAC4 soap_in_PointerTons2__ObjectTree(struct soap *soap, const char *tag, struct ns2__ObjectTree **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ObjectTree **)soap_malloc(soap, sizeof(struct ns2__ObjectTree *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ObjectTree(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ObjectTree **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ObjectTree, sizeof(struct ns2__ObjectTree), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ObjectTree(struct soap *soap, struct ns2__ObjectTree *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ObjectTree);
	if (soap_out_PointerTons2__ObjectTree(soap, tag?tag:"ns2:ObjectTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObjectTree ** SOAP_FMAC4 soap_get_PointerTons2__ObjectTree(struct soap *soap, struct ns2__ObjectTree **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Object(struct soap *soap, struct ns2__Object *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Object))
		soap_serialize_ns2__Object(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Object(struct soap *soap, const char *tag, int id, struct ns2__Object *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Object);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Object(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Object ** SOAP_FMAC4 soap_in_PointerTons2__Object(struct soap *soap, const char *tag, struct ns2__Object **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Object **)soap_malloc(soap, sizeof(struct ns2__Object *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Object(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Object **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Object, sizeof(struct ns2__Object), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Object(struct soap *soap, struct ns2__Object *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Object);
	if (soap_out_PointerTons2__Object(soap, tag?tag:"ns2:Object", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Object ** SOAP_FMAC4 soap_get_PointerTons2__Object(struct soap *soap, struct ns2__Object **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZStatus(struct soap *soap, struct ns2__PTZStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZStatus))
		soap_serialize_ns2__PTZStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZStatus(struct soap *soap, const char *tag, int id, struct ns2__PTZStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZStatus ** SOAP_FMAC4 soap_in_PointerTons2__PTZStatus(struct soap *soap, const char *tag, struct ns2__PTZStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZStatus **)soap_malloc(soap, sizeof(struct ns2__PTZStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZStatus, sizeof(struct ns2__PTZStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZStatus(struct soap *soap, struct ns2__PTZStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZStatus);
	if (soap_out_PointerTons2__PTZStatus(soap, tag?tag:"ns2:PTZStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStatus ** SOAP_FMAC4 soap_get_PointerTons2__PTZStatus(struct soap *soap, struct ns2__PTZStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TransformationExtension(struct soap *soap, struct ns2__TransformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TransformationExtension))
		soap_serialize_ns2__TransformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TransformationExtension(struct soap *soap, const char *tag, int id, struct ns2__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TransformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__TransformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTons2__TransformationExtension(struct soap *soap, const char *tag, struct ns2__TransformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__TransformationExtension **)soap_malloc(soap, sizeof(struct ns2__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__TransformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TransformationExtension, sizeof(struct ns2__TransformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TransformationExtension(struct soap *soap, struct ns2__TransformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TransformationExtension);
	if (soap_out_PointerTons2__TransformationExtension(soap, tag?tag:"ns2:TransformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTons2__TransformationExtension(struct soap *soap, struct ns2__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ClassDescriptorExtension(struct soap *soap, struct ns2__ClassDescriptorExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ClassDescriptorExtension))
		soap_serialize_ns2__ClassDescriptorExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, struct ns2__ClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ClassDescriptorExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ClassDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTons2__ClassDescriptorExtension(struct soap *soap, const char *tag, struct ns2__ClassDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ClassDescriptorExtension **)soap_malloc(soap, sizeof(struct ns2__ClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ClassDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ClassDescriptorExtension, sizeof(struct ns2__ClassDescriptorExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ClassDescriptorExtension(struct soap *soap, struct ns2__ClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ClassDescriptorExtension);
	if (soap_out_PointerTons2__ClassDescriptorExtension(soap, tag?tag:"ns2:ClassDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTons2__ClassDescriptorExtension(struct soap *soap, struct ns2__ClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ClassDescriptor_ClassCandidate(struct soap *soap, struct _ns2__ClassDescriptor_ClassCandidate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate))
		soap_serialize__ns2__ClassDescriptor_ClassCandidate(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, struct _ns2__ClassDescriptor_ClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ClassDescriptor_ClassCandidate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_in_PointerTo_ns2__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _ns2__ClassDescriptor_ClassCandidate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ClassDescriptor_ClassCandidate **)soap_malloc(soap, sizeof(struct _ns2__ClassDescriptor_ClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ClassDescriptor_ClassCandidate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ClassDescriptor_ClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate, sizeof(struct _ns2__ClassDescriptor_ClassCandidate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ClassDescriptor_ClassCandidate(struct soap *soap, struct _ns2__ClassDescriptor_ClassCandidate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ClassDescriptor_ClassCandidate);
	if (soap_out_PointerTo_ns2__ClassDescriptor_ClassCandidate(soap, tag?tag:"ns2:ClassDescriptor-ClassCandidate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_get_PointerTo_ns2__ClassDescriptor_ClassCandidate(struct soap *soap, struct _ns2__ClassDescriptor_ClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ColorDescriptorExtension(struct soap *soap, struct ns2__ColorDescriptorExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ColorDescriptorExtension))
		soap_serialize_ns2__ColorDescriptorExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, struct ns2__ColorDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ColorDescriptorExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ColorDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ColorDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTons2__ColorDescriptorExtension(struct soap *soap, const char *tag, struct ns2__ColorDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ColorDescriptorExtension **)soap_malloc(soap, sizeof(struct ns2__ColorDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ColorDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ColorDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ColorDescriptorExtension, sizeof(struct ns2__ColorDescriptorExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ColorDescriptorExtension(struct soap *soap, struct ns2__ColorDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ColorDescriptorExtension);
	if (soap_out_PointerTons2__ColorDescriptorExtension(soap, tag?tag:"ns2:ColorDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ColorDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTons2__ColorDescriptorExtension(struct soap *soap, struct ns2__ColorDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ColorDescriptor_ColorCluster(struct soap *soap, struct _ns2__ColorDescriptor_ColorCluster *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster))
		soap_serialize__ns2__ColorDescriptor_ColorCluster(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, struct _ns2__ColorDescriptor_ColorCluster *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ColorDescriptor_ColorCluster(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_in_PointerTo_ns2__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _ns2__ColorDescriptor_ColorCluster **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ColorDescriptor_ColorCluster **)soap_malloc(soap, sizeof(struct _ns2__ColorDescriptor_ColorCluster *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ColorDescriptor_ColorCluster(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ColorDescriptor_ColorCluster **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ColorDescriptor_ColorCluster, sizeof(struct _ns2__ColorDescriptor_ColorCluster), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ColorDescriptor_ColorCluster(struct soap *soap, struct _ns2__ColorDescriptor_ColorCluster *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ColorDescriptor_ColorCluster);
	if (soap_out_PointerTo_ns2__ColorDescriptor_ColorCluster(soap, tag?tag:"ns2:ColorDescriptor-ColorCluster", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_get_PointerTo_ns2__ColorDescriptor_ColorCluster(struct soap *soap, struct _ns2__ColorDescriptor_ColorCluster **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ColorCovariance(struct soap *soap, struct ns2__ColorCovariance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ColorCovariance))
		soap_serialize_ns2__ColorCovariance(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ColorCovariance(struct soap *soap, const char *tag, int id, struct ns2__ColorCovariance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ColorCovariance);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ColorCovariance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ColorCovariance ** SOAP_FMAC4 soap_in_PointerTons2__ColorCovariance(struct soap *soap, const char *tag, struct ns2__ColorCovariance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ColorCovariance **)soap_malloc(soap, sizeof(struct ns2__ColorCovariance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ColorCovariance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ColorCovariance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ColorCovariance, sizeof(struct ns2__ColorCovariance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ColorCovariance(struct soap *soap, struct ns2__ColorCovariance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ColorCovariance);
	if (soap_out_PointerTons2__ColorCovariance(soap, tag?tag:"ns2:ColorCovariance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ColorCovariance ** SOAP_FMAC4 soap_get_PointerTons2__ColorCovariance(struct soap *soap, struct ns2__ColorCovariance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Color(struct soap *soap, struct ns2__Color *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Color))
		soap_serialize_ns2__Color(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Color(struct soap *soap, const char *tag, int id, struct ns2__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Color);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Color ** SOAP_FMAC4 soap_in_PointerTons2__Color(struct soap *soap, const char *tag, struct ns2__Color **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Color **)soap_malloc(soap, sizeof(struct ns2__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Color(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Color, sizeof(struct ns2__Color), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Color(struct soap *soap, struct ns2__Color *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Color);
	if (soap_out_PointerTons2__Color(soap, tag?tag:"ns2:Color", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Color ** SOAP_FMAC4 soap_get_PointerTons2__Color(struct soap *soap, struct ns2__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShapeDescriptorExtension(struct soap *soap, struct ns2__ShapeDescriptorExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShapeDescriptorExtension))
		soap_serialize_ns2__ShapeDescriptorExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, struct ns2__ShapeDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShapeDescriptorExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ShapeDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ShapeDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTons2__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct ns2__ShapeDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ShapeDescriptorExtension **)soap_malloc(soap, sizeof(struct ns2__ShapeDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ShapeDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ShapeDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShapeDescriptorExtension, sizeof(struct ns2__ShapeDescriptorExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShapeDescriptorExtension(struct soap *soap, struct ns2__ShapeDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ShapeDescriptorExtension);
	if (soap_out_PointerTons2__ShapeDescriptorExtension(soap, tag?tag:"ns2:ShapeDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ShapeDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTons2__ShapeDescriptorExtension(struct soap *soap, struct ns2__ShapeDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Polygon(struct soap *soap, struct ns2__Polygon *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Polygon))
		soap_serialize_ns2__Polygon(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Polygon(struct soap *soap, const char *tag, int id, struct ns2__Polygon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Polygon);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Polygon(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Polygon ** SOAP_FMAC4 soap_in_PointerTons2__Polygon(struct soap *soap, const char *tag, struct ns2__Polygon **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Polygon **)soap_malloc(soap, sizeof(struct ns2__Polygon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Polygon(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Polygon, sizeof(struct ns2__Polygon), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Polygon(struct soap *soap, struct ns2__Polygon *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Polygon);
	if (soap_out_PointerTons2__Polygon(soap, tag?tag:"ns2:Polygon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Polygon ** SOAP_FMAC4 soap_get_PointerTons2__Polygon(struct soap *soap, struct ns2__Polygon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AppearanceExtension(struct soap *soap, struct ns2__AppearanceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AppearanceExtension))
		soap_serialize_ns2__AppearanceExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AppearanceExtension(struct soap *soap, const char *tag, int id, struct ns2__AppearanceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AppearanceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AppearanceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AppearanceExtension ** SOAP_FMAC4 soap_in_PointerTons2__AppearanceExtension(struct soap *soap, const char *tag, struct ns2__AppearanceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AppearanceExtension **)soap_malloc(soap, sizeof(struct ns2__AppearanceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AppearanceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AppearanceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AppearanceExtension, sizeof(struct ns2__AppearanceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AppearanceExtension(struct soap *soap, struct ns2__AppearanceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AppearanceExtension);
	if (soap_out_PointerTons2__AppearanceExtension(soap, tag?tag:"ns2:AppearanceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AppearanceExtension ** SOAP_FMAC4 soap_get_PointerTons2__AppearanceExtension(struct soap *soap, struct ns2__AppearanceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ClassDescriptor(struct soap *soap, struct ns2__ClassDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ClassDescriptor))
		soap_serialize_ns2__ClassDescriptor(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ClassDescriptor(struct soap *soap, const char *tag, int id, struct ns2__ClassDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ClassDescriptor);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ClassDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ClassDescriptor ** SOAP_FMAC4 soap_in_PointerTons2__ClassDescriptor(struct soap *soap, const char *tag, struct ns2__ClassDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ClassDescriptor **)soap_malloc(soap, sizeof(struct ns2__ClassDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ClassDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ClassDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ClassDescriptor, sizeof(struct ns2__ClassDescriptor), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ClassDescriptor(struct soap *soap, struct ns2__ClassDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ClassDescriptor);
	if (soap_out_PointerTons2__ClassDescriptor(soap, tag?tag:"ns2:ClassDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ClassDescriptor ** SOAP_FMAC4 soap_get_PointerTons2__ClassDescriptor(struct soap *soap, struct ns2__ClassDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ColorDescriptor(struct soap *soap, struct ns2__ColorDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ColorDescriptor))
		soap_serialize_ns2__ColorDescriptor(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ColorDescriptor(struct soap *soap, const char *tag, int id, struct ns2__ColorDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ColorDescriptor);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ColorDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ColorDescriptor ** SOAP_FMAC4 soap_in_PointerTons2__ColorDescriptor(struct soap *soap, const char *tag, struct ns2__ColorDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ColorDescriptor **)soap_malloc(soap, sizeof(struct ns2__ColorDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ColorDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ColorDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ColorDescriptor, sizeof(struct ns2__ColorDescriptor), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ColorDescriptor(struct soap *soap, struct ns2__ColorDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ColorDescriptor);
	if (soap_out_PointerTons2__ColorDescriptor(soap, tag?tag:"ns2:ColorDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ColorDescriptor ** SOAP_FMAC4 soap_get_PointerTons2__ColorDescriptor(struct soap *soap, struct ns2__ColorDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShapeDescriptor(struct soap *soap, struct ns2__ShapeDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShapeDescriptor))
		soap_serialize_ns2__ShapeDescriptor(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShapeDescriptor(struct soap *soap, const char *tag, int id, struct ns2__ShapeDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShapeDescriptor);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ShapeDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ShapeDescriptor ** SOAP_FMAC4 soap_in_PointerTons2__ShapeDescriptor(struct soap *soap, const char *tag, struct ns2__ShapeDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ShapeDescriptor **)soap_malloc(soap, sizeof(struct ns2__ShapeDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ShapeDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ShapeDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShapeDescriptor, sizeof(struct ns2__ShapeDescriptor), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShapeDescriptor(struct soap *soap, struct ns2__ShapeDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ShapeDescriptor);
	if (soap_out_PointerTons2__ShapeDescriptor(soap, tag?tag:"ns2:ShapeDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ShapeDescriptor ** SOAP_FMAC4 soap_get_PointerTons2__ShapeDescriptor(struct soap *soap, struct ns2__ShapeDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Transformation(struct soap *soap, struct ns2__Transformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Transformation))
		soap_serialize_ns2__Transformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Transformation(struct soap *soap, const char *tag, int id, struct ns2__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Transformation);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Transformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Transformation ** SOAP_FMAC4 soap_in_PointerTons2__Transformation(struct soap *soap, const char *tag, struct ns2__Transformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Transformation **)soap_malloc(soap, sizeof(struct ns2__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Transformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Transformation, sizeof(struct ns2__Transformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Transformation(struct soap *soap, struct ns2__Transformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Transformation);
	if (soap_out_PointerTons2__Transformation(soap, tag?tag:"ns2:Transformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Transformation ** SOAP_FMAC4 soap_get_PointerTons2__Transformation(struct soap *soap, struct ns2__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Vector(struct soap *soap, struct ns2__Vector *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Vector))
		soap_serialize_ns2__Vector(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Vector(struct soap *soap, const char *tag, int id, struct ns2__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Vector);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Vector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Vector ** SOAP_FMAC4 soap_in_PointerTons2__Vector(struct soap *soap, const char *tag, struct ns2__Vector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Vector **)soap_malloc(soap, sizeof(struct ns2__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Vector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Vector, sizeof(struct ns2__Vector), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Vector(struct soap *soap, struct ns2__Vector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Vector);
	if (soap_out_PointerTons2__Vector(soap, tag?tag:"ns2:Vector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Vector ** SOAP_FMAC4 soap_get_PointerTons2__Vector(struct soap *soap, struct ns2__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ItemListDescriptionExtension(struct soap *soap, struct ns2__ItemListDescriptionExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ItemListDescriptionExtension))
		soap_serialize_ns2__ItemListDescriptionExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, struct ns2__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ItemListDescriptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ItemListDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTons2__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct ns2__ItemListDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(struct ns2__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ItemListDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ItemListDescriptionExtension, sizeof(struct ns2__ItemListDescriptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ItemListDescriptionExtension(struct soap *soap, struct ns2__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ItemListDescriptionExtension);
	if (soap_out_PointerTons2__ItemListDescriptionExtension(soap, tag?tag:"ns2:ItemListDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTons2__ItemListDescriptionExtension(struct soap *soap, struct ns2__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ItemListDescription_ElementItemDescription(struct soap *soap, struct _ns2__ItemListDescription_ElementItemDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription))
		soap_serialize__ns2__ItemListDescription_ElementItemDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, struct _ns2__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ItemListDescription_ElementItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_ns2__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _ns2__ItemListDescription_ElementItemDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(struct _ns2__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ItemListDescription_ElementItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription, sizeof(struct _ns2__ItemListDescription_ElementItemDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ItemListDescription_ElementItemDescription(struct soap *soap, struct _ns2__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ItemListDescription_ElementItemDescription);
	if (soap_out_PointerTo_ns2__ItemListDescription_ElementItemDescription(soap, tag?tag:"ns2:ItemListDescription-ElementItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_ns2__ItemListDescription_ElementItemDescription(struct soap *soap, struct _ns2__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _ns2__ItemListDescription_SimpleItemDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription))
		soap_serialize__ns2__ItemListDescription_SimpleItemDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, struct _ns2__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ItemListDescription_SimpleItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _ns2__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(struct _ns2__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ItemListDescription_SimpleItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription, sizeof(struct _ns2__ItemListDescription_SimpleItemDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _ns2__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ItemListDescription_SimpleItemDescription);
	if (soap_out_PointerTo_ns2__ItemListDescription_SimpleItemDescription(soap, tag?tag:"ns2:ItemListDescription-SimpleItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_ns2__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _ns2__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MessageDescriptionExtension(struct soap *soap, struct ns2__MessageDescriptionExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MessageDescriptionExtension))
		soap_serialize_ns2__MessageDescriptionExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, struct ns2__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MessageDescriptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MessageDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTons2__MessageDescriptionExtension(struct soap *soap, const char *tag, struct ns2__MessageDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MessageDescriptionExtension **)soap_malloc(soap, sizeof(struct ns2__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MessageDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MessageDescriptionExtension, sizeof(struct ns2__MessageDescriptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MessageDescriptionExtension(struct soap *soap, struct ns2__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MessageDescriptionExtension);
	if (soap_out_PointerTons2__MessageDescriptionExtension(soap, tag?tag:"ns2:MessageDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTons2__MessageDescriptionExtension(struct soap *soap, struct ns2__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ItemListDescription(struct soap *soap, struct ns2__ItemListDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ItemListDescription))
		soap_serialize_ns2__ItemListDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ItemListDescription(struct soap *soap, const char *tag, int id, struct ns2__ItemListDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ItemListDescription);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ItemListDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ItemListDescription ** SOAP_FMAC4 soap_in_PointerTons2__ItemListDescription(struct soap *soap, const char *tag, struct ns2__ItemListDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ItemListDescription **)soap_malloc(soap, sizeof(struct ns2__ItemListDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ItemListDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ItemListDescription, sizeof(struct ns2__ItemListDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ItemListDescription(struct soap *soap, struct ns2__ItemListDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ItemListDescription);
	if (soap_out_PointerTons2__ItemListDescription(soap, tag?tag:"ns2:ItemListDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemListDescription ** SOAP_FMAC4 soap_get_PointerTons2__ItemListDescription(struct soap *soap, struct ns2__ItemListDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ItemListExtension(struct soap *soap, struct ns2__ItemListExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ItemListExtension))
		soap_serialize_ns2__ItemListExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ItemListExtension(struct soap *soap, const char *tag, int id, struct ns2__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ItemListExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTons2__ItemListExtension(struct soap *soap, const char *tag, struct ns2__ItemListExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ItemListExtension **)soap_malloc(soap, sizeof(struct ns2__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ItemListExtension, sizeof(struct ns2__ItemListExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ItemListExtension(struct soap *soap, struct ns2__ItemListExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ItemListExtension);
	if (soap_out_PointerTons2__ItemListExtension(soap, tag?tag:"ns2:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTons2__ItemListExtension(struct soap *soap, struct ns2__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ItemList_ElementItem(struct soap *soap, struct _ns2__ItemList_ElementItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ItemList_ElementItem))
		soap_serialize__ns2__ItemList_ElementItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _ns2__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ItemList_ElementItem);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_ns2__ItemList_ElementItem(struct soap *soap, const char *tag, struct _ns2__ItemList_ElementItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _ns2__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ItemList_ElementItem, sizeof(struct _ns2__ItemList_ElementItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ItemList_ElementItem(struct soap *soap, struct _ns2__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ItemList_ElementItem);
	if (soap_out_PointerTo_ns2__ItemList_ElementItem(soap, tag?tag:"ns2:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_ns2__ItemList_ElementItem(struct soap *soap, struct _ns2__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ItemList_SimpleItem(struct soap *soap, struct _ns2__ItemList_SimpleItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ItemList_SimpleItem))
		soap_serialize__ns2__ItemList_SimpleItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _ns2__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ItemList_SimpleItem);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_ns2__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _ns2__ItemList_SimpleItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _ns2__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ItemList_SimpleItem, sizeof(struct _ns2__ItemList_SimpleItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ItemList_SimpleItem(struct soap *soap, struct _ns2__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ItemList_SimpleItem);
	if (soap_out_PointerTo_ns2__ItemList_SimpleItem(soap, tag?tag:"ns2:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_ns2__ItemList_SimpleItem(struct soap *soap, struct _ns2__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusOptions20Extension(struct soap *soap, struct ns2__FocusOptions20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusOptions20Extension))
		soap_serialize_ns2__FocusOptions20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusOptions20Extension(struct soap *soap, const char *tag, int id, struct ns2__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusOptions20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTons2__FocusOptions20Extension(struct soap *soap, const char *tag, struct ns2__FocusOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusOptions20Extension **)soap_malloc(soap, sizeof(struct ns2__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusOptions20Extension, sizeof(struct ns2__FocusOptions20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusOptions20Extension(struct soap *soap, struct ns2__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusOptions20Extension);
	if (soap_out_PointerTons2__FocusOptions20Extension(soap, tag?tag:"ns2:FocusOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTons2__FocusOptions20Extension(struct soap *soap, struct ns2__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalanceOptions20Extension(struct soap *soap, struct ns2__WhiteBalanceOptions20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension))
		soap_serialize_ns2__WhiteBalanceOptions20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, struct ns2__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalanceOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct ns2__WhiteBalanceOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(struct ns2__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalanceOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalanceOptions20Extension, sizeof(struct ns2__WhiteBalanceOptions20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalanceOptions20Extension(struct soap *soap, struct ns2__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalanceOptions20Extension);
	if (soap_out_PointerTons2__WhiteBalanceOptions20Extension(soap, tag?tag:"ns2:WhiteBalanceOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalanceOptions20Extension(struct soap *soap, struct ns2__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusConfiguration20Extension(struct soap *soap, struct ns2__FocusConfiguration20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusConfiguration20Extension))
		soap_serialize_ns2__FocusConfiguration20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, struct ns2__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusConfiguration20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusConfiguration20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTons2__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct ns2__FocusConfiguration20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(struct ns2__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusConfiguration20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusConfiguration20Extension, sizeof(struct ns2__FocusConfiguration20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusConfiguration20Extension(struct soap *soap, struct ns2__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusConfiguration20Extension);
	if (soap_out_PointerTons2__FocusConfiguration20Extension(soap, tag?tag:"ns2:FocusConfiguration20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTons2__FocusConfiguration20Extension(struct soap *soap, struct ns2__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalance20Extension(struct soap *soap, struct ns2__WhiteBalance20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalance20Extension))
		soap_serialize_ns2__WhiteBalance20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, struct ns2__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalance20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalance20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalance20Extension(struct soap *soap, const char *tag, struct ns2__WhiteBalance20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WhiteBalance20Extension **)soap_malloc(soap, sizeof(struct ns2__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalance20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalance20Extension, sizeof(struct ns2__WhiteBalance20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalance20Extension(struct soap *soap, struct ns2__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalance20Extension);
	if (soap_out_PointerTons2__WhiteBalance20Extension(soap, tag?tag:"ns2:WhiteBalance20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalance20Extension(struct soap *soap, struct ns2__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RelativeFocusOptions20(struct soap *soap, struct ns2__RelativeFocusOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RelativeFocusOptions20))
		soap_serialize_ns2__RelativeFocusOptions20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, struct ns2__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RelativeFocusOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RelativeFocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTons2__RelativeFocusOptions20(struct soap *soap, const char *tag, struct ns2__RelativeFocusOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(struct ns2__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RelativeFocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RelativeFocusOptions20, sizeof(struct ns2__RelativeFocusOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RelativeFocusOptions20(struct soap *soap, struct ns2__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RelativeFocusOptions20);
	if (soap_out_PointerTons2__RelativeFocusOptions20(soap, tag?tag:"ns2:RelativeFocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTons2__RelativeFocusOptions20(struct soap *soap, struct ns2__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BacklightCompensationMode(struct soap *soap, enum ns2__BacklightCompensationMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__BacklightCompensationMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BacklightCompensationMode(struct soap *soap, const char *tag, int id, enum ns2__BacklightCompensationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BacklightCompensationMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BacklightCompensationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__BacklightCompensationMode ** SOAP_FMAC4 soap_in_PointerTons2__BacklightCompensationMode(struct soap *soap, const char *tag, enum ns2__BacklightCompensationMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__BacklightCompensationMode **)soap_malloc(soap, sizeof(enum ns2__BacklightCompensationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BacklightCompensationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__BacklightCompensationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BacklightCompensationMode, sizeof(enum ns2__BacklightCompensationMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BacklightCompensationMode(struct soap *soap, enum ns2__BacklightCompensationMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BacklightCompensationMode);
	if (soap_out_PointerTons2__BacklightCompensationMode(soap, tag?tag:"ns2:BacklightCompensationMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__BacklightCompensationMode ** SOAP_FMAC4 soap_get_PointerTons2__BacklightCompensationMode(struct soap *soap, enum ns2__BacklightCompensationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImagingOptions20Extension(struct soap *soap, struct ns2__ImagingOptions20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImagingOptions20Extension))
		soap_serialize_ns2__ImagingOptions20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, struct ns2__ImagingOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImagingOptions20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ImagingOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTons2__ImagingOptions20Extension(struct soap *soap, const char *tag, struct ns2__ImagingOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ImagingOptions20Extension **)soap_malloc(soap, sizeof(struct ns2__ImagingOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ImagingOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImagingOptions20Extension, sizeof(struct ns2__ImagingOptions20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImagingOptions20Extension(struct soap *soap, struct ns2__ImagingOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImagingOptions20Extension);
	if (soap_out_PointerTons2__ImagingOptions20Extension(soap, tag?tag:"ns2:ImagingOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTons2__ImagingOptions20Extension(struct soap *soap, struct ns2__ImagingOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalanceOptions20(struct soap *soap, struct ns2__WhiteBalanceOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalanceOptions20))
		soap_serialize_ns2__WhiteBalanceOptions20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, struct ns2__WhiteBalanceOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalanceOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalanceOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct ns2__WhiteBalanceOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(struct ns2__WhiteBalanceOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalanceOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalanceOptions20, sizeof(struct ns2__WhiteBalanceOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalanceOptions20(struct soap *soap, struct ns2__WhiteBalanceOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalanceOptions20);
	if (soap_out_PointerTons2__WhiteBalanceOptions20(soap, tag?tag:"ns2:WhiteBalanceOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalanceOptions20(struct soap *soap, struct ns2__WhiteBalanceOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WideDynamicRangeOptions20(struct soap *soap, struct ns2__WideDynamicRangeOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WideDynamicRangeOptions20))
		soap_serialize_ns2__WideDynamicRangeOptions20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, struct ns2__WideDynamicRangeOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WideDynamicRangeOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WideDynamicRangeOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTons2__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct ns2__WideDynamicRangeOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(struct ns2__WideDynamicRangeOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WideDynamicRangeOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WideDynamicRangeOptions20, sizeof(struct ns2__WideDynamicRangeOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WideDynamicRangeOptions20(struct soap *soap, struct ns2__WideDynamicRangeOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WideDynamicRangeOptions20);
	if (soap_out_PointerTons2__WideDynamicRangeOptions20(soap, tag?tag:"ns2:WideDynamicRangeOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTons2__WideDynamicRangeOptions20(struct soap *soap, struct ns2__WideDynamicRangeOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusOptions20(struct soap *soap, struct ns2__FocusOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusOptions20))
		soap_serialize_ns2__FocusOptions20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusOptions20(struct soap *soap, const char *tag, int id, struct ns2__FocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTons2__FocusOptions20(struct soap *soap, const char *tag, struct ns2__FocusOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusOptions20 **)soap_malloc(soap, sizeof(struct ns2__FocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusOptions20, sizeof(struct ns2__FocusOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusOptions20(struct soap *soap, struct ns2__FocusOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusOptions20);
	if (soap_out_PointerTons2__FocusOptions20(soap, tag?tag:"ns2:FocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTons2__FocusOptions20(struct soap *soap, struct ns2__FocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExposureOptions20(struct soap *soap, struct ns2__ExposureOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ExposureOptions20))
		soap_serialize_ns2__ExposureOptions20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExposureOptions20(struct soap *soap, const char *tag, int id, struct ns2__ExposureOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExposureOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ExposureOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTons2__ExposureOptions20(struct soap *soap, const char *tag, struct ns2__ExposureOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ExposureOptions20 **)soap_malloc(soap, sizeof(struct ns2__ExposureOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ExposureOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExposureOptions20, sizeof(struct ns2__ExposureOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExposureOptions20(struct soap *soap, struct ns2__ExposureOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ExposureOptions20);
	if (soap_out_PointerTons2__ExposureOptions20(soap, tag?tag:"ns2:ExposureOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTons2__ExposureOptions20(struct soap *soap, struct ns2__ExposureOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BacklightCompensationOptions20(struct soap *soap, struct ns2__BacklightCompensationOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BacklightCompensationOptions20))
		soap_serialize_ns2__BacklightCompensationOptions20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, struct ns2__BacklightCompensationOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BacklightCompensationOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BacklightCompensationOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTons2__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct ns2__BacklightCompensationOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(struct ns2__BacklightCompensationOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BacklightCompensationOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BacklightCompensationOptions20, sizeof(struct ns2__BacklightCompensationOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BacklightCompensationOptions20(struct soap *soap, struct ns2__BacklightCompensationOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BacklightCompensationOptions20);
	if (soap_out_PointerTons2__BacklightCompensationOptions20(soap, tag?tag:"ns2:BacklightCompensationOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTons2__BacklightCompensationOptions20(struct soap *soap, struct ns2__BacklightCompensationOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImagingSettingsExtension20(struct soap *soap, struct ns2__ImagingSettingsExtension20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImagingSettingsExtension20))
		soap_serialize_ns2__ImagingSettingsExtension20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, struct ns2__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImagingSettingsExtension20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ImagingSettingsExtension20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTons2__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct ns2__ImagingSettingsExtension20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(struct ns2__ImagingSettingsExtension20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ImagingSettingsExtension20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImagingSettingsExtension20, sizeof(struct ns2__ImagingSettingsExtension20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImagingSettingsExtension20(struct soap *soap, struct ns2__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImagingSettingsExtension20);
	if (soap_out_PointerTons2__ImagingSettingsExtension20(soap, tag?tag:"ns2:ImagingSettingsExtension20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTons2__ImagingSettingsExtension20(struct soap *soap, struct ns2__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalance20(struct soap *soap, struct ns2__WhiteBalance20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalance20))
		soap_serialize_ns2__WhiteBalance20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalance20(struct soap *soap, const char *tag, int id, struct ns2__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalance20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalance20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalance20(struct soap *soap, const char *tag, struct ns2__WhiteBalance20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WhiteBalance20 **)soap_malloc(soap, sizeof(struct ns2__WhiteBalance20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalance20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalance20, sizeof(struct ns2__WhiteBalance20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalance20(struct soap *soap, struct ns2__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalance20);
	if (soap_out_PointerTons2__WhiteBalance20(soap, tag?tag:"ns2:WhiteBalance20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalance20(struct soap *soap, struct ns2__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WideDynamicRange20(struct soap *soap, struct ns2__WideDynamicRange20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WideDynamicRange20))
		soap_serialize_ns2__WideDynamicRange20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WideDynamicRange20(struct soap *soap, const char *tag, int id, struct ns2__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WideDynamicRange20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WideDynamicRange20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTons2__WideDynamicRange20(struct soap *soap, const char *tag, struct ns2__WideDynamicRange20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WideDynamicRange20 **)soap_malloc(soap, sizeof(struct ns2__WideDynamicRange20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WideDynamicRange20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WideDynamicRange20, sizeof(struct ns2__WideDynamicRange20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WideDynamicRange20(struct soap *soap, struct ns2__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WideDynamicRange20);
	if (soap_out_PointerTons2__WideDynamicRange20(soap, tag?tag:"ns2:WideDynamicRange20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTons2__WideDynamicRange20(struct soap *soap, struct ns2__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusConfiguration20(struct soap *soap, struct ns2__FocusConfiguration20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusConfiguration20))
		soap_serialize_ns2__FocusConfiguration20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusConfiguration20(struct soap *soap, const char *tag, int id, struct ns2__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusConfiguration20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusConfiguration20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTons2__FocusConfiguration20(struct soap *soap, const char *tag, struct ns2__FocusConfiguration20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusConfiguration20 **)soap_malloc(soap, sizeof(struct ns2__FocusConfiguration20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusConfiguration20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusConfiguration20, sizeof(struct ns2__FocusConfiguration20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusConfiguration20(struct soap *soap, struct ns2__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusConfiguration20);
	if (soap_out_PointerTons2__FocusConfiguration20(soap, tag?tag:"ns2:FocusConfiguration20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTons2__FocusConfiguration20(struct soap *soap, struct ns2__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Exposure20(struct soap *soap, struct ns2__Exposure20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Exposure20))
		soap_serialize_ns2__Exposure20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Exposure20(struct soap *soap, const char *tag, int id, struct ns2__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Exposure20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Exposure20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Exposure20 ** SOAP_FMAC4 soap_in_PointerTons2__Exposure20(struct soap *soap, const char *tag, struct ns2__Exposure20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Exposure20 **)soap_malloc(soap, sizeof(struct ns2__Exposure20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Exposure20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Exposure20, sizeof(struct ns2__Exposure20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Exposure20(struct soap *soap, struct ns2__Exposure20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Exposure20);
	if (soap_out_PointerTons2__Exposure20(soap, tag?tag:"ns2:Exposure20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Exposure20 ** SOAP_FMAC4 soap_get_PointerTons2__Exposure20(struct soap *soap, struct ns2__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BacklightCompensation20(struct soap *soap, struct ns2__BacklightCompensation20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BacklightCompensation20))
		soap_serialize_ns2__BacklightCompensation20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BacklightCompensation20(struct soap *soap, const char *tag, int id, struct ns2__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BacklightCompensation20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BacklightCompensation20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTons2__BacklightCompensation20(struct soap *soap, const char *tag, struct ns2__BacklightCompensation20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BacklightCompensation20 **)soap_malloc(soap, sizeof(struct ns2__BacklightCompensation20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BacklightCompensation20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BacklightCompensation20, sizeof(struct ns2__BacklightCompensation20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BacklightCompensation20(struct soap *soap, struct ns2__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BacklightCompensation20);
	if (soap_out_PointerTons2__BacklightCompensation20(soap, tag?tag:"ns2:BacklightCompensation20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTons2__BacklightCompensation20(struct soap *soap, struct ns2__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusStatus20Extension(struct soap *soap, struct ns2__FocusStatus20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusStatus20Extension))
		soap_serialize_ns2__FocusStatus20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusStatus20Extension(struct soap *soap, const char *tag, int id, struct ns2__FocusStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusStatus20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusStatus20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTons2__FocusStatus20Extension(struct soap *soap, const char *tag, struct ns2__FocusStatus20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusStatus20Extension **)soap_malloc(soap, sizeof(struct ns2__FocusStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusStatus20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusStatus20Extension, sizeof(struct ns2__FocusStatus20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusStatus20Extension(struct soap *soap, struct ns2__FocusStatus20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusStatus20Extension);
	if (soap_out_PointerTons2__FocusStatus20Extension(soap, tag?tag:"ns2:FocusStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTons2__FocusStatus20Extension(struct soap *soap, struct ns2__FocusStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImagingStatus20Extension(struct soap *soap, struct ns2__ImagingStatus20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImagingStatus20Extension))
		soap_serialize_ns2__ImagingStatus20Extension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, struct ns2__ImagingStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImagingStatus20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ImagingStatus20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTons2__ImagingStatus20Extension(struct soap *soap, const char *tag, struct ns2__ImagingStatus20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ImagingStatus20Extension **)soap_malloc(soap, sizeof(struct ns2__ImagingStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ImagingStatus20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImagingStatus20Extension, sizeof(struct ns2__ImagingStatus20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImagingStatus20Extension(struct soap *soap, struct ns2__ImagingStatus20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImagingStatus20Extension);
	if (soap_out_PointerTons2__ImagingStatus20Extension(soap, tag?tag:"ns2:ImagingStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTons2__ImagingStatus20Extension(struct soap *soap, struct ns2__ImagingStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusStatus20(struct soap *soap, struct ns2__FocusStatus20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusStatus20))
		soap_serialize_ns2__FocusStatus20(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusStatus20(struct soap *soap, const char *tag, int id, struct ns2__FocusStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusStatus20);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusStatus20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTons2__FocusStatus20(struct soap *soap, const char *tag, struct ns2__FocusStatus20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusStatus20 **)soap_malloc(soap, sizeof(struct ns2__FocusStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusStatus20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusStatus20, sizeof(struct ns2__FocusStatus20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusStatus20(struct soap *soap, struct ns2__FocusStatus20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusStatus20);
	if (soap_out_PointerTons2__FocusStatus20(soap, tag?tag:"ns2:FocusStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTons2__FocusStatus20(struct soap *soap, struct ns2__FocusStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContinuousFocusOptions(struct soap *soap, struct ns2__ContinuousFocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContinuousFocusOptions))
		soap_serialize_ns2__ContinuousFocusOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, struct ns2__ContinuousFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContinuousFocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ContinuousFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTons2__ContinuousFocusOptions(struct soap *soap, const char *tag, struct ns2__ContinuousFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ContinuousFocusOptions **)soap_malloc(soap, sizeof(struct ns2__ContinuousFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ContinuousFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContinuousFocusOptions, sizeof(struct ns2__ContinuousFocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContinuousFocusOptions(struct soap *soap, struct ns2__ContinuousFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContinuousFocusOptions);
	if (soap_out_PointerTons2__ContinuousFocusOptions(soap, tag?tag:"ns2:ContinuousFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTons2__ContinuousFocusOptions(struct soap *soap, struct ns2__ContinuousFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RelativeFocusOptions(struct soap *soap, struct ns2__RelativeFocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RelativeFocusOptions))
		soap_serialize_ns2__RelativeFocusOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RelativeFocusOptions(struct soap *soap, const char *tag, int id, struct ns2__RelativeFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RelativeFocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RelativeFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions ** SOAP_FMAC4 soap_in_PointerTons2__RelativeFocusOptions(struct soap *soap, const char *tag, struct ns2__RelativeFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RelativeFocusOptions **)soap_malloc(soap, sizeof(struct ns2__RelativeFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RelativeFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RelativeFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RelativeFocusOptions, sizeof(struct ns2__RelativeFocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RelativeFocusOptions(struct soap *soap, struct ns2__RelativeFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RelativeFocusOptions);
	if (soap_out_PointerTons2__RelativeFocusOptions(soap, tag?tag:"ns2:RelativeFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelativeFocusOptions ** SOAP_FMAC4 soap_get_PointerTons2__RelativeFocusOptions(struct soap *soap, struct ns2__RelativeFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AbsoluteFocusOptions(struct soap *soap, struct ns2__AbsoluteFocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AbsoluteFocusOptions))
		soap_serialize_ns2__AbsoluteFocusOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, struct ns2__AbsoluteFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AbsoluteFocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AbsoluteFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTons2__AbsoluteFocusOptions(struct soap *soap, const char *tag, struct ns2__AbsoluteFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(struct ns2__AbsoluteFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AbsoluteFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AbsoluteFocusOptions, sizeof(struct ns2__AbsoluteFocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AbsoluteFocusOptions(struct soap *soap, struct ns2__AbsoluteFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AbsoluteFocusOptions);
	if (soap_out_PointerTons2__AbsoluteFocusOptions(soap, tag?tag:"ns2:AbsoluteFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTons2__AbsoluteFocusOptions(struct soap *soap, struct ns2__AbsoluteFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContinuousFocus(struct soap *soap, struct ns2__ContinuousFocus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContinuousFocus))
		soap_serialize_ns2__ContinuousFocus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContinuousFocus(struct soap *soap, const char *tag, int id, struct ns2__ContinuousFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContinuousFocus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ContinuousFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTons2__ContinuousFocus(struct soap *soap, const char *tag, struct ns2__ContinuousFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ContinuousFocus **)soap_malloc(soap, sizeof(struct ns2__ContinuousFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ContinuousFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContinuousFocus, sizeof(struct ns2__ContinuousFocus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContinuousFocus(struct soap *soap, struct ns2__ContinuousFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContinuousFocus);
	if (soap_out_PointerTons2__ContinuousFocus(soap, tag?tag:"ns2:ContinuousFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTons2__ContinuousFocus(struct soap *soap, struct ns2__ContinuousFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RelativeFocus(struct soap *soap, struct ns2__RelativeFocus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RelativeFocus))
		soap_serialize_ns2__RelativeFocus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RelativeFocus(struct soap *soap, const char *tag, int id, struct ns2__RelativeFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RelativeFocus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RelativeFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTons2__RelativeFocus(struct soap *soap, const char *tag, struct ns2__RelativeFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RelativeFocus **)soap_malloc(soap, sizeof(struct ns2__RelativeFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RelativeFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RelativeFocus, sizeof(struct ns2__RelativeFocus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RelativeFocus(struct soap *soap, struct ns2__RelativeFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RelativeFocus);
	if (soap_out_PointerTons2__RelativeFocus(soap, tag?tag:"ns2:RelativeFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTons2__RelativeFocus(struct soap *soap, struct ns2__RelativeFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AbsoluteFocus(struct soap *soap, struct ns2__AbsoluteFocus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AbsoluteFocus))
		soap_serialize_ns2__AbsoluteFocus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AbsoluteFocus(struct soap *soap, const char *tag, int id, struct ns2__AbsoluteFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AbsoluteFocus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AbsoluteFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTons2__AbsoluteFocus(struct soap *soap, const char *tag, struct ns2__AbsoluteFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AbsoluteFocus **)soap_malloc(soap, sizeof(struct ns2__AbsoluteFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AbsoluteFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AbsoluteFocus, sizeof(struct ns2__AbsoluteFocus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AbsoluteFocus(struct soap *soap, struct ns2__AbsoluteFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AbsoluteFocus);
	if (soap_out_PointerTons2__AbsoluteFocus(soap, tag?tag:"ns2:AbsoluteFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTons2__AbsoluteFocus(struct soap *soap, struct ns2__AbsoluteFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalanceMode(struct soap *soap, enum ns2__WhiteBalanceMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalanceMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalanceMode(struct soap *soap, const char *tag, int id, enum ns2__WhiteBalanceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalanceMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalanceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__WhiteBalanceMode ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalanceMode(struct soap *soap, const char *tag, enum ns2__WhiteBalanceMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__WhiteBalanceMode **)soap_malloc(soap, sizeof(enum ns2__WhiteBalanceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalanceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__WhiteBalanceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalanceMode, sizeof(enum ns2__WhiteBalanceMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalanceMode(struct soap *soap, enum ns2__WhiteBalanceMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalanceMode);
	if (soap_out_PointerTons2__WhiteBalanceMode(soap, tag?tag:"ns2:WhiteBalanceMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__WhiteBalanceMode ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalanceMode(struct soap *soap, enum ns2__WhiteBalanceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExposurePriority(struct soap *soap, enum ns2__ExposurePriority *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ExposurePriority);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExposurePriority(struct soap *soap, const char *tag, int id, enum ns2__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExposurePriority);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTons2__ExposurePriority(struct soap *soap, const char *tag, enum ns2__ExposurePriority **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ExposurePriority **)soap_malloc(soap, sizeof(enum ns2__ExposurePriority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ExposurePriority(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExposurePriority, sizeof(enum ns2__ExposurePriority), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExposurePriority(struct soap *soap, enum ns2__ExposurePriority *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ExposurePriority);
	if (soap_out_PointerTons2__ExposurePriority(soap, tag?tag:"ns2:ExposurePriority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTons2__ExposurePriority(struct soap *soap, enum ns2__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExposureMode(struct soap *soap, enum ns2__ExposureMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ExposureMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExposureMode(struct soap *soap, const char *tag, int id, enum ns2__ExposureMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExposureMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ExposureMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ExposureMode ** SOAP_FMAC4 soap_in_PointerTons2__ExposureMode(struct soap *soap, const char *tag, enum ns2__ExposureMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ExposureMode **)soap_malloc(soap, sizeof(enum ns2__ExposureMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ExposureMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ExposureMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExposureMode, sizeof(enum ns2__ExposureMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExposureMode(struct soap *soap, enum ns2__ExposureMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ExposureMode);
	if (soap_out_PointerTons2__ExposureMode(soap, tag?tag:"ns2:ExposureMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ExposureMode ** SOAP_FMAC4 soap_get_PointerTons2__ExposureMode(struct soap *soap, enum ns2__ExposureMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AutoFocusMode(struct soap *soap, enum ns2__AutoFocusMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__AutoFocusMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AutoFocusMode(struct soap *soap, const char *tag, int id, enum ns2__AutoFocusMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AutoFocusMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AutoFocusMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__AutoFocusMode ** SOAP_FMAC4 soap_in_PointerTons2__AutoFocusMode(struct soap *soap, const char *tag, enum ns2__AutoFocusMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__AutoFocusMode **)soap_malloc(soap, sizeof(enum ns2__AutoFocusMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AutoFocusMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__AutoFocusMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AutoFocusMode, sizeof(enum ns2__AutoFocusMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AutoFocusMode(struct soap *soap, enum ns2__AutoFocusMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AutoFocusMode);
	if (soap_out_PointerTons2__AutoFocusMode(soap, tag?tag:"ns2:AutoFocusMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AutoFocusMode ** SOAP_FMAC4 soap_get_PointerTons2__AutoFocusMode(struct soap *soap, enum ns2__AutoFocusMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WideDynamicMode(struct soap *soap, enum ns2__WideDynamicMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__WideDynamicMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WideDynamicMode(struct soap *soap, const char *tag, int id, enum ns2__WideDynamicMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WideDynamicMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WideDynamicMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__WideDynamicMode ** SOAP_FMAC4 soap_in_PointerTons2__WideDynamicMode(struct soap *soap, const char *tag, enum ns2__WideDynamicMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__WideDynamicMode **)soap_malloc(soap, sizeof(enum ns2__WideDynamicMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WideDynamicMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__WideDynamicMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WideDynamicMode, sizeof(enum ns2__WideDynamicMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WideDynamicMode(struct soap *soap, enum ns2__WideDynamicMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WideDynamicMode);
	if (soap_out_PointerTons2__WideDynamicMode(soap, tag?tag:"ns2:WideDynamicMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__WideDynamicMode ** SOAP_FMAC4 soap_get_PointerTons2__WideDynamicMode(struct soap *soap, enum ns2__WideDynamicMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalanceOptions(struct soap *soap, struct ns2__WhiteBalanceOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalanceOptions))
		soap_serialize_ns2__WhiteBalanceOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, struct ns2__WhiteBalanceOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalanceOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalanceOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalanceOptions(struct soap *soap, const char *tag, struct ns2__WhiteBalanceOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WhiteBalanceOptions **)soap_malloc(soap, sizeof(struct ns2__WhiteBalanceOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalanceOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalanceOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalanceOptions, sizeof(struct ns2__WhiteBalanceOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalanceOptions(struct soap *soap, struct ns2__WhiteBalanceOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalanceOptions);
	if (soap_out_PointerTons2__WhiteBalanceOptions(soap, tag?tag:"ns2:WhiteBalanceOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalanceOptions ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalanceOptions(struct soap *soap, struct ns2__WhiteBalanceOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WideDynamicRangeOptions(struct soap *soap, struct ns2__WideDynamicRangeOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WideDynamicRangeOptions))
		soap_serialize_ns2__WideDynamicRangeOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, struct ns2__WideDynamicRangeOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WideDynamicRangeOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WideDynamicRangeOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions ** SOAP_FMAC4 soap_in_PointerTons2__WideDynamicRangeOptions(struct soap *soap, const char *tag, struct ns2__WideDynamicRangeOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WideDynamicRangeOptions **)soap_malloc(soap, sizeof(struct ns2__WideDynamicRangeOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WideDynamicRangeOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRangeOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WideDynamicRangeOptions, sizeof(struct ns2__WideDynamicRangeOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WideDynamicRangeOptions(struct soap *soap, struct ns2__WideDynamicRangeOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WideDynamicRangeOptions);
	if (soap_out_PointerTons2__WideDynamicRangeOptions(soap, tag?tag:"ns2:WideDynamicRangeOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRangeOptions ** SOAP_FMAC4 soap_get_PointerTons2__WideDynamicRangeOptions(struct soap *soap, struct ns2__WideDynamicRangeOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusOptions(struct soap *soap, struct ns2__FocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusOptions))
		soap_serialize_ns2__FocusOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusOptions(struct soap *soap, const char *tag, int id, struct ns2__FocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusOptions ** SOAP_FMAC4 soap_in_PointerTons2__FocusOptions(struct soap *soap, const char *tag, struct ns2__FocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusOptions **)soap_malloc(soap, sizeof(struct ns2__FocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusOptions, sizeof(struct ns2__FocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusOptions(struct soap *soap, struct ns2__FocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusOptions);
	if (soap_out_PointerTons2__FocusOptions(soap, tag?tag:"ns2:FocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusOptions ** SOAP_FMAC4 soap_get_PointerTons2__FocusOptions(struct soap *soap, struct ns2__FocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExposureOptions(struct soap *soap, struct ns2__ExposureOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ExposureOptions))
		soap_serialize_ns2__ExposureOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExposureOptions(struct soap *soap, const char *tag, int id, struct ns2__ExposureOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExposureOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ExposureOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ExposureOptions ** SOAP_FMAC4 soap_in_PointerTons2__ExposureOptions(struct soap *soap, const char *tag, struct ns2__ExposureOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ExposureOptions **)soap_malloc(soap, sizeof(struct ns2__ExposureOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ExposureOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ExposureOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExposureOptions, sizeof(struct ns2__ExposureOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExposureOptions(struct soap *soap, struct ns2__ExposureOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ExposureOptions);
	if (soap_out_PointerTons2__ExposureOptions(soap, tag?tag:"ns2:ExposureOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ExposureOptions ** SOAP_FMAC4 soap_get_PointerTons2__ExposureOptions(struct soap *soap, struct ns2__ExposureOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BacklightCompensationOptions(struct soap *soap, struct ns2__BacklightCompensationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BacklightCompensationOptions))
		soap_serialize_ns2__BacklightCompensationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, struct ns2__BacklightCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BacklightCompensationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BacklightCompensationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions ** SOAP_FMAC4 soap_in_PointerTons2__BacklightCompensationOptions(struct soap *soap, const char *tag, struct ns2__BacklightCompensationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BacklightCompensationOptions **)soap_malloc(soap, sizeof(struct ns2__BacklightCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BacklightCompensationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BacklightCompensationOptions, sizeof(struct ns2__BacklightCompensationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BacklightCompensationOptions(struct soap *soap, struct ns2__BacklightCompensationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BacklightCompensationOptions);
	if (soap_out_PointerTons2__BacklightCompensationOptions(soap, tag?tag:"ns2:BacklightCompensationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensationOptions ** SOAP_FMAC4 soap_get_PointerTons2__BacklightCompensationOptions(struct soap *soap, struct ns2__BacklightCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Rectangle(struct soap *soap, struct ns2__Rectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Rectangle))
		soap_serialize_ns2__Rectangle(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Rectangle(struct soap *soap, const char *tag, int id, struct ns2__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Rectangle);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Rectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Rectangle ** SOAP_FMAC4 soap_in_PointerTons2__Rectangle(struct soap *soap, const char *tag, struct ns2__Rectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Rectangle **)soap_malloc(soap, sizeof(struct ns2__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Rectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Rectangle, sizeof(struct ns2__Rectangle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Rectangle(struct soap *soap, struct ns2__Rectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Rectangle);
	if (soap_out_PointerTons2__Rectangle(soap, tag?tag:"ns2:Rectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Rectangle ** SOAP_FMAC4 soap_get_PointerTons2__Rectangle(struct soap *soap, struct ns2__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImagingSettingsExtension(struct soap *soap, struct ns2__ImagingSettingsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImagingSettingsExtension))
		soap_serialize_ns2__ImagingSettingsExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, struct ns2__ImagingSettingsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImagingSettingsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ImagingSettingsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension ** SOAP_FMAC4 soap_in_PointerTons2__ImagingSettingsExtension(struct soap *soap, const char *tag, struct ns2__ImagingSettingsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ImagingSettingsExtension **)soap_malloc(soap, sizeof(struct ns2__ImagingSettingsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ImagingSettingsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingSettingsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImagingSettingsExtension, sizeof(struct ns2__ImagingSettingsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImagingSettingsExtension(struct soap *soap, struct ns2__ImagingSettingsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImagingSettingsExtension);
	if (soap_out_PointerTons2__ImagingSettingsExtension(soap, tag?tag:"ns2:ImagingSettingsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingSettingsExtension ** SOAP_FMAC4 soap_get_PointerTons2__ImagingSettingsExtension(struct soap *soap, struct ns2__ImagingSettingsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WhiteBalance(struct soap *soap, struct ns2__WhiteBalance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WhiteBalance))
		soap_serialize_ns2__WhiteBalance(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WhiteBalance(struct soap *soap, const char *tag, int id, struct ns2__WhiteBalance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WhiteBalance);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WhiteBalance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WhiteBalance ** SOAP_FMAC4 soap_in_PointerTons2__WhiteBalance(struct soap *soap, const char *tag, struct ns2__WhiteBalance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WhiteBalance **)soap_malloc(soap, sizeof(struct ns2__WhiteBalance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WhiteBalance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WhiteBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WhiteBalance, sizeof(struct ns2__WhiteBalance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WhiteBalance(struct soap *soap, struct ns2__WhiteBalance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WhiteBalance);
	if (soap_out_PointerTons2__WhiteBalance(soap, tag?tag:"ns2:WhiteBalance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WhiteBalance ** SOAP_FMAC4 soap_get_PointerTons2__WhiteBalance(struct soap *soap, struct ns2__WhiteBalance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__WideDynamicRange(struct soap *soap, struct ns2__WideDynamicRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__WideDynamicRange))
		soap_serialize_ns2__WideDynamicRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__WideDynamicRange(struct soap *soap, const char *tag, int id, struct ns2__WideDynamicRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__WideDynamicRange);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__WideDynamicRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__WideDynamicRange ** SOAP_FMAC4 soap_in_PointerTons2__WideDynamicRange(struct soap *soap, const char *tag, struct ns2__WideDynamicRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__WideDynamicRange **)soap_malloc(soap, sizeof(struct ns2__WideDynamicRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__WideDynamicRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__WideDynamicRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WideDynamicRange, sizeof(struct ns2__WideDynamicRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__WideDynamicRange(struct soap *soap, struct ns2__WideDynamicRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__WideDynamicRange);
	if (soap_out_PointerTons2__WideDynamicRange(soap, tag?tag:"ns2:WideDynamicRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__WideDynamicRange ** SOAP_FMAC4 soap_get_PointerTons2__WideDynamicRange(struct soap *soap, struct ns2__WideDynamicRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IrCutFilterMode(struct soap *soap, enum ns2__IrCutFilterMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__IrCutFilterMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IrCutFilterMode(struct soap *soap, const char *tag, int id, enum ns2__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IrCutFilterMode);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTons2__IrCutFilterMode(struct soap *soap, const char *tag, enum ns2__IrCutFilterMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__IrCutFilterMode **)soap_malloc(soap, sizeof(enum ns2__IrCutFilterMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IrCutFilterMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IrCutFilterMode, sizeof(enum ns2__IrCutFilterMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IrCutFilterMode(struct soap *soap, enum ns2__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IrCutFilterMode);
	if (soap_out_PointerTons2__IrCutFilterMode(soap, tag?tag:"ns2:IrCutFilterMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTons2__IrCutFilterMode(struct soap *soap, enum ns2__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusConfiguration(struct soap *soap, struct ns2__FocusConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusConfiguration))
		soap_serialize_ns2__FocusConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusConfiguration(struct soap *soap, const char *tag, int id, struct ns2__FocusConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__FocusConfiguration(struct soap *soap, const char *tag, struct ns2__FocusConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusConfiguration **)soap_malloc(soap, sizeof(struct ns2__FocusConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusConfiguration, sizeof(struct ns2__FocusConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusConfiguration(struct soap *soap, struct ns2__FocusConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusConfiguration);
	if (soap_out_PointerTons2__FocusConfiguration(soap, tag?tag:"ns2:FocusConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__FocusConfiguration(struct soap *soap, struct ns2__FocusConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Exposure(struct soap *soap, struct ns2__Exposure *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Exposure))
		soap_serialize_ns2__Exposure(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Exposure(struct soap *soap, const char *tag, int id, struct ns2__Exposure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Exposure);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Exposure(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Exposure ** SOAP_FMAC4 soap_in_PointerTons2__Exposure(struct soap *soap, const char *tag, struct ns2__Exposure **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Exposure **)soap_malloc(soap, sizeof(struct ns2__Exposure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Exposure(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Exposure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Exposure, sizeof(struct ns2__Exposure), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Exposure(struct soap *soap, struct ns2__Exposure *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Exposure);
	if (soap_out_PointerTons2__Exposure(soap, tag?tag:"ns2:Exposure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Exposure ** SOAP_FMAC4 soap_get_PointerTons2__Exposure(struct soap *soap, struct ns2__Exposure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BacklightCompensation(struct soap *soap, struct ns2__BacklightCompensation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BacklightCompensation))
		soap_serialize_ns2__BacklightCompensation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BacklightCompensation(struct soap *soap, const char *tag, int id, struct ns2__BacklightCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BacklightCompensation);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BacklightCompensation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BacklightCompensation ** SOAP_FMAC4 soap_in_PointerTons2__BacklightCompensation(struct soap *soap, const char *tag, struct ns2__BacklightCompensation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BacklightCompensation **)soap_malloc(soap, sizeof(struct ns2__BacklightCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BacklightCompensation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BacklightCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BacklightCompensation, sizeof(struct ns2__BacklightCompensation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BacklightCompensation(struct soap *soap, struct ns2__BacklightCompensation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BacklightCompensation);
	if (soap_out_PointerTons2__BacklightCompensation(soap, tag?tag:"ns2:BacklightCompensation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BacklightCompensation ** SOAP_FMAC4 soap_get_PointerTons2__BacklightCompensation(struct soap *soap, struct ns2__BacklightCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FocusStatus(struct soap *soap, struct ns2__FocusStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FocusStatus))
		soap_serialize_ns2__FocusStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FocusStatus(struct soap *soap, const char *tag, int id, struct ns2__FocusStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FocusStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FocusStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FocusStatus ** SOAP_FMAC4 soap_in_PointerTons2__FocusStatus(struct soap *soap, const char *tag, struct ns2__FocusStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FocusStatus **)soap_malloc(soap, sizeof(struct ns2__FocusStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FocusStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FocusStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FocusStatus, sizeof(struct ns2__FocusStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FocusStatus(struct soap *soap, struct ns2__FocusStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FocusStatus);
	if (soap_out_PointerTons2__FocusStatus(soap, tag?tag:"ns2:FocusStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FocusStatus ** SOAP_FMAC4 soap_get_PointerTons2__FocusStatus(struct soap *soap, struct ns2__FocusStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MoveStatus(struct soap *soap, enum ns2__MoveStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__MoveStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MoveStatus(struct soap *soap, const char *tag, int id, enum ns2__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MoveStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__MoveStatus ** SOAP_FMAC4 soap_in_PointerTons2__MoveStatus(struct soap *soap, const char *tag, enum ns2__MoveStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__MoveStatus **)soap_malloc(soap, sizeof(enum ns2__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MoveStatus, sizeof(enum ns2__MoveStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MoveStatus(struct soap *soap, enum ns2__MoveStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MoveStatus);
	if (soap_out_PointerTons2__MoveStatus(soap, tag?tag:"ns2:MoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MoveStatus ** SOAP_FMAC4 soap_get_PointerTons2__MoveStatus(struct soap *soap, enum ns2__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZMoveStatus(struct soap *soap, struct ns2__PTZMoveStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZMoveStatus))
		soap_serialize_ns2__PTZMoveStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZMoveStatus(struct soap *soap, const char *tag, int id, struct ns2__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZMoveStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZMoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTons2__PTZMoveStatus(struct soap *soap, const char *tag, struct ns2__PTZMoveStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZMoveStatus **)soap_malloc(soap, sizeof(struct ns2__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZMoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZMoveStatus, sizeof(struct ns2__PTZMoveStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZMoveStatus(struct soap *soap, struct ns2__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZMoveStatus);
	if (soap_out_PointerTons2__PTZMoveStatus(soap, tag?tag:"ns2:PTZMoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTons2__PTZMoveStatus(struct soap *soap, struct ns2__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZVector(struct soap *soap, struct ns2__PTZVector *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZVector))
		soap_serialize_ns2__PTZVector(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZVector(struct soap *soap, const char *tag, int id, struct ns2__PTZVector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZVector);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZVector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZVector ** SOAP_FMAC4 soap_in_PointerTons2__PTZVector(struct soap *soap, const char *tag, struct ns2__PTZVector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZVector **)soap_malloc(soap, sizeof(struct ns2__PTZVector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZVector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZVector, sizeof(struct ns2__PTZVector), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZVector(struct soap *soap, struct ns2__PTZVector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZVector);
	if (soap_out_PointerTons2__PTZVector(soap, tag?tag:"ns2:PTZVector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZVector ** SOAP_FMAC4 soap_get_PointerTons2__PTZVector(struct soap *soap, struct ns2__PTZVector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Vector1D(struct soap *soap, struct ns2__Vector1D *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Vector1D))
		soap_serialize_ns2__Vector1D(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Vector1D(struct soap *soap, const char *tag, int id, struct ns2__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Vector1D);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Vector1D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Vector1D ** SOAP_FMAC4 soap_in_PointerTons2__Vector1D(struct soap *soap, const char *tag, struct ns2__Vector1D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Vector1D **)soap_malloc(soap, sizeof(struct ns2__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Vector1D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Vector1D, sizeof(struct ns2__Vector1D), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Vector1D(struct soap *soap, struct ns2__Vector1D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Vector1D);
	if (soap_out_PointerTons2__Vector1D(soap, tag?tag:"ns2:Vector1D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Vector1D ** SOAP_FMAC4 soap_get_PointerTons2__Vector1D(struct soap *soap, struct ns2__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Vector2D(struct soap *soap, struct ns2__Vector2D *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Vector2D))
		soap_serialize_ns2__Vector2D(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Vector2D(struct soap *soap, const char *tag, int id, struct ns2__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Vector2D);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Vector2D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Vector2D ** SOAP_FMAC4 soap_in_PointerTons2__Vector2D(struct soap *soap, const char *tag, struct ns2__Vector2D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Vector2D **)soap_malloc(soap, sizeof(struct ns2__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Vector2D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Vector2D, sizeof(struct ns2__Vector2D), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Vector2D(struct soap *soap, struct ns2__Vector2D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Vector2D);
	if (soap_out_PointerTons2__Vector2D(soap, tag?tag:"ns2:Vector2D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Vector2D ** SOAP_FMAC4 soap_get_PointerTons2__Vector2D(struct soap *soap, struct ns2__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FloatRange(struct soap *soap, struct ns2__FloatRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FloatRange))
		soap_serialize_ns2__FloatRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FloatRange(struct soap *soap, const char *tag, int id, struct ns2__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FloatRange);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FloatRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FloatRange ** SOAP_FMAC4 soap_in_PointerTons2__FloatRange(struct soap *soap, const char *tag, struct ns2__FloatRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FloatRange **)soap_malloc(soap, sizeof(struct ns2__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FloatRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FloatRange, sizeof(struct ns2__FloatRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FloatRange(struct soap *soap, struct ns2__FloatRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FloatRange);
	if (soap_out_PointerTons2__FloatRange(soap, tag?tag:"ns2:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FloatRange ** SOAP_FMAC4 soap_get_PointerTons2__FloatRange(struct soap *soap, struct ns2__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZSpacesExtension(struct soap *soap, struct ns2__PTZSpacesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZSpacesExtension))
		soap_serialize_ns2__PTZSpacesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZSpacesExtension(struct soap *soap, const char *tag, int id, struct ns2__PTZSpacesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZSpacesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZSpacesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZSpacesExtension ** SOAP_FMAC4 soap_in_PointerTons2__PTZSpacesExtension(struct soap *soap, const char *tag, struct ns2__PTZSpacesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZSpacesExtension **)soap_malloc(soap, sizeof(struct ns2__PTZSpacesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZSpacesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZSpacesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZSpacesExtension, sizeof(struct ns2__PTZSpacesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZSpacesExtension(struct soap *soap, struct ns2__PTZSpacesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZSpacesExtension);
	if (soap_out_PointerTons2__PTZSpacesExtension(soap, tag?tag:"ns2:PTZSpacesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZSpacesExtension ** SOAP_FMAC4 soap_get_PointerTons2__PTZSpacesExtension(struct soap *soap, struct ns2__PTZSpacesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Space1DDescription(struct soap *soap, struct ns2__Space1DDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Space1DDescription))
		soap_serialize_ns2__Space1DDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Space1DDescription(struct soap *soap, const char *tag, int id, struct ns2__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Space1DDescription);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Space1DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTons2__Space1DDescription(struct soap *soap, const char *tag, struct ns2__Space1DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Space1DDescription **)soap_malloc(soap, sizeof(struct ns2__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Space1DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Space1DDescription, sizeof(struct ns2__Space1DDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Space1DDescription(struct soap *soap, struct ns2__Space1DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Space1DDescription);
	if (soap_out_PointerTons2__Space1DDescription(soap, tag?tag:"ns2:Space1DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTons2__Space1DDescription(struct soap *soap, struct ns2__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Space2DDescription(struct soap *soap, struct ns2__Space2DDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Space2DDescription))
		soap_serialize_ns2__Space2DDescription(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Space2DDescription(struct soap *soap, const char *tag, int id, struct ns2__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Space2DDescription);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Space2DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTons2__Space2DDescription(struct soap *soap, const char *tag, struct ns2__Space2DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Space2DDescription **)soap_malloc(soap, sizeof(struct ns2__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Space2DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Space2DDescription, sizeof(struct ns2__Space2DDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Space2DDescription(struct soap *soap, struct ns2__Space2DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Space2DDescription);
	if (soap_out_PointerTons2__Space2DDescription(soap, tag?tag:"ns2:Space2DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTons2__Space2DDescription(struct soap *soap, struct ns2__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DurationRange(struct soap *soap, struct ns2__DurationRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DurationRange))
		soap_serialize_ns2__DurationRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DurationRange(struct soap *soap, const char *tag, int id, struct ns2__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DurationRange);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DurationRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DurationRange ** SOAP_FMAC4 soap_in_PointerTons2__DurationRange(struct soap *soap, const char *tag, struct ns2__DurationRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DurationRange **)soap_malloc(soap, sizeof(struct ns2__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DurationRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DurationRange, sizeof(struct ns2__DurationRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DurationRange(struct soap *soap, struct ns2__DurationRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DurationRange);
	if (soap_out_PointerTons2__DurationRange(soap, tag?tag:"ns2:DurationRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DurationRange ** SOAP_FMAC4 soap_get_PointerTons2__DurationRange(struct soap *soap, struct ns2__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZSpaces(struct soap *soap, struct ns2__PTZSpaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZSpaces))
		soap_serialize_ns2__PTZSpaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZSpaces(struct soap *soap, const char *tag, int id, struct ns2__PTZSpaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZSpaces);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZSpaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZSpaces ** SOAP_FMAC4 soap_in_PointerTons2__PTZSpaces(struct soap *soap, const char *tag, struct ns2__PTZSpaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZSpaces **)soap_malloc(soap, sizeof(struct ns2__PTZSpaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZSpaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZSpaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZSpaces, sizeof(struct ns2__PTZSpaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZSpaces(struct soap *soap, struct ns2__PTZSpaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZSpaces);
	if (soap_out_PointerTons2__PTZSpaces(soap, tag?tag:"ns2:PTZSpaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZSpaces ** SOAP_FMAC4 soap_get_PointerTons2__PTZSpaces(struct soap *soap, struct ns2__PTZSpaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BinaryData(struct soap *soap, struct ns2__BinaryData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BinaryData))
		soap_serialize_ns2__BinaryData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BinaryData(struct soap *soap, const char *tag, int id, struct ns2__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BinaryData);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BinaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BinaryData ** SOAP_FMAC4 soap_in_PointerTons2__BinaryData(struct soap *soap, const char *tag, struct ns2__BinaryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BinaryData **)soap_malloc(soap, sizeof(struct ns2__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BinaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BinaryData, sizeof(struct ns2__BinaryData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BinaryData(struct soap *soap, struct ns2__BinaryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__BinaryData);
	if (soap_out_PointerTons2__BinaryData(soap, tag?tag:"ns2:BinaryData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BinaryData ** SOAP_FMAC4 soap_get_PointerTons2__BinaryData(struct soap *soap, struct ns2__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CertificateGenerationParametersExtension(struct soap *soap, struct ns2__CertificateGenerationParametersExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CertificateGenerationParametersExtension))
		soap_serialize_ns2__CertificateGenerationParametersExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, struct ns2__CertificateGenerationParametersExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CertificateGenerationParametersExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__CertificateGenerationParametersExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_in_PointerTons2__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct ns2__CertificateGenerationParametersExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__CertificateGenerationParametersExtension **)soap_malloc(soap, sizeof(struct ns2__CertificateGenerationParametersExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__CertificateGenerationParametersExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__CertificateGenerationParametersExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CertificateGenerationParametersExtension, sizeof(struct ns2__CertificateGenerationParametersExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CertificateGenerationParametersExtension(struct soap *soap, struct ns2__CertificateGenerationParametersExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CertificateGenerationParametersExtension);
	if (soap_out_PointerTons2__CertificateGenerationParametersExtension(soap, tag?tag:"ns2:CertificateGenerationParametersExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_get_PointerTons2__CertificateGenerationParametersExtension(struct soap *soap, struct ns2__CertificateGenerationParametersExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Date(struct soap *soap, struct ns2__Date *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Date))
		soap_serialize_ns2__Date(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Date(struct soap *soap, const char *tag, int id, struct ns2__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Date);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Date(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Date ** SOAP_FMAC4 soap_in_PointerTons2__Date(struct soap *soap, const char *tag, struct ns2__Date **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Date **)soap_malloc(soap, sizeof(struct ns2__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Date, sizeof(struct ns2__Date), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Date(struct soap *soap, struct ns2__Date *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Date);
	if (soap_out_PointerTons2__Date(soap, tag?tag:"ns2:Date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Date ** SOAP_FMAC4 soap_get_PointerTons2__Date(struct soap *soap, struct ns2__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Time(struct soap *soap, struct ns2__Time *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Time))
		soap_serialize_ns2__Time(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Time(struct soap *soap, const char *tag, int id, struct ns2__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Time);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Time(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Time ** SOAP_FMAC4 soap_in_PointerTons2__Time(struct soap *soap, const char *tag, struct ns2__Time **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Time **)soap_malloc(soap, sizeof(struct ns2__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Time, sizeof(struct ns2__Time), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Time(struct soap *soap, struct ns2__Time *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Time);
	if (soap_out_PointerTons2__Time(soap, tag?tag:"ns2:Time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Time ** SOAP_FMAC4 soap_get_PointerTons2__Time(struct soap *soap, struct ns2__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SystemDateTimeExtension(struct soap *soap, struct ns2__SystemDateTimeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SystemDateTimeExtension))
		soap_serialize_ns2__SystemDateTimeExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, struct ns2__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SystemDateTimeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SystemDateTimeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTons2__SystemDateTimeExtension(struct soap *soap, const char *tag, struct ns2__SystemDateTimeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SystemDateTimeExtension **)soap_malloc(soap, sizeof(struct ns2__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SystemDateTimeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SystemDateTimeExtension, sizeof(struct ns2__SystemDateTimeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SystemDateTimeExtension(struct soap *soap, struct ns2__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SystemDateTimeExtension);
	if (soap_out_PointerTons2__SystemDateTimeExtension(soap, tag?tag:"ns2:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTons2__SystemDateTimeExtension(struct soap *soap, struct ns2__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DateTime(struct soap *soap, struct ns2__DateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DateTime))
		soap_serialize_ns2__DateTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DateTime(struct soap *soap, const char *tag, int id, struct ns2__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DateTime);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DateTime ** SOAP_FMAC4 soap_in_PointerTons2__DateTime(struct soap *soap, const char *tag, struct ns2__DateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DateTime **)soap_malloc(soap, sizeof(struct ns2__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DateTime, sizeof(struct ns2__DateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DateTime(struct soap *soap, struct ns2__DateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DateTime);
	if (soap_out_PointerTons2__DateTime(soap, tag?tag:"ns2:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DateTime ** SOAP_FMAC4 soap_get_PointerTons2__DateTime(struct soap *soap, struct ns2__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TimeZone(struct soap *soap, struct ns2__TimeZone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TimeZone))
		soap_serialize_ns2__TimeZone(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TimeZone(struct soap *soap, const char *tag, int id, struct ns2__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TimeZone);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__TimeZone(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__TimeZone ** SOAP_FMAC4 soap_in_PointerTons2__TimeZone(struct soap *soap, const char *tag, struct ns2__TimeZone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__TimeZone **)soap_malloc(soap, sizeof(struct ns2__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__TimeZone(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TimeZone, sizeof(struct ns2__TimeZone), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TimeZone(struct soap *soap, struct ns2__TimeZone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TimeZone);
	if (soap_out_PointerTons2__TimeZone(soap, tag?tag:"ns2:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__TimeZone ** SOAP_FMAC4 soap_get_PointerTons2__TimeZone(struct soap *soap, struct ns2__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AttachmentData(struct soap *soap, struct ns2__AttachmentData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AttachmentData))
		soap_serialize_ns2__AttachmentData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AttachmentData(struct soap *soap, const char *tag, int id, struct ns2__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AttachmentData);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AttachmentData ** SOAP_FMAC4 soap_in_PointerTons2__AttachmentData(struct soap *soap, const char *tag, struct ns2__AttachmentData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AttachmentData **)soap_malloc(soap, sizeof(struct ns2__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AttachmentData, sizeof(struct ns2__AttachmentData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AttachmentData(struct soap *soap, struct ns2__AttachmentData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AttachmentData);
	if (soap_out_PointerTons2__AttachmentData(soap, tag?tag:"ns2:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AttachmentData ** SOAP_FMAC4 soap_get_PointerTons2__AttachmentData(struct soap *soap, struct ns2__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SystemCapabilitiesExtension(struct soap *soap, struct ns2__SystemCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SystemCapabilitiesExtension))
		soap_serialize_ns2__SystemCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SystemCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SystemCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__SystemCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SystemCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SystemCapabilitiesExtension, sizeof(struct ns2__SystemCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SystemCapabilitiesExtension(struct soap *soap, struct ns2__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SystemCapabilitiesExtension);
	if (soap_out_PointerTons2__SystemCapabilitiesExtension(soap, tag?tag:"ns2:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__SystemCapabilitiesExtension(struct soap *soap, struct ns2__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OnvifVersion(struct soap *soap, struct ns2__OnvifVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OnvifVersion))
		soap_serialize_ns2__OnvifVersion(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OnvifVersion(struct soap *soap, const char *tag, int id, struct ns2__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OnvifVersion);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__OnvifVersion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTons2__OnvifVersion(struct soap *soap, const char *tag, struct ns2__OnvifVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__OnvifVersion **)soap_malloc(soap, sizeof(struct ns2__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__OnvifVersion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OnvifVersion, sizeof(struct ns2__OnvifVersion), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OnvifVersion(struct soap *soap, struct ns2__OnvifVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OnvifVersion);
	if (soap_out_PointerTons2__OnvifVersion(soap, tag?tag:"ns2:OnvifVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTons2__OnvifVersion(struct soap *soap, struct ns2__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SecurityCapabilitiesExtension(struct soap *soap, struct ns2__SecurityCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SecurityCapabilitiesExtension))
		soap_serialize_ns2__SecurityCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SecurityCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SecurityCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__SecurityCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SecurityCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SecurityCapabilitiesExtension, sizeof(struct ns2__SecurityCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SecurityCapabilitiesExtension(struct soap *soap, struct ns2__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SecurityCapabilitiesExtension);
	if (soap_out_PointerTons2__SecurityCapabilitiesExtension(soap, tag?tag:"ns2:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__SecurityCapabilitiesExtension(struct soap *soap, struct ns2__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkCapabilitiesExtension(struct soap *soap, struct ns2__NetworkCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkCapabilitiesExtension))
		soap_serialize_ns2__NetworkCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__NetworkCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkCapabilitiesExtension, sizeof(struct ns2__NetworkCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkCapabilitiesExtension(struct soap *soap, struct ns2__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkCapabilitiesExtension);
	if (soap_out_PointerTons2__NetworkCapabilitiesExtension(soap, tag?tag:"ns2:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__NetworkCapabilitiesExtension(struct soap *soap, struct ns2__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct ns2__RealTimeStreamingCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension))
		soap_serialize_ns2__RealTimeStreamingCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RealTimeStreamingCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RealTimeStreamingCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension, sizeof(struct ns2__RealTimeStreamingCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct ns2__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"ns2:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct ns2__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ProfileCapabilities(struct soap *soap, struct ns2__ProfileCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ProfileCapabilities))
		soap_serialize_ns2__ProfileCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct ns2__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ProfileCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__ProfileCapabilities(struct soap *soap, const char *tag, struct ns2__ProfileCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ProfileCapabilities **)soap_malloc(soap, sizeof(struct ns2__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ProfileCapabilities, sizeof(struct ns2__ProfileCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ProfileCapabilities(struct soap *soap, struct ns2__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ProfileCapabilities);
	if (soap_out_PointerTons2__ProfileCapabilities(soap, tag?tag:"ns2:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__ProfileCapabilities(struct soap *soap, struct ns2__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MediaCapabilitiesExtension(struct soap *soap, struct ns2__MediaCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MediaCapabilitiesExtension))
		soap_serialize_ns2__MediaCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MediaCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MediaCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__MediaCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MediaCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MediaCapabilitiesExtension, sizeof(struct ns2__MediaCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MediaCapabilitiesExtension(struct soap *soap, struct ns2__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MediaCapabilitiesExtension);
	if (soap_out_PointerTons2__MediaCapabilitiesExtension(soap, tag?tag:"ns2:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__MediaCapabilitiesExtension(struct soap *soap, struct ns2__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RealTimeStreamingCapabilities(struct soap *soap, struct ns2__RealTimeStreamingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RealTimeStreamingCapabilities))
		soap_serialize_ns2__RealTimeStreamingCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, struct ns2__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RealTimeStreamingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RealTimeStreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct ns2__RealTimeStreamingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(struct ns2__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RealTimeStreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RealTimeStreamingCapabilities, sizeof(struct ns2__RealTimeStreamingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RealTimeStreamingCapabilities(struct soap *soap, struct ns2__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RealTimeStreamingCapabilities);
	if (soap_out_PointerTons2__RealTimeStreamingCapabilities(soap, tag?tag:"ns2:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__RealTimeStreamingCapabilities(struct soap *soap, struct ns2__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IOCapabilitiesExtension(struct soap *soap, struct ns2__IOCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IOCapabilitiesExtension))
		soap_serialize_ns2__IOCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IOCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IOCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__IOCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IOCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IOCapabilitiesExtension, sizeof(struct ns2__IOCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IOCapabilitiesExtension(struct soap *soap, struct ns2__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IOCapabilitiesExtension);
	if (soap_out_PointerTons2__IOCapabilitiesExtension(soap, tag?tag:"ns2:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__IOCapabilitiesExtension(struct soap *soap, struct ns2__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DeviceCapabilitiesExtension(struct soap *soap, struct ns2__DeviceCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DeviceCapabilitiesExtension))
		soap_serialize_ns2__DeviceCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DeviceCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DeviceCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__DeviceCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DeviceCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DeviceCapabilitiesExtension, sizeof(struct ns2__DeviceCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DeviceCapabilitiesExtension(struct soap *soap, struct ns2__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DeviceCapabilitiesExtension);
	if (soap_out_PointerTons2__DeviceCapabilitiesExtension(soap, tag?tag:"ns2:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__DeviceCapabilitiesExtension(struct soap *soap, struct ns2__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SecurityCapabilities(struct soap *soap, struct ns2__SecurityCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SecurityCapabilities))
		soap_serialize_ns2__SecurityCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct ns2__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SecurityCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__SecurityCapabilities(struct soap *soap, const char *tag, struct ns2__SecurityCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SecurityCapabilities **)soap_malloc(soap, sizeof(struct ns2__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SecurityCapabilities, sizeof(struct ns2__SecurityCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SecurityCapabilities(struct soap *soap, struct ns2__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SecurityCapabilities);
	if (soap_out_PointerTons2__SecurityCapabilities(soap, tag?tag:"ns2:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__SecurityCapabilities(struct soap *soap, struct ns2__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IOCapabilities(struct soap *soap, struct ns2__IOCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IOCapabilities))
		soap_serialize_ns2__IOCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IOCapabilities(struct soap *soap, const char *tag, int id, struct ns2__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IOCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__IOCapabilities(struct soap *soap, const char *tag, struct ns2__IOCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IOCapabilities **)soap_malloc(soap, sizeof(struct ns2__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IOCapabilities, sizeof(struct ns2__IOCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IOCapabilities(struct soap *soap, struct ns2__IOCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IOCapabilities);
	if (soap_out_PointerTons2__IOCapabilities(soap, tag?tag:"ns2:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__IOCapabilities(struct soap *soap, struct ns2__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SystemCapabilities(struct soap *soap, struct ns2__SystemCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SystemCapabilities))
		soap_serialize_ns2__SystemCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SystemCapabilities(struct soap *soap, const char *tag, int id, struct ns2__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SystemCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__SystemCapabilities(struct soap *soap, const char *tag, struct ns2__SystemCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__SystemCapabilities **)soap_malloc(soap, sizeof(struct ns2__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SystemCapabilities, sizeof(struct ns2__SystemCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SystemCapabilities(struct soap *soap, struct ns2__SystemCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SystemCapabilities);
	if (soap_out_PointerTons2__SystemCapabilities(soap, tag?tag:"ns2:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__SystemCapabilities(struct soap *soap, struct ns2__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkCapabilities(struct soap *soap, struct ns2__NetworkCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkCapabilities))
		soap_serialize_ns2__NetworkCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct ns2__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__NetworkCapabilities(struct soap *soap, const char *tag, struct ns2__NetworkCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkCapabilities **)soap_malloc(soap, sizeof(struct ns2__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkCapabilities, sizeof(struct ns2__NetworkCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkCapabilities(struct soap *soap, struct ns2__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkCapabilities);
	if (soap_out_PointerTons2__NetworkCapabilities(soap, tag?tag:"ns2:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__NetworkCapabilities(struct soap *soap, struct ns2__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CapabilitiesExtension(struct soap *soap, struct ns2__CapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CapabilitiesExtension))
		soap_serialize_ns2__CapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns2__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__CapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons2__CapabilitiesExtension(struct soap *soap, const char *tag, struct ns2__CapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__CapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns2__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__CapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CapabilitiesExtension, sizeof(struct ns2__CapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CapabilitiesExtension(struct soap *soap, struct ns2__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CapabilitiesExtension);
	if (soap_out_PointerTons2__CapabilitiesExtension(soap, tag?tag:"ns2:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons2__CapabilitiesExtension(struct soap *soap, struct ns2__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZCapabilities(struct soap *soap, struct ns2__PTZCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZCapabilities))
		soap_serialize_ns2__PTZCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZCapabilities(struct soap *soap, const char *tag, int id, struct ns2__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__PTZCapabilities(struct soap *soap, const char *tag, struct ns2__PTZCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZCapabilities **)soap_malloc(soap, sizeof(struct ns2__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZCapabilities, sizeof(struct ns2__PTZCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZCapabilities(struct soap *soap, struct ns2__PTZCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZCapabilities);
	if (soap_out_PointerTons2__PTZCapabilities(soap, tag?tag:"ns2:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__PTZCapabilities(struct soap *soap, struct ns2__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MediaCapabilities(struct soap *soap, struct ns2__MediaCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MediaCapabilities))
		soap_serialize_ns2__MediaCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MediaCapabilities(struct soap *soap, const char *tag, int id, struct ns2__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MediaCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MediaCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__MediaCapabilities(struct soap *soap, const char *tag, struct ns2__MediaCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MediaCapabilities **)soap_malloc(soap, sizeof(struct ns2__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MediaCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MediaCapabilities, sizeof(struct ns2__MediaCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MediaCapabilities(struct soap *soap, struct ns2__MediaCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MediaCapabilities);
	if (soap_out_PointerTons2__MediaCapabilities(soap, tag?tag:"ns2:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__MediaCapabilities(struct soap *soap, struct ns2__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImagingCapabilities(struct soap *soap, struct ns2__ImagingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImagingCapabilities))
		soap_serialize_ns2__ImagingCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImagingCapabilities(struct soap *soap, const char *tag, int id, struct ns2__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImagingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ImagingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__ImagingCapabilities(struct soap *soap, const char *tag, struct ns2__ImagingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ImagingCapabilities **)soap_malloc(soap, sizeof(struct ns2__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ImagingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImagingCapabilities, sizeof(struct ns2__ImagingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImagingCapabilities(struct soap *soap, struct ns2__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImagingCapabilities);
	if (soap_out_PointerTons2__ImagingCapabilities(soap, tag?tag:"ns2:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__ImagingCapabilities(struct soap *soap, struct ns2__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventCapabilities(struct soap *soap, struct ns2__EventCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventCapabilities))
		soap_serialize_ns2__EventCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventCapabilities(struct soap *soap, const char *tag, int id, struct ns2__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EventCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__EventCapabilities(struct soap *soap, const char *tag, struct ns2__EventCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__EventCapabilities **)soap_malloc(soap, sizeof(struct ns2__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EventCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventCapabilities, sizeof(struct ns2__EventCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventCapabilities(struct soap *soap, struct ns2__EventCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventCapabilities);
	if (soap_out_PointerTons2__EventCapabilities(soap, tag?tag:"ns2:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__EventCapabilities(struct soap *soap, struct ns2__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DeviceCapabilities(struct soap *soap, struct ns2__DeviceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DeviceCapabilities))
		soap_serialize_ns2__DeviceCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DeviceCapabilities(struct soap *soap, const char *tag, int id, struct ns2__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DeviceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__DeviceCapabilities(struct soap *soap, const char *tag, struct ns2__DeviceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DeviceCapabilities **)soap_malloc(soap, sizeof(struct ns2__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DeviceCapabilities, sizeof(struct ns2__DeviceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DeviceCapabilities(struct soap *soap, struct ns2__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DeviceCapabilities);
	if (soap_out_PointerTons2__DeviceCapabilities(soap, tag?tag:"ns2:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__DeviceCapabilities(struct soap *soap, struct ns2__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AnalyticsCapabilities(struct soap *soap, struct ns2__AnalyticsCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AnalyticsCapabilities))
		soap_serialize_ns2__AnalyticsCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, struct ns2__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AnalyticsCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AnalyticsCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTons2__AnalyticsCapabilities(struct soap *soap, const char *tag, struct ns2__AnalyticsCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AnalyticsCapabilities **)soap_malloc(soap, sizeof(struct ns2__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AnalyticsCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AnalyticsCapabilities, sizeof(struct ns2__AnalyticsCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AnalyticsCapabilities(struct soap *soap, struct ns2__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AnalyticsCapabilities);
	if (soap_out_PointerTons2__AnalyticsCapabilities(soap, tag?tag:"ns2:AnalyticsCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTons2__AnalyticsCapabilities(struct soap *soap, struct ns2__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPAddressFilterExtension(struct soap *soap, struct ns2__IPAddressFilterExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPAddressFilterExtension))
		soap_serialize_ns2__IPAddressFilterExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, struct ns2__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPAddressFilterExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPAddressFilterExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTons2__IPAddressFilterExtension(struct soap *soap, const char *tag, struct ns2__IPAddressFilterExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPAddressFilterExtension **)soap_malloc(soap, sizeof(struct ns2__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPAddressFilterExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPAddressFilterExtension, sizeof(struct ns2__IPAddressFilterExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPAddressFilterExtension(struct soap *soap, struct ns2__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPAddressFilterExtension);
	if (soap_out_PointerTons2__IPAddressFilterExtension(soap, tag?tag:"ns2:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTons2__IPAddressFilterExtension(struct soap *soap, struct ns2__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkZeroConfigurationExtension(struct soap *soap, struct ns2__NetworkZeroConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension))
		soap_serialize_ns2__NetworkZeroConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns2__NetworkZeroConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkZeroConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons2__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, struct ns2__NetworkZeroConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(struct ns2__NetworkZeroConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkZeroConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkZeroConfigurationExtension, sizeof(struct ns2__NetworkZeroConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkZeroConfigurationExtension(struct soap *soap, struct ns2__NetworkZeroConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkZeroConfigurationExtension);
	if (soap_out_PointerTons2__NetworkZeroConfigurationExtension(soap, tag?tag:"ns2:NetworkZeroConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons2__NetworkZeroConfigurationExtension(struct soap *soap, struct ns2__NetworkZeroConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv6DHCPConfiguration(struct soap *soap, enum ns2__IPv6DHCPConfiguration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6DHCPConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, enum ns2__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv6DHCPConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum ns2__IPv6DHCPConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(enum ns2__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv6DHCPConfiguration, sizeof(enum ns2__IPv6DHCPConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv6DHCPConfiguration(struct soap *soap, enum ns2__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv6DHCPConfiguration);
	if (soap_out_PointerTons2__IPv6DHCPConfiguration(soap, tag?tag:"ns2:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__IPv6DHCPConfiguration(struct soap *soap, enum ns2__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct ns2__NetworkInterfaceSetConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension))
		soap_serialize_ns2__NetworkInterfaceSetConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns2__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkInterfaceSetConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(struct ns2__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkInterfaceSetConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension, sizeof(struct ns2__NetworkInterfaceSetConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct ns2__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"ns2:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons2__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct ns2__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration))
		soap_serialize_ns2__IPv6NetworkInterfaceSetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct ns2__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct ns2__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct ns2__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv6NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration, sizeof(struct ns2__IPv6NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"ns2:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration))
		soap_serialize_ns2__IPv4NetworkInterfaceSetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct ns2__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct ns2__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct ns2__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv4NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration, sizeof(struct ns2__IPv4NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"ns2:IPv4NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct ns2__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DynamicDNSInformationExtension(struct soap *soap, struct ns2__DynamicDNSInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DynamicDNSInformationExtension))
		soap_serialize_ns2__DynamicDNSInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, struct ns2__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DynamicDNSInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DynamicDNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTons2__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct ns2__DynamicDNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(struct ns2__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DynamicDNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DynamicDNSInformationExtension, sizeof(struct ns2__DynamicDNSInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DynamicDNSInformationExtension(struct soap *soap, struct ns2__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DynamicDNSInformationExtension);
	if (soap_out_PointerTons2__DynamicDNSInformationExtension(soap, tag?tag:"ns2:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTons2__DynamicDNSInformationExtension(struct soap *soap, struct ns2__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NTPInformationExtension(struct soap *soap, struct ns2__NTPInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NTPInformationExtension))
		soap_serialize_ns2__NTPInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NTPInformationExtension(struct soap *soap, const char *tag, int id, struct ns2__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NTPInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NTPInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTons2__NTPInformationExtension(struct soap *soap, const char *tag, struct ns2__NTPInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NTPInformationExtension **)soap_malloc(soap, sizeof(struct ns2__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NTPInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NTPInformationExtension, sizeof(struct ns2__NTPInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NTPInformationExtension(struct soap *soap, struct ns2__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NTPInformationExtension);
	if (soap_out_PointerTons2__NTPInformationExtension(soap, tag?tag:"ns2:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTons2__NTPInformationExtension(struct soap *soap, struct ns2__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkHost(struct soap *soap, struct ns2__NetworkHost *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkHost))
		soap_serialize_ns2__NetworkHost(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkHost(struct soap *soap, const char *tag, int id, struct ns2__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkHost);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkHost(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkHost ** SOAP_FMAC4 soap_in_PointerTons2__NetworkHost(struct soap *soap, const char *tag, struct ns2__NetworkHost **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkHost **)soap_malloc(soap, sizeof(struct ns2__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkHost(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkHost, sizeof(struct ns2__NetworkHost), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkHost(struct soap *soap, struct ns2__NetworkHost *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkHost);
	if (soap_out_PointerTons2__NetworkHost(soap, tag?tag:"ns2:NetworkHost", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkHost ** SOAP_FMAC4 soap_get_PointerTons2__NetworkHost(struct soap *soap, struct ns2__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DNSInformationExtension(struct soap *soap, struct ns2__DNSInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DNSInformationExtension))
		soap_serialize_ns2__DNSInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DNSInformationExtension(struct soap *soap, const char *tag, int id, struct ns2__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DNSInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTons2__DNSInformationExtension(struct soap *soap, const char *tag, struct ns2__DNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DNSInformationExtension **)soap_malloc(soap, sizeof(struct ns2__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DNSInformationExtension, sizeof(struct ns2__DNSInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DNSInformationExtension(struct soap *soap, struct ns2__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DNSInformationExtension);
	if (soap_out_PointerTons2__DNSInformationExtension(soap, tag?tag:"ns2:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTons2__DNSInformationExtension(struct soap *soap, struct ns2__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__token);
	if (soap_out_PointerToxsd__token(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HostnameInformationExtension(struct soap *soap, struct ns2__HostnameInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HostnameInformationExtension))
		soap_serialize_ns2__HostnameInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HostnameInformationExtension(struct soap *soap, const char *tag, int id, struct ns2__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HostnameInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__HostnameInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTons2__HostnameInformationExtension(struct soap *soap, const char *tag, struct ns2__HostnameInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__HostnameInformationExtension **)soap_malloc(soap, sizeof(struct ns2__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__HostnameInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HostnameInformationExtension, sizeof(struct ns2__HostnameInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HostnameInformationExtension(struct soap *soap, struct ns2__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HostnameInformationExtension);
	if (soap_out_PointerTons2__HostnameInformationExtension(soap, tag?tag:"ns2:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTons2__HostnameInformationExtension(struct soap *soap, struct ns2__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkHostExtension(struct soap *soap, struct ns2__NetworkHostExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkHostExtension))
		soap_serialize_ns2__NetworkHostExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkHostExtension(struct soap *soap, const char *tag, int id, struct ns2__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkHostExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkHostExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTons2__NetworkHostExtension(struct soap *soap, const char *tag, struct ns2__NetworkHostExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkHostExtension **)soap_malloc(soap, sizeof(struct ns2__NetworkHostExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkHostExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkHostExtension, sizeof(struct ns2__NetworkHostExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkHostExtension(struct soap *soap, struct ns2__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkHostExtension);
	if (soap_out_PointerTons2__NetworkHostExtension(soap, tag?tag:"ns2:NetworkHostExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTons2__NetworkHostExtension(struct soap *soap, struct ns2__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DNSName(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DNSName))
		soap_serialize_ns2__DNSName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DNSName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DNSName);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DNSName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons2__DNSName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DNSName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DNSName, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DNSName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DNSName);
	if (soap_out_PointerTons2__DNSName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons2__DNSName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv6Address(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6Address))
		soap_serialize_ns2__IPv6Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv6Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons2__IPv6Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv6Address, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv6Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv6Address);
	if (soap_out_PointerTons2__IPv6Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons2__IPv6Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv4Address(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv4Address))
		soap_serialize_ns2__IPv4Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv4Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons2__IPv4Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv4Address, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv4Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv4Address);
	if (soap_out_PointerTons2__IPv4Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons2__IPv4Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkProtocolExtension(struct soap *soap, struct ns2__NetworkProtocolExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkProtocolExtension))
		soap_serialize_ns2__NetworkProtocolExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, struct ns2__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkProtocolExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkProtocolExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTons2__NetworkProtocolExtension(struct soap *soap, const char *tag, struct ns2__NetworkProtocolExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkProtocolExtension **)soap_malloc(soap, sizeof(struct ns2__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkProtocolExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkProtocolExtension, sizeof(struct ns2__NetworkProtocolExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkProtocolExtension(struct soap *soap, struct ns2__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkProtocolExtension);
	if (soap_out_PointerTons2__NetworkProtocolExtension(soap, tag?tag:"ns2:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTons2__NetworkProtocolExtension(struct soap *soap, struct ns2__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv6ConfigurationExtension(struct soap *soap, struct ns2__IPv6ConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6ConfigurationExtension))
		soap_serialize_ns2__IPv6ConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns2__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv6ConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv6ConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons2__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct ns2__IPv6ConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(struct ns2__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv6ConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv6ConfigurationExtension, sizeof(struct ns2__IPv6ConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv6ConfigurationExtension(struct soap *soap, struct ns2__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv6ConfigurationExtension);
	if (soap_out_PointerTons2__IPv6ConfigurationExtension(soap, tag?tag:"ns2:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons2__IPv6ConfigurationExtension(struct soap *soap, struct ns2__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PrefixedIPv6Address(struct soap *soap, struct ns2__PrefixedIPv6Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PrefixedIPv6Address))
		soap_serialize_ns2__PrefixedIPv6Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, struct ns2__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PrefixedIPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PrefixedIPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTons2__PrefixedIPv6Address(struct soap *soap, const char *tag, struct ns2__PrefixedIPv6Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PrefixedIPv6Address **)soap_malloc(soap, sizeof(struct ns2__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PrefixedIPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PrefixedIPv6Address, sizeof(struct ns2__PrefixedIPv6Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PrefixedIPv6Address(struct soap *soap, struct ns2__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PrefixedIPv6Address);
	if (soap_out_PointerTons2__PrefixedIPv6Address(soap, tag?tag:"ns2:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTons2__PrefixedIPv6Address(struct soap *soap, struct ns2__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PrefixedIPv4Address(struct soap *soap, struct ns2__PrefixedIPv4Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PrefixedIPv4Address))
		soap_serialize_ns2__PrefixedIPv4Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, struct ns2__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PrefixedIPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PrefixedIPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTons2__PrefixedIPv4Address(struct soap *soap, const char *tag, struct ns2__PrefixedIPv4Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PrefixedIPv4Address **)soap_malloc(soap, sizeof(struct ns2__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PrefixedIPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PrefixedIPv4Address, sizeof(struct ns2__PrefixedIPv4Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PrefixedIPv4Address(struct soap *soap, struct ns2__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PrefixedIPv4Address);
	if (soap_out_PointerTons2__PrefixedIPv4Address(soap, tag?tag:"ns2:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTons2__PrefixedIPv4Address(struct soap *soap, struct ns2__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv4Configuration(struct soap *soap, struct ns2__IPv4Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv4Configuration))
		soap_serialize_ns2__IPv4Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv4Configuration(struct soap *soap, const char *tag, int id, struct ns2__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv4Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTons2__IPv4Configuration(struct soap *soap, const char *tag, struct ns2__IPv4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv4Configuration **)soap_malloc(soap, sizeof(struct ns2__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv4Configuration, sizeof(struct ns2__IPv4Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv4Configuration(struct soap *soap, struct ns2__IPv4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv4Configuration);
	if (soap_out_PointerTons2__IPv4Configuration(soap, tag?tag:"ns2:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTons2__IPv4Configuration(struct soap *soap, struct ns2__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPv6Configuration(struct soap *soap, struct ns2__IPv6Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6Configuration))
		soap_serialize_ns2__IPv6Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPv6Configuration(struct soap *soap, const char *tag, int id, struct ns2__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPv6Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPv6Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTons2__IPv6Configuration(struct soap *soap, const char *tag, struct ns2__IPv6Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPv6Configuration **)soap_malloc(soap, sizeof(struct ns2__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPv6Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPv6Configuration, sizeof(struct ns2__IPv6Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPv6Configuration(struct soap *soap, struct ns2__IPv6Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPv6Configuration);
	if (soap_out_PointerTons2__IPv6Configuration(soap, tag?tag:"ns2:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTons2__IPv6Configuration(struct soap *soap, struct ns2__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NetworkInterfaceConnectionSetting(struct soap *soap, struct ns2__NetworkInterfaceConnectionSetting *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting))
		soap_serialize_ns2__NetworkInterfaceConnectionSetting(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, struct ns2__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__NetworkInterfaceConnectionSetting(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTons2__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct ns2__NetworkInterfaceConnectionSetting **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(struct ns2__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__NetworkInterfaceConnectionSetting(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting, sizeof(struct ns2__NetworkInterfaceConnectionSetting), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NetworkInterfaceConnectionSetting(struct soap *soap, struct ns2__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NetworkInterfaceConnectionSetting);
	if (soap_out_PointerTons2__NetworkInterfaceConnectionSetting(soap, tag?tag:"ns2:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTons2__NetworkInterfaceConnectionSetting(struct soap *soap, struct ns2__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Transport(struct soap *soap, struct ns2__Transport *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Transport))
		soap_serialize_ns2__Transport(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Transport(struct soap *soap, const char *tag, int id, struct ns2__Transport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Transport);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Transport(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Transport ** SOAP_FMAC4 soap_in_PointerTons2__Transport(struct soap *soap, const char *tag, struct ns2__Transport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Transport **)soap_malloc(soap, sizeof(struct ns2__Transport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Transport(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Transport, sizeof(struct ns2__Transport), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Transport(struct soap *soap, struct ns2__Transport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Transport);
	if (soap_out_PointerTons2__Transport(soap, tag?tag:"ns2:Transport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Transport ** SOAP_FMAC4 soap_get_PointerTons2__Transport(struct soap *soap, struct ns2__Transport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IPAddress(struct soap *soap, struct ns2__IPAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IPAddress))
		soap_serialize_ns2__IPAddress(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IPAddress(struct soap *soap, const char *tag, int id, struct ns2__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IPAddress);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IPAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IPAddress ** SOAP_FMAC4 soap_in_PointerTons2__IPAddress(struct soap *soap, const char *tag, struct ns2__IPAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IPAddress **)soap_malloc(soap, sizeof(struct ns2__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IPAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IPAddress, sizeof(struct ns2__IPAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IPAddress(struct soap *soap, struct ns2__IPAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IPAddress);
	if (soap_out_PointerTons2__IPAddress(soap, tag?tag:"ns2:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IPAddress ** SOAP_FMAC4 soap_get_PointerTons2__IPAddress(struct soap *soap, struct ns2__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZStatusFilterOptions(struct soap *soap, struct ns2__PTZStatusFilterOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZStatusFilterOptions))
		soap_serialize_ns2__PTZStatusFilterOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, struct ns2__PTZStatusFilterOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZStatusFilterOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZStatusFilterOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZStatusFilterOptions ** SOAP_FMAC4 soap_in_PointerTons2__PTZStatusFilterOptions(struct soap *soap, const char *tag, struct ns2__PTZStatusFilterOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZStatusFilterOptions **)soap_malloc(soap, sizeof(struct ns2__PTZStatusFilterOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZStatusFilterOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZStatusFilterOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZStatusFilterOptions, sizeof(struct ns2__PTZStatusFilterOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZStatusFilterOptions(struct soap *soap, struct ns2__PTZStatusFilterOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZStatusFilterOptions);
	if (soap_out_PointerTons2__PTZStatusFilterOptions(soap, tag?tag:"ns2:PTZStatusFilterOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZStatusFilterOptions ** SOAP_FMAC4 soap_get_PointerTons2__PTZStatusFilterOptions(struct soap *soap, struct ns2__PTZStatusFilterOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _ns2__EventSubscription_SubscriptionPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy))
		soap_serialize__ns2__EventSubscription_SubscriptionPolicy(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _ns2__EventSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__EventSubscription_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _ns2__EventSubscription_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _ns2__EventSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__EventSubscription_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy, sizeof(struct _ns2__EventSubscription_SubscriptionPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _ns2__EventSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__EventSubscription_SubscriptionPolicy);
	if (soap_out_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, tag?tag:"ns2:EventSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns2__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _ns2__EventSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FilterType(struct soap *soap, struct ns2__FilterType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FilterType))
		soap_serialize_ns2__FilterType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FilterType(struct soap *soap, const char *tag, int id, struct ns2__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FilterType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FilterType ** SOAP_FMAC4 soap_in_PointerTons2__FilterType(struct soap *soap, const char *tag, struct ns2__FilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FilterType **)soap_malloc(soap, sizeof(struct ns2__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FilterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FilterType, sizeof(struct ns2__FilterType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FilterType(struct soap *soap, struct ns2__FilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FilterType);
	if (soap_out_PointerTons2__FilterType(soap, tag?tag:"ns2:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FilterType ** SOAP_FMAC4 soap_get_PointerTons2__FilterType(struct soap *soap, struct ns2__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IntList(struct soap *soap, struct ns2__IntList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IntList))
		soap_serialize_ns2__IntList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IntList(struct soap *soap, const char *tag, int id, struct ns2__IntList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IntList);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IntList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IntList ** SOAP_FMAC4 soap_in_PointerTons2__IntList(struct soap *soap, const char *tag, struct ns2__IntList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IntList **)soap_malloc(soap, sizeof(struct ns2__IntList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IntList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IntList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IntList, sizeof(struct ns2__IntList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IntList(struct soap *soap, struct ns2__IntList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IntList);
	if (soap_out_PointerTons2__IntList(soap, tag?tag:"ns2:IntList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntList ** SOAP_FMAC4 soap_get_PointerTons2__IntList(struct soap *soap, struct ns2__IntList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AudioEncoderConfigurationOption(struct soap *soap, struct ns2__AudioEncoderConfigurationOption *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AudioEncoderConfigurationOption))
		soap_serialize_ns2__AudioEncoderConfigurationOption(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, struct ns2__AudioEncoderConfigurationOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AudioEncoderConfigurationOption);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AudioEncoderConfigurationOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_in_PointerTons2__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, struct ns2__AudioEncoderConfigurationOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AudioEncoderConfigurationOption **)soap_malloc(soap, sizeof(struct ns2__AudioEncoderConfigurationOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AudioEncoderConfigurationOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioEncoderConfigurationOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AudioEncoderConfigurationOption, sizeof(struct ns2__AudioEncoderConfigurationOption), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AudioEncoderConfigurationOption(struct soap *soap, struct ns2__AudioEncoderConfigurationOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AudioEncoderConfigurationOption);
	if (soap_out_PointerTons2__AudioEncoderConfigurationOption(soap, tag?tag:"ns2:AudioEncoderConfigurationOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_get_PointerTons2__AudioEncoderConfigurationOption(struct soap *soap, struct ns2__AudioEncoderConfigurationOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AudioSourceOptionsExtension(struct soap *soap, struct ns2__AudioSourceOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AudioSourceOptionsExtension))
		soap_serialize_ns2__AudioSourceOptionsExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, struct ns2__AudioSourceOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AudioSourceOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AudioSourceOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_in_PointerTons2__AudioSourceOptionsExtension(struct soap *soap, const char *tag, struct ns2__AudioSourceOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AudioSourceOptionsExtension **)soap_malloc(soap, sizeof(struct ns2__AudioSourceOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AudioSourceOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioSourceOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AudioSourceOptionsExtension, sizeof(struct ns2__AudioSourceOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AudioSourceOptionsExtension(struct soap *soap, struct ns2__AudioSourceOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AudioSourceOptionsExtension);
	if (soap_out_PointerTons2__AudioSourceOptionsExtension(soap, tag?tag:"ns2:AudioSourceOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_get_PointerTons2__AudioSourceOptionsExtension(struct soap *soap, struct ns2__AudioSourceOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__H264Profile(struct soap *soap, enum ns2__H264Profile *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__H264Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__H264Profile(struct soap *soap, const char *tag, int id, enum ns2__H264Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__H264Profile);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__H264Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__H264Profile ** SOAP_FMAC4 soap_in_PointerTons2__H264Profile(struct soap *soap, const char *tag, enum ns2__H264Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__H264Profile **)soap_malloc(soap, sizeof(enum ns2__H264Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__H264Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__H264Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__H264Profile, sizeof(enum ns2__H264Profile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__H264Profile(struct soap *soap, enum ns2__H264Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__H264Profile);
	if (soap_out_PointerTons2__H264Profile(soap, tag?tag:"ns2:H264Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__H264Profile ** SOAP_FMAC4 soap_get_PointerTons2__H264Profile(struct soap *soap, enum ns2__H264Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Mpeg4Profile(struct soap *soap, enum ns2__Mpeg4Profile *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__Mpeg4Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Mpeg4Profile(struct soap *soap, const char *tag, int id, enum ns2__Mpeg4Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Mpeg4Profile);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Mpeg4Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__Mpeg4Profile ** SOAP_FMAC4 soap_in_PointerTons2__Mpeg4Profile(struct soap *soap, const char *tag, enum ns2__Mpeg4Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__Mpeg4Profile **)soap_malloc(soap, sizeof(enum ns2__Mpeg4Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Mpeg4Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__Mpeg4Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Mpeg4Profile, sizeof(enum ns2__Mpeg4Profile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Mpeg4Profile(struct soap *soap, enum ns2__Mpeg4Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Mpeg4Profile);
	if (soap_out_PointerTons2__Mpeg4Profile(soap, tag?tag:"ns2:Mpeg4Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Mpeg4Profile ** SOAP_FMAC4 soap_get_PointerTons2__Mpeg4Profile(struct soap *soap, enum ns2__Mpeg4Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoResolution(struct soap *soap, struct ns2__VideoResolution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoResolution))
		soap_serialize_ns2__VideoResolution(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoResolution(struct soap *soap, const char *tag, int id, struct ns2__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoResolution);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoResolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoResolution ** SOAP_FMAC4 soap_in_PointerTons2__VideoResolution(struct soap *soap, const char *tag, struct ns2__VideoResolution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoResolution **)soap_malloc(soap, sizeof(struct ns2__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoResolution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoResolution, sizeof(struct ns2__VideoResolution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoResolution(struct soap *soap, struct ns2__VideoResolution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoResolution);
	if (soap_out_PointerTons2__VideoResolution(soap, tag?tag:"ns2:VideoResolution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoResolution ** SOAP_FMAC4 soap_get_PointerTons2__VideoResolution(struct soap *soap, struct ns2__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoEncoderOptionsExtension(struct soap *soap, struct ns2__VideoEncoderOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoEncoderOptionsExtension))
		soap_serialize_ns2__VideoEncoderOptionsExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, struct ns2__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoEncoderOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoEncoderOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTons2__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct ns2__VideoEncoderOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(struct ns2__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoEncoderOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoEncoderOptionsExtension, sizeof(struct ns2__VideoEncoderOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoEncoderOptionsExtension(struct soap *soap, struct ns2__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoEncoderOptionsExtension);
	if (soap_out_PointerTons2__VideoEncoderOptionsExtension(soap, tag?tag:"ns2:VideoEncoderOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTons2__VideoEncoderOptionsExtension(struct soap *soap, struct ns2__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__H264Options(struct soap *soap, struct ns2__H264Options *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__H264Options))
		soap_serialize_ns2__H264Options(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__H264Options(struct soap *soap, const char *tag, int id, struct ns2__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__H264Options);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__H264Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__H264Options ** SOAP_FMAC4 soap_in_PointerTons2__H264Options(struct soap *soap, const char *tag, struct ns2__H264Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__H264Options **)soap_malloc(soap, sizeof(struct ns2__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__H264Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__H264Options, sizeof(struct ns2__H264Options), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__H264Options(struct soap *soap, struct ns2__H264Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__H264Options);
	if (soap_out_PointerTons2__H264Options(soap, tag?tag:"ns2:H264Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__H264Options ** SOAP_FMAC4 soap_get_PointerTons2__H264Options(struct soap *soap, struct ns2__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Mpeg4Options(struct soap *soap, struct ns2__Mpeg4Options *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Mpeg4Options))
		soap_serialize_ns2__Mpeg4Options(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Mpeg4Options(struct soap *soap, const char *tag, int id, struct ns2__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Mpeg4Options);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Mpeg4Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTons2__Mpeg4Options(struct soap *soap, const char *tag, struct ns2__Mpeg4Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Mpeg4Options **)soap_malloc(soap, sizeof(struct ns2__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Mpeg4Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Mpeg4Options, sizeof(struct ns2__Mpeg4Options), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Mpeg4Options(struct soap *soap, struct ns2__Mpeg4Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Mpeg4Options);
	if (soap_out_PointerTons2__Mpeg4Options(soap, tag?tag:"ns2:Mpeg4Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTons2__Mpeg4Options(struct soap *soap, struct ns2__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__JpegOptions(struct soap *soap, struct ns2__JpegOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__JpegOptions))
		soap_serialize_ns2__JpegOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__JpegOptions(struct soap *soap, const char *tag, int id, struct ns2__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__JpegOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__JpegOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__JpegOptions ** SOAP_FMAC4 soap_in_PointerTons2__JpegOptions(struct soap *soap, const char *tag, struct ns2__JpegOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__JpegOptions **)soap_malloc(soap, sizeof(struct ns2__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__JpegOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__JpegOptions, sizeof(struct ns2__JpegOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__JpegOptions(struct soap *soap, struct ns2__JpegOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__JpegOptions);
	if (soap_out_PointerTons2__JpegOptions(soap, tag?tag:"ns2:JpegOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__JpegOptions ** SOAP_FMAC4 soap_get_PointerTons2__JpegOptions(struct soap *soap, struct ns2__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct ns2__VideoSourceConfigurationOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension))
		soap_serialize_ns2__VideoSourceConfigurationOptionsExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct ns2__VideoSourceConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoSourceConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTons2__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct ns2__VideoSourceConfigurationOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct ns2__VideoSourceConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoSourceConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension, sizeof(struct ns2__VideoSourceConfigurationOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct ns2__VideoSourceConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoSourceConfigurationOptionsExtension);
	if (soap_out_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, tag?tag:"ns2:VideoSourceConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTons2__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct ns2__VideoSourceConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReferenceToken(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReferenceToken))
		soap_serialize_ns2__ReferenceToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReferenceToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReferenceToken);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons2__ReferenceToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReferenceToken, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReferenceToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReferenceToken);
	if (soap_out_PointerTons2__ReferenceToken(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons2__ReferenceToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IntRectangleRange(struct soap *soap, struct ns2__IntRectangleRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IntRectangleRange))
		soap_serialize_ns2__IntRectangleRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IntRectangleRange(struct soap *soap, const char *tag, int id, struct ns2__IntRectangleRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IntRectangleRange);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IntRectangleRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IntRectangleRange ** SOAP_FMAC4 soap_in_PointerTons2__IntRectangleRange(struct soap *soap, const char *tag, struct ns2__IntRectangleRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IntRectangleRange **)soap_malloc(soap, sizeof(struct ns2__IntRectangleRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IntRectangleRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IntRectangleRange, sizeof(struct ns2__IntRectangleRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IntRectangleRange(struct soap *soap, struct ns2__IntRectangleRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IntRectangleRange);
	if (soap_out_PointerTons2__IntRectangleRange(soap, tag?tag:"ns2:IntRectangleRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntRectangleRange ** SOAP_FMAC4 soap_get_PointerTons2__IntRectangleRange(struct soap *soap, struct ns2__IntRectangleRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ProfileExtension(struct soap *soap, struct ns2__ProfileExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ProfileExtension))
		soap_serialize_ns2__ProfileExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ProfileExtension(struct soap *soap, const char *tag, int id, struct ns2__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ProfileExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ProfileExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTons2__ProfileExtension(struct soap *soap, const char *tag, struct ns2__ProfileExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ProfileExtension **)soap_malloc(soap, sizeof(struct ns2__ProfileExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ProfileExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ProfileExtension, sizeof(struct ns2__ProfileExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ProfileExtension(struct soap *soap, struct ns2__ProfileExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ProfileExtension);
	if (soap_out_PointerTons2__ProfileExtension(soap, tag?tag:"ns2:ProfileExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTons2__ProfileExtension(struct soap *soap, struct ns2__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MetadataConfiguration(struct soap *soap, struct ns2__MetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MetadataConfiguration))
		soap_serialize_ns2__MetadataConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MetadataConfiguration(struct soap *soap, const char *tag, int id, struct ns2__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__MetadataConfiguration(struct soap *soap, const char *tag, struct ns2__MetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MetadataConfiguration **)soap_malloc(soap, sizeof(struct ns2__MetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MetadataConfiguration, sizeof(struct ns2__MetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MetadataConfiguration(struct soap *soap, struct ns2__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MetadataConfiguration);
	if (soap_out_PointerTons2__MetadataConfiguration(soap, tag?tag:"ns2:MetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__MetadataConfiguration(struct soap *soap, struct ns2__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PTZConfiguration(struct soap *soap, struct ns2__PTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PTZConfiguration))
		soap_serialize_ns2__PTZConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PTZConfiguration(struct soap *soap, const char *tag, int id, struct ns2__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__PTZConfiguration(struct soap *soap, const char *tag, struct ns2__PTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__PTZConfiguration **)soap_malloc(soap, sizeof(struct ns2__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PTZConfiguration, sizeof(struct ns2__PTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PTZConfiguration(struct soap *soap, struct ns2__PTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PTZConfiguration);
	if (soap_out_PointerTons2__PTZConfiguration(soap, tag?tag:"ns2:PTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__PTZConfiguration(struct soap *soap, struct ns2__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoAnalyticsConfiguration(struct soap *soap, struct ns2__VideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoAnalyticsConfiguration))
		soap_serialize_ns2__VideoAnalyticsConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct ns2__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct ns2__VideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct ns2__VideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoAnalyticsConfiguration, sizeof(struct ns2__VideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoAnalyticsConfiguration(struct soap *soap, struct ns2__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoAnalyticsConfiguration);
	if (soap_out_PointerTons2__VideoAnalyticsConfiguration(soap, tag?tag:"ns2:VideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__VideoAnalyticsConfiguration(struct soap *soap, struct ns2__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AudioEncoderConfiguration(struct soap *soap, struct ns2__AudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AudioEncoderConfiguration))
		soap_serialize_ns2__AudioEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct ns2__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct ns2__AudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct ns2__AudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AudioEncoderConfiguration, sizeof(struct ns2__AudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AudioEncoderConfiguration(struct soap *soap, struct ns2__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AudioEncoderConfiguration);
	if (soap_out_PointerTons2__AudioEncoderConfiguration(soap, tag?tag:"ns2:AudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__AudioEncoderConfiguration(struct soap *soap, struct ns2__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AudioSourceConfiguration(struct soap *soap, struct ns2__AudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AudioSourceConfiguration))
		soap_serialize_ns2__AudioSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct ns2__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__AudioSourceConfiguration(struct soap *soap, const char *tag, struct ns2__AudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AudioSourceConfiguration **)soap_malloc(soap, sizeof(struct ns2__AudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AudioSourceConfiguration, sizeof(struct ns2__AudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AudioSourceConfiguration(struct soap *soap, struct ns2__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AudioSourceConfiguration);
	if (soap_out_PointerTons2__AudioSourceConfiguration(soap, tag?tag:"ns2:AudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__AudioSourceConfiguration(struct soap *soap, struct ns2__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoSourceConfiguration(struct soap *soap, struct ns2__VideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoSourceConfiguration))
		soap_serialize_ns2__VideoSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct ns2__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__VideoSourceConfiguration(struct soap *soap, const char *tag, struct ns2__VideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoSourceConfiguration **)soap_malloc(soap, sizeof(struct ns2__VideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoSourceConfiguration, sizeof(struct ns2__VideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoSourceConfiguration(struct soap *soap, struct ns2__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoSourceConfiguration);
	if (soap_out_PointerTons2__VideoSourceConfiguration(soap, tag?tag:"ns2:VideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__VideoSourceConfiguration(struct soap *soap, struct ns2__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IntRange(struct soap *soap, struct ns2__IntRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IntRange))
		soap_serialize_ns2__IntRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IntRange(struct soap *soap, const char *tag, int id, struct ns2__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IntRange);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IntRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IntRange ** SOAP_FMAC4 soap_in_PointerTons2__IntRange(struct soap *soap, const char *tag, struct ns2__IntRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IntRange **)soap_malloc(soap, sizeof(struct ns2__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IntRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IntRange, sizeof(struct ns2__IntRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IntRange(struct soap *soap, struct ns2__IntRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IntRange);
	if (soap_out_PointerTons2__IntRange(soap, tag?tag:"ns2:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntRange ** SOAP_FMAC4 soap_get_PointerTons2__IntRange(struct soap *soap, struct ns2__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UserExtension(struct soap *soap, struct ns2__UserExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UserExtension))
		soap_serialize_ns2__UserExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UserExtension(struct soap *soap, const char *tag, int id, struct ns2__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UserExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UserExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__UserExtension ** SOAP_FMAC4 soap_in_PointerTons2__UserExtension(struct soap *soap, const char *tag, struct ns2__UserExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__UserExtension **)soap_malloc(soap, sizeof(struct ns2__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UserExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UserExtension, sizeof(struct ns2__UserExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UserExtension(struct soap *soap, struct ns2__UserExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UserExtension);
	if (soap_out_PointerTons2__UserExtension(soap, tag?tag:"ns2:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__UserExtension ** SOAP_FMAC4 soap_get_PointerTons2__UserExtension(struct soap *soap, struct ns2__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoEncoderConfiguration(struct soap *soap, struct ns2__VideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoEncoderConfiguration))
		soap_serialize_ns2__VideoEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct ns2__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTons2__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct ns2__VideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct ns2__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoEncoderConfiguration, sizeof(struct ns2__VideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoEncoderConfiguration(struct soap *soap, struct ns2__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoEncoderConfiguration);
	if (soap_out_PointerTons2__VideoEncoderConfiguration(soap, tag?tag:"ns2:VideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTons2__VideoEncoderConfiguration(struct soap *soap, struct ns2__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VideoEncoderConfigurationOptions(struct soap *soap, struct ns2__VideoEncoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions))
		soap_serialize_ns2__VideoEncoderConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct ns2__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__VideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTons2__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct ns2__VideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct ns2__VideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__VideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VideoEncoderConfigurationOptions, sizeof(struct ns2__VideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VideoEncoderConfigurationOptions(struct soap *soap, struct ns2__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VideoEncoderConfigurationOptions);
	if (soap_out_PointerTons2__VideoEncoderConfigurationOptions(soap, tag?tag:"ns2:VideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTons2__VideoEncoderConfigurationOptions(struct soap *soap, struct ns2__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MediaUri(struct soap *soap, struct ns2__MediaUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MediaUri))
		soap_serialize_ns2__MediaUri(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MediaUri(struct soap *soap, const char *tag, int id, struct ns2__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MediaUri);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MediaUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__MediaUri ** SOAP_FMAC4 soap_in_PointerTons2__MediaUri(struct soap *soap, const char *tag, struct ns2__MediaUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__MediaUri **)soap_malloc(soap, sizeof(struct ns2__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MediaUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MediaUri, sizeof(struct ns2__MediaUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MediaUri(struct soap *soap, struct ns2__MediaUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MediaUri);
	if (soap_out_PointerTons2__MediaUri(soap, tag?tag:"ns2:MediaUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MediaUri ** SOAP_FMAC4 soap_get_PointerTons2__MediaUri(struct soap *soap, struct ns2__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StreamSetup(struct soap *soap, struct ns2__StreamSetup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StreamSetup))
		soap_serialize_ns2__StreamSetup(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StreamSetup(struct soap *soap, const char *tag, int id, struct ns2__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StreamSetup);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__StreamSetup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__StreamSetup ** SOAP_FMAC4 soap_in_PointerTons2__StreamSetup(struct soap *soap, const char *tag, struct ns2__StreamSetup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__StreamSetup **)soap_malloc(soap, sizeof(struct ns2__StreamSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__StreamSetup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StreamSetup, sizeof(struct ns2__StreamSetup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StreamSetup(struct soap *soap, struct ns2__StreamSetup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__StreamSetup);
	if (soap_out_PointerTons2__StreamSetup(soap, tag?tag:"ns2:StreamSetup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__StreamSetup ** SOAP_FMAC4 soap_get_PointerTons2__StreamSetup(struct soap *soap, struct ns2__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Profile(struct soap *soap, struct ns2__Profile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Profile))
		soap_serialize_ns2__Profile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Profile(struct soap *soap, const char *tag, int id, struct ns2__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Profile);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Profile ** SOAP_FMAC4 soap_in_PointerTons2__Profile(struct soap *soap, const char *tag, struct ns2__Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Profile **)soap_malloc(soap, sizeof(struct ns2__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Profile, sizeof(struct ns2__Profile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Profile(struct soap *soap, struct ns2__Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Profile);
	if (soap_out_PointerTons2__Profile(soap, tag?tag:"ns2:Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Profile ** SOAP_FMAC4 soap_get_PointerTons2__Profile(struct soap *soap, struct ns2__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TopicNamespaceLocation(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TopicNamespaceLocation
	*a = SOAP_DEFAULT_ns2__TopicNamespaceLocation;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__TopicNamespaceLocation(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__TopicNamespaceLocation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TopicNamespaceLocation(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__TopicNamespaceLocation);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__TopicNamespaceLocation(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__TopicNamespaceLocation, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TopicNamespaceLocation(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TopicNamespaceLocation);
	if (soap_out_ns2__TopicNamespaceLocation(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__TopicNamespaceLocation(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TopicNamespaceLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AuxiliaryData(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AuxiliaryData
	*a = SOAP_DEFAULT_ns2__AuxiliaryData;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AuxiliaryData(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__AuxiliaryData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AuxiliaryData(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__AuxiliaryData);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__AuxiliaryData(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__AuxiliaryData, 1, 0, 128);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AuxiliaryData(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AuxiliaryData);
	if (soap_out_ns2__AuxiliaryData(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__AuxiliaryData(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Domain(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Domain
	*a = SOAP_DEFAULT_ns2__Domain;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Domain(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__Domain);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Domain(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__Domain);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__Domain(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__Domain, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Domain(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Domain);
	if (soap_out_ns2__Domain(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__Domain(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Domain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DNSName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DNSName
	*a = SOAP_DEFAULT_ns2__DNSName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DNSName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__DNSName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DNSName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__DNSName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__DNSName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__DNSName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DNSName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DNSName);
	if (soap_out_ns2__DNSName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__DNSName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__HwAddress(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__HwAddress
	*a = SOAP_DEFAULT_ns2__HwAddress;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__HwAddress(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__HwAddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HwAddress(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__HwAddress);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__HwAddress(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__HwAddress, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__HwAddress(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__HwAddress);
	if (soap_out_ns2__HwAddress(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__HwAddress(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HwAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv6Address(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IPv6Address
	*a = SOAP_DEFAULT_ns2__IPv6Address;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv6Address(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__IPv6Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv6Address(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__IPv6Address);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__IPv6Address(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__IPv6Address, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv6Address(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv6Address);
	if (soap_out_ns2__IPv6Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__IPv6Address(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IPv4Address(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IPv4Address
	*a = SOAP_DEFAULT_ns2__IPv4Address;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IPv4Address(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__IPv4Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IPv4Address(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__IPv4Address);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__IPv4Address(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__IPv4Address, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IPv4Address(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IPv4Address);
	if (soap_out_ns2__IPv4Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__IPv4Address(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Name(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__Name
	*a = SOAP_DEFAULT_ns2__Name;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Name(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__Name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__Name(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__Name, 1, 0, 64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Name);
	if (soap_out_ns2__Name(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ReferenceToken(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ReferenceToken
	*a = SOAP_DEFAULT_ns2__ReferenceToken;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ReferenceToken(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ReferenceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__ReferenceToken, 1, 0, 64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ReferenceToken);
	if (soap_out_ns2__ReferenceToken(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__token(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__token
	*a = SOAP_DEFAULT_xsd__token;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__integer(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__integer
	*a = SOAP_DEFAULT_xsd__integer;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__anyURI
	*a = SOAP_DEFAULT_xsd__anyURI;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anySimpleType(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__anySimpleType
	*a = SOAP_DEFAULT_xsd__anySimpleType;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anySimpleType);
	if (soap_out_xsd__anySimpleType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptedKeyType);
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xenc__ReferenceList);
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__xenc__union_ReferenceList);
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__ReferenceType);
	if (soap_out_PointerToxenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertyType);
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__TransformsType);
	if (soap_out_PointerToxenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherReferenceType);
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertiesType);
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherDataType);
	if (soap_out_PointerToxenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ds__KeyInfo);
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag?tag:"ds:KeyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionMethodType);
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
